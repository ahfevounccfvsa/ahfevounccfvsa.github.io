<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cmlanche</title>
  
  <subtitle>金鳞岂是池中物</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cmlanche.com/"/>
  <updated>2019-04-11T09:21:12.000Z</updated>
  <id>http://www.cmlanche.com/</id>
  
  <author>
    <name>cmlanche</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>给Appium内置系统对话框自动处理 - appium-uiautomator2-driver篇</title>
    <link href="http://www.cmlanche.com/2019/04/11/%E7%BB%99Appium%E5%86%85%E7%BD%AE%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86---appium-uiautomator2-driver%E7%AF%87/"/>
    <id>http://www.cmlanche.com/2019/04/11/给Appium内置系统对话框自动处理---appium-uiautomator2-driver篇/</id>
    <published>2019-04-11T09:02:20.000Z</published>
    <updated>2019-04-11T09:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎关注我的Appium知乎专栏：<a href="https://zhuanlan.zhihu.com/custom-appium" target="_blank" rel="noopener">自定义Appium之路</a></p><p>当appium脚本的uiautomationName设置为UiAutomator2时，就会启动appium-uiautomator2-driver这个driver来执行你的脚本测试，而它的系统对话框的处理跟UIAutomator1的就不一样了，更加复杂一点。</p><p>因为UIAutomator2是一个apk形式的，本身可以认为是一个应用，是需要安装的，所以在启动UIAutomator2之前，就会碰到系统对话框的问题，此时，我们需要借助UIAutomator1来做这件事。</p><h3 id="大体流程是："><a href="#大体流程是：" class="headerlink" title="大体流程是："></a>大体流程是：</h3><ol><li>启动UIAutomator1</li><li>用UIAutomator1来处理权限框</li><li>安装各种apk，包括UIAutomator2的apk</li><li>杀死UIAutomator1服务</li><li>启动UIAutomator2</li><li>使用UIAutomator2来监控界面，处理系统对话框</li></ol><h3 id="怎么做呢？"><a href="#怎么做呢？" class="headerlink" title="怎么做呢？"></a>怎么做呢？</h3><p>首先我们需要修改appium-uiautomator2-driver，因为原本的执行流程根本没有UIAutomator1的事情，我们需要把UIAutomator1引用进来：(appium-uiautomator2-driver/lib/driver.js)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; androidHelpers, androidCommands, SETTINGS_HELPER_PKG_ID, UiAutomator &#125; <span class="keyword">from</span> <span class="string">'appium-android-driver-cmext'</span>;</span><br></pre></td></tr></table></figure><p>上面代码中的UiAutomator是我新加的，但是在appium-android-driver中并没有导出UiAutomator的，我们需要给它导出来：(在appium-uiautomator2-driver/index.js)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> driver <span class="keyword">from</span> <span class="string">'./lib/driver'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> androidHelperIndex <span class="keyword">from</span> <span class="string">'./lib/android-helpers'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> commandIndex <span class="keyword">from</span> <span class="string">'./lib/commands/index'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> webview <span class="keyword">from</span> <span class="string">'./lib/webview-helpers'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> caps <span class="keyword">from</span> <span class="string">'./lib/desired-caps'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> uia <span class="keyword">from</span> <span class="string">'./lib/uiautomator'</span>;   <span class="comment">// 这是新增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; AndroidDriver &#125; = driver;</span><br><span class="line"><span class="keyword">const</span> &#123; UiAutomator &#125; = uia; <span class="comment">// 这是新增</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">helpers</span>: webviewHelpers, NATIVE_WIN, WEBVIEW_WIN, WEBVIEW_BASE,</span><br><span class="line">        CHROMIUM_WIN &#125; = webview;</span><br><span class="line"><span class="keyword">const</span> &#123; commonCapConstraints &#125; = caps;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">commands</span>: androidCommands &#125; = commandIndex;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">helpers</span>: androidHelpers, SETTINGS_HELPER_PKG_ID &#125; = androidHelperIndex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AndroidDriver;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  androidHelpers, androidCommands, AndroidDriver, startServer,</span><br><span class="line">  commonCapConstraints, webviewHelpers, NATIVE_WIN, WEBVIEW_WIN,</span><br><span class="line">  WEBVIEW_BASE, CHROMIUM_WIN, SETTINGS_HELPER_PKG_ID, UiAutomator <span class="comment">// 这是新增</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>添加一个启动UIAutomator1服务的方法：(appium-uiautomator2-driver/lib/driver.js)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> startUiAutomator1Service () &#123;</span><br><span class="line">  <span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'..'</span>, <span class="string">'appium-android-driver'</span>);</span><br><span class="line">  <span class="keyword">const</span> startDetector = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="regexp">/Appium Socket Server Ready/</span>.test(s); &#125;;</span><br><span class="line">  <span class="keyword">const</span> bootstrapJar = path.resolve(rootDir, <span class="string">'bootstrap'</span>, <span class="string">'bin'</span>, <span class="string">'AppiumBootstrap.jar'</span>);</span><br><span class="line">  <span class="keyword">this</span>.uiAutomator = <span class="keyword">new</span> UiAutomator(<span class="keyword">this</span>.adb);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.uiAutomator.start(</span><br><span class="line">    bootstrapJar, <span class="string">'io.appium.android.bootstrap.Bootstrap'</span>,</span><br><span class="line">    startDetector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这个driver.js没有导入path，我们还要导入path：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">'path'</span>;</span><br></pre></td></tr></table></figure><p>然后我们找到<code>startUiAutomator2Session</code>方法，分别添加如下代码：</p><ol><li><p>启动UIAutomator1的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动UIAutomator2之前，先启动UIAutomator1服务来处理系统框</span></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.startUiAutomator1Service();</span><br></pre></td></tr></table></figure></li><li><p>kill UIAutomator1的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在启动UIAutomator2之前，要先杀死UIAutomator1服务，否则UIAutomator2无法启动</span></span><br><span class="line"><span class="comment">// 因为UIAutomator只允许同时存在一个</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.uiAutomator) &#123;</span><br><span class="line"><span class="keyword">this</span>.uiAutomator.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>位置如下图：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/awqkh.png" alt="image-20190411171620414"></p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/2am2t.png" alt="image-20190411171642533"></p><p>自此，nodejs的事情就完成了，剩下的就是要改造appium-uiautomator2-server的代码，让它能够像UIAutomator1一样监听界面，自动处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎关注我的Appium知乎专栏：&lt;a href=&quot;https://zhuanlan.zhihu.com/custom-appium&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自定义Appium之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当appium脚本的uiaut
      
    
    </summary>
    
    
      <category term="appium" scheme="http://www.cmlanche.com/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>系统对话框自动处理流程</title>
    <link href="http://www.cmlanche.com/2019/04/11/%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%87%AA%E5%8A%A8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.cmlanche.com/2019/04/11/系统对话框自动处理流程/</id>
    <published>2019-04-11T08:35:58.000Z</published>
    <updated>2019-04-11T08:35:58.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="appium" scheme="http://www.cmlanche.com/tags/appium/"/>
    
      <category term="自动化测试" scheme="http://www.cmlanche.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>自定义系统框处理 – 有哪些方法？</title>
    <link href="http://www.cmlanche.com/2019/04/11/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%A4%84%E7%90%86-%E2%80%93-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F/"/>
    <id>http://www.cmlanche.com/2019/04/11/自定义系统框处理-–-有哪些方法？/</id>
    <published>2019-04-11T08:20:22.000Z</published>
    <updated>2019-04-11T08:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>系统框处理流程有哪些方法？</p><h3 id="adb赋予权限"><a href="#adb赋予权限" class="headerlink" title="adb赋予权限"></a>adb赋予权限</h3><ol><li>优点：用户无感知</li><li>缺点：<ol><li>只能解决小部分问题，无法对所有手机和系统版本兼容</li><li>不仅仅是系统<strong>权限</strong>框，<strong>其他弹出的系统框</strong>也要处理，如系统<strong>更新</strong>对话框</li></ol></li></ol><h3 id="单独写appium脚本去处理"><a href="#单独写appium脚本去处理" class="headerlink" title="单独写appium脚本去处理"></a><del>单独写appium脚本去处理</del></h3><p>此方案无法做到，因为权限框处理在脚本之前</p><h3 id="在PC端额外开启一个线程去做权限框处理"><a href="#在PC端额外开启一个线程去做权限框处理" class="headerlink" title="在PC端额外开启一个线程去做权限框处理"></a>在PC端额外开启一个线程去做权限框处理</h3><ol><li>优点：无需改造Appium</li><li>缺点：在pc端额外维护一个处理流程，并且需要不断的去请求dump控件树，再拉取到pc端解析<ol><li>流程过于复杂，不稳定</li><li>处理不及时</li><li>控件树信息塞选可能有漏，无法从根本上解决</li></ol></li></ol><h3 id="自定义appium，添加监控代码，使appium自带这种功能"><a href="#自定义appium，添加监控代码，使appium自带这种功能" class="headerlink" title="自定义appium，添加监控代码，使appium自带这种功能"></a>自定义appium，添加监控代码，使appium自带这种功能</h3><ol><li>优点：深度定制Appium，内置权限框处理<ol><li>内置，有问题可以从根本上解决</li><li>原生，处理速度及时，速度快</li><li>系统框信息自定义配置，有新的无法解决的对话框，可以只修改配置即可**</li></ol></li><li><strong>缺点：</strong><ol><li>需要定制Appium，难度大</li><li>Appium版本更新的话，需要拉取，会有代码上的冲突**</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;系统框处理流程有哪些方法？&lt;/p&gt;
&lt;h3 id=&quot;adb赋予权限&quot;&gt;&lt;a href=&quot;#adb赋予权限&quot; class=&quot;headerlink&quot; title=&quot;adb赋予权限&quot;&gt;&lt;/a&gt;adb赋予权限&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;优点：用户无感知&lt;/li&gt;
&lt;li&gt;缺点：&lt;o
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>appium的技术架构</title>
    <link href="http://www.cmlanche.com/2019/04/11/appium%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.cmlanche.com/2019/04/11/appium的技术架构/</id>
    <published>2019-04-11T07:29:27.000Z</published>
    <updated>2019-04-11T08:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎关注我的Appium知乎专栏：<a href="https://zhuanlan.zhihu.com/custom-appium" target="_blank" rel="noopener">自定义Appium之路</a></p><p>appium是基于nodejs来打包、发布的，也用它来管理各个driver，如下图所示，它的结构图如下：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/4y4w5.png" alt="image-20190411154231747"></p><p>从上图就可以看到：<strong>android的自动化比iOS的要难多了！</strong></p><p>appium主程序，依赖各个driver程序，其中，安卓的自动化有3个driver，分别是：</p><ol><li>appium-android-driver - 用于驱动UIAutomator1</li><li>appium-uiautomator2-driver - 用于驱动UIAutomator2</li><li>appium-espresso-driver - 用于驱动Espresso</li></ol><p>列个表对比一下：</p><table><thead><tr><th>功能\Driver</th><th>appium-android-driver</th><th>appium-uiautomator2-driver</th><th>appium-espresso-driver</th></tr></thead><tbody><tr><td>用途</td><td>驱动UIAutomator1</td><td>驱动UIAutomator2</td><td>驱动espresso</td></tr><tr><td>automationName</td><td>UiAutomator1</td><td>UiAutomator2</td><td>Espresso</td></tr><tr><td>包形式</td><td>AppiumBootstrap.jar</td><td>appium-uiautomator2-server-v${version}.apk</td><td>TODO待研究</td></tr><tr><td>包依赖地址</td><td>bootstrap/bin/</td><td>appium-uiautomator2-server/apks/</td><td>TODO</td></tr><tr><td>优点</td><td>jar包形式，免安装，一个命令直接启动，权限级别是shell级别</td><td>官方推荐使用2，对高版本兼容性好</td><td>控件识别能力强</td></tr><tr><td>缺点</td><td>对高版本兼容性差，容易无法识别控件</td><td>apk形式，需要安装</td><td>apk形式，需求安装，并且是侵入式的，可能带来风险</td></tr><tr><td>Server模块</td><td>在相同工程中，Bootstrap目录，maven工程，主要目标是在bin目录下输出AppiumBootstrap.jar</td><td>不同工程，单独的另外一个Nodejs工程：appium-uiautomator2-server</td><td>相同Nodejs工程，espress-server目录，gradle工程</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎关注我的Appium知乎专栏：&lt;a href=&quot;https://zhuanlan.zhihu.com/custom-appium&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自定义Appium之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;appium是基于nodejs
      
    
    </summary>
    
    
      <category term="appium" scheme="http://www.cmlanche.com/tags/appium/"/>
    
  </entry>
  
  <entry>
    <title>给 Appium 内置系统对话框处理吧！appium-android-driver 篇</title>
    <link href="http://www.cmlanche.com/2019/04/11/Appium%E7%9A%84UIAutomator1%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9D%83%E9%99%90%E6%A1%86%E5%A4%84%E7%90%86/"/>
    <id>http://www.cmlanche.com/2019/04/11/Appium的UIAutomator1的自定义权限框处理/</id>
    <published>2019-04-11T07:18:46.000Z</published>
    <updated>2019-04-11T08:55:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎关注我的Appium知乎专栏：<a href="https://zhuanlan.zhihu.com/custom-appium" target="_blank" rel="noopener">自定义Appium之路</a></p><p>当Appium脚本中的uiautomationName设置为UiAutomator1时，会启动UIAutomator1的Driver来测试你的Appium脚本，在脚本之前之前，会有很多权限框弹出，此时就需要我们的UIAutomator1来自动处理这样的对话框，并且要在安装apk之前就启动UIAutomator1的服务。</p><p>很不幸，appium的代码中，是先安装Appium Setting APK和被测应用的，那怎么改呢？</p><p>我们找到appium-android-driver工程，找打lib/driver.js，然后找到startAndroidSession方法，将如下代码提到这个方法的最前面：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// start UiAutomator （改动：优先启动UIAutomator1）</span></span><br><span class="line"><span class="keyword">this</span>.bootstrap = <span class="keyword">new</span> helpers.bootstrap(<span class="keyword">this</span>.adb, <span class="keyword">this</span>.bootstrapPort, <span class="keyword">this</span>.opts.websocket);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.bootstrap.start(<span class="keyword">this</span>.opts.appPackage, <span class="keyword">this</span>.opts.disableAndroidWatchers, <span class="keyword">this</span>.opts.acceptSslCerts);</span><br><span class="line"><span class="comment">// handling unexpected shutdown</span></span><br><span class="line"><span class="keyword">this</span>.bootstrap.onUnexpectedShutdown.catch(<span class="keyword">async</span> (err) =&gt; &#123; <span class="comment">// eslint-disable-line promise/prefer-await-to-callbacks</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.bootstrap.ignoreUnexpectedShutdown) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.startUnexpectedShutdown(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/5vr6h.png" alt="image-20190411164422233"></p><p>经过测试，这样不会影响UIAutomator1的正常启动，不会带来负面影响。</p><p>既然都优先启动了，我们就要让UIAutomator1去监控手机界面了。</p><p>不幸的是，Appium并没有给我们写类似的监听代码，我们得自己动手了，其实很简单，大体思路就是，dump控件树，检测界面控件，检测到权限框，就点”允许”、”是”之类的，这里就需要不断的枚举了。国内手机产商众多，android版本也多，这里就有大量的工作要做了。</p><p>幸运的是，Appium给我们做好了监控的线程，只是空实现，基本啥都没干，代码在SocketServer.java的listenForever中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenForever</span><span class="params">(<span class="keyword">boolean</span> disableAndroidWatchers, <span class="keyword">boolean</span> acceptSSLCerts)</span> <span class="keyword">throws</span> SocketServerException </span>&#123;</span><br><span class="line">  Logger.debug(<span class="string">"Appium Socket Server Ready"</span>);</span><br><span class="line">  UpdateStrings.loadStringsJson();</span><br><span class="line">  <span class="keyword">if</span> (disableAndroidWatchers) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"Skipped registering crash watchers."</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dismissCrashAlerts();</span><br><span class="line">    <span class="comment">// 看这里，就是这个每隔100毫秒触发一次的check !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="keyword">final</span> TimerTask updateWatchers = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          watchers.check();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    timer.scheduleAtFixedRate(updateWatchers, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (acceptSSLCerts) &#123;</span><br><span class="line">    Logger.debug(<span class="string">"Accepting SSL certificate errors."</span>);</span><br><span class="line">    acceptSSLCertificates();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    client = server.accept();</span><br><span class="line">    Logger.debug(<span class="string">"Client connected"</span>);</span><br><span class="line">    in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">    out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream(), <span class="string">"UTF-8"</span>));</span><br><span class="line">    <span class="keyword">while</span> (keepListening) &#123;</span><br><span class="line">      handleClientData();</span><br><span class="line">    &#125;</span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">    client.close();</span><br><span class="line">    Logger.debug(<span class="string">"Closed client connection"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SocketServerException(<span class="string">"Error when client was trying to connect"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎关注我的Appium知乎专栏：&lt;a href=&quot;https://zhuanlan.zhihu.com/custom-appium&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自定义Appium之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当Appium脚本中的uiau
      
    
    </summary>
    
    
      <category term="appium" scheme="http://www.cmlanche.com/tags/appium/"/>
    
      <category term="uiautomator" scheme="http://www.cmlanche.com/tags/uiautomator/"/>
    
  </entry>
  
  <entry>
    <title>独立开发者的开放心态：帮助他人，其实就是在帮你自己！</title>
    <link href="http://www.cmlanche.com/2019/04/11/Open%E5%BF%83%E6%80%81/"/>
    <id>http://www.cmlanche.com/2019/04/11/Open心态/</id>
    <published>2019-04-11T03:01:19.000Z</published>
    <updated>2019-04-11T03:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>不要怕被抄袭，心态要开放，往往收获会更多</li><li>理念：你身边的朋友都富有了，你才更有机会富有；帮助他人，其实就是帮你自己！</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;不要怕被抄袭，心态要开放，往往收获会更多&lt;/li&gt;
&lt;li&gt;理念：你身边的朋友都富有了，你才更有机会富有；帮助他人，其实就是帮你自己！&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>appium怎么本地执行、调试</title>
    <link href="http://www.cmlanche.com/2019/04/09/appium%E6%80%8E%E4%B9%88%E6%9C%AC%E5%9C%B0%E6%89%A7%E8%A1%8C%E3%80%81%E8%B0%83%E8%AF%95/"/>
    <id>http://www.cmlanche.com/2019/04/09/appium怎么本地执行、调试/</id>
    <published>2019-04-09T06:36:34.000Z</published>
    <updated>2019-04-11T07:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎关注我的Appium知乎专栏：<a href="https://zhuanlan.zhihu.com/custom-appium" target="_blank" rel="noopener">自定义Appium之路</a></p><h3 id="本地执行"><a href="#本地执行" class="headerlink" title="本地执行"></a>本地执行</h3><p>通常的执行方式是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 下载npm库中的appium</span><br><span class="line">npm i -g appium </span><br><span class="line"><span class="meta">#</span> 启动appium服务器</span><br><span class="line">appium</span><br></pre></td></tr></table></figure><p>但如果是本地appium代码怎么执行呢？请看如下shell脚本</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 克隆appium代码</span><br><span class="line">git clone https://github.com/appium/appium.git</span><br><span class="line"><span class="meta">#</span> 安装依赖</span><br><span class="line">npm install</span><br><span class="line"><span class="meta">#</span> 编译</span><br><span class="line">gulp transpile</span><br><span class="line"><span class="meta">#</span> 本地启动appium</span><br><span class="line">./build/lib/main.js</span><br></pre></td></tr></table></figure><p>只查看AndroidDriver的日志怎么做？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./build/lib/main.js | grep AndroidDriver</span><br></pre></td></tr></table></figure><h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><ol><li><p>配置VS Code的调试器</p><p>按F5，打开调试器，选择node.js，会生成一个launch.json的配置文件，这个配置文件用来启动程序的:</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    "version": "0.2.0",</span><br><span class="line">    "configurations": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Appium"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/appium/build/lib/main.js"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置好launch.json之后，启动调试，会出现如下工具栏：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/a56nt.png" alt="image-20190409150446005"></p><p>其含义分别是：继续执行、单步到下一步、跳转到里面、跳出、重启、停止。</p></li></ol><h3 id="本地其他库的调试"><a href="#本地其他库的调试" class="headerlink" title="本地其他库的调试"></a>本地其他库的调试</h3><h5 id="方法1：npm-link-创建软链"><a href="#方法1：npm-link-创建软链" class="headerlink" title="方法1：npm link 创建软链"></a>方法1：npm link 创建软链</h5><p>通过上面的配置，我们可以调试appium工程，但是本地其他工程无法调试，因为都是直接走的依赖库，此时我们只需要用link命令就可以完成本地库与实际依赖库的关联。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm link ../appium-android-driver</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chengmingdeMacBook-Pro:appium cmlanche$ npm link ../appium-android-driver</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span> appium-android-driver-cmext@4.11.0-20190409a prepare /Users/cmlanche/sourcetree/appium/appium-android-driver</span><br><span class="line"><span class="meta">&gt;</span> gulp prepublish</span><br><span class="line"></span><br><span class="line">[15:50:55] Using gulpfile ~/sourcetree/appium/appium-android-driver/gulpfile.js</span><br><span class="line">[15:50:55] Starting 'prepublish'...</span><br><span class="line">[15:50:55] Starting 'clean'...</span><br><span class="line">[15:50:55] Finished 'clean' after 71 ms</span><br><span class="line">[15:50:55] Starting 'transpile'...</span><br><span class="line">[15:50:59] Finished 'transpile' after 3.75 s</span><br><span class="line">[15:50:59] Finished 'prepublish' after 3.83 s</span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">audited 29538 packages in 14.08s</span><br><span class="line">found 2 moderate severity vulnerabilities</span><br><span class="line">  run `npm audit fix` to fix them, or `npm audit` for details</span><br><span class="line">/usr/local/lib/node_modules/appium-android-driver-cmext -&gt; /Users/cmlanche/sourcetree/appium/appium-android-driver</span><br><span class="line">/Users/cmlanche/sourcetree/appium/appium/node_modules/appium-android-driver-cmext -&gt; /usr/local/lib/node_modules/appium-android-driver-cmext -&gt; /Users/cmlanche/sourcetree/appium/appium-android-driver</span><br></pre></td></tr></table></figure><h5 id="方法2：依赖本地仓库"><a href="#方法2：依赖本地仓库" class="headerlink" title="方法2：依赖本地仓库"></a>方法2：依赖本地仓库</h5><p>切换到appium工程目录下，安装我自定义的uiautomator2-driver</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i appium-uiautomator2-driver-cmext@"file:../appium-uiautomator2-driver"</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chengmingdeMacBook-Pro:appium cmlanche$ npm i appium-uiautomator2-driver-cmext@"file:../appium-uiautomator2-driver"</span><br><span class="line">+ appium-uiautomator2-driver-cmext@1.33.0-20190410f</span><br><span class="line">removed 1 package and updated 1 package in 24.494s</span><br></pre></td></tr></table></figure><p>当本地库修改后，运行<code>npm i</code>重新编译一下，就可以继续调试了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎关注我的Appium知乎专栏：&lt;a href=&quot;https://zhuanlan.zhihu.com/custom-appium&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自定义Appium之路&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;本地执行&quot;&gt;&lt;a href=&quot;#本地执行&quot; class=&quot;headerlink&quot; title=&quot;本地执行&quot;&gt;&lt;/a&gt;本地执行&lt;/h3&gt;&lt;p&gt;通常的执行方式是：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; 下载npm库中的appium&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm i -g appium &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; 启动appium服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;appium&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但如果是本地appium代码怎么执行呢？请看如下shell脚本&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>怎么证明你买的域名是你的？</title>
    <link href="http://www.cmlanche.com/2019/04/04/%E6%80%8E%E4%B9%88%E8%AF%81%E6%98%8E%E4%BD%A0%E4%B9%B0%E7%9A%84%E5%9F%9F%E5%90%8D%E6%98%AF%E4%BD%A0%E7%9A%84/"/>
    <id>http://www.cmlanche.com/2019/04/04/怎么证明你买的域名是你的/</id>
    <published>2019-04-04T11:59:39.000Z</published>
    <updated>2019-04-04T12:24:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的”独立开发者”微信群中网友问的，我之前还从来没想过这个问题，自认为买了就是我的。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/yy68o.png" alt="1"></p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/lcil0.png" alt="2"></p><p>但仔细一想，其实这件事没有那么简单，比如我在阿里云万网买了域名，我可以对这个域名做任何操作，然而这个操作是建立在阿里云这个平台上的，也就是说，阿里云也可以随时强制收回这个域名，可以强制更改这个域名的所有者，可以禁用转移等，也就是说，你买了的这个域名，真正的所有者是这个平台，是阿里云！</p><a id="more"></a><p>我特意在知乎和v2ex这两个平台发出这样的提问：</p><ol><li>知乎：<a href="https://www.zhihu.com/question/318726785" target="_blank" rel="noopener">https://www.zhihu.com/question/318726785</a></li><li>v2ex：<a href="https://www.v2ex.com/t/552018" target="_blank" rel="noopener">https://www.v2ex.com/t/552018</a></li></ol><p>大体上有个初步的认识：</p><ol><li>你所购买的域名确实是你的，你可以用whoise查询，查询结果中是你的联系人信息。</li><li>你买的域名，你可以获得一个转移码的东西，你可以用它来转移的你的域名到另外一个平台，比如从阿里云转到godaddy.com。</li><li>平台确实可以随意改动你的域名的任何信息，但是它只要改了，就会有污点，就会存在记录，你可以凭借记录到ICANN（国际域名管理组织）或者CNNIC（中国域名注册局，管理.cn和中文域名系统）申诉。</li><li>其实平台一般不会做这种蠢事，不然就失去了平台最根本的东西，这样也会给自己留下污点，对自己更不利。不过据说阿里干过，参见”<a href="https://www.williamlong.info/weibo/archives/763.html" target="_blank" rel="noopener">万网封停慧聪网域名事件</a>“。</li><li>总结下来就是，不要把自己的域名放在竞争对手那里，最好在国外域名服务产商购买，如godaddy，namesilo，namecheap等，因为别人跟你毫无瓜葛，没必要对你的域名干啥坏事。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我的”独立开发者”微信群中网友问的，我之前还从来没想过这个问题，自认为买了就是我的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/yy68o.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/lcil0.png&quot; alt=&quot;2&quot;&gt;&lt;/p&gt;
&lt;p&gt;但仔细一想，其实这件事没有那么简单，比如我在阿里云万网买了域名，我可以对这个域名做任何操作，然而这个操作是建立在阿里云这个平台上的，也就是说，阿里云也可以随时强制收回这个域名，可以强制更改这个域名的所有者，可以禁用转移等，也就是说，你买了的这个域名，真正的所有者是这个平台，是阿里云！&lt;/p&gt;
    
    </summary>
    
    
      <category term="域名" scheme="http://www.cmlanche.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>初步成功自定义Appium</title>
    <link href="http://www.cmlanche.com/2019/04/01/%E5%88%9D%E6%AD%A5%E6%88%90%E5%8A%9F%E8%87%AA%E5%AE%9A%E4%B9%89Appium/"/>
    <id>http://www.cmlanche.com/2019/04/01/初步成功自定义Appium/</id>
    <published>2019-04-01T09:36:08.000Z</published>
    <updated>2019-04-02T10:52:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改造appium-android-driver"><a href="#改造appium-android-driver" class="headerlink" title="改造appium-android-driver"></a>改造appium-android-driver</h1><p>这个driver是UIAutomator1的driver，负责UIAutomator1的服务启动、停止、命令接收和执行。</p><h3 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h3><ul><li>appium-android-driver(NodeJS工程)<ul><li>bootstrap(Maven工程)</li></ul></li></ul><p>本身appium-android-driver是一个nodejs工程，它还套着一个bootstrap的maven工程，这个maven工程就是用来打包UIAutomator1的，会再bootstrap/bin的目录下构建生成一个叫AppiumBootstrap.jar的供外层的NodeJS工程使用。代码在<code>appium-android-driver/lib/bootstrap.js</code>的start函数中</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> rootDir = path.resolve(__dirname, <span class="string">'..'</span>, <span class="string">'..'</span>);</span><br><span class="line"><span class="keyword">const</span> startDetector = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123; <span class="keyword">return</span> <span class="regexp">/Appium Socket Server Ready/</span>.test(s); &#125;;</span><br><span class="line"><span class="keyword">const</span> bootstrapJar = path.resolve(rootDir, <span class="string">'bootstrap'</span>, <span class="string">'bin'</span>, <span class="string">'AppiumBootstrap.jar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.init();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.adb.forwardPort(<span class="keyword">this</span>.systemPort, <span class="number">4724</span>);</span><br><span class="line"><span class="keyword">this</span>.process = <span class="keyword">await</span> <span class="keyword">this</span>.uiAutomator.start(</span><br><span class="line">                 bootstrapJar, <span class="string">'io.appium.android.bootstrap.Bootstrap'</span>,</span><br><span class="line">                 startDetector, <span class="string">'-e'</span>, <span class="string">'pkg'</span>, appPackage,</span><br><span class="line">                 <span class="string">'-e'</span>, <span class="string">'disableAndroidWatchers'</span>, disableAndroidWatchers,</span><br><span class="line">                 <span class="string">'-e'</span>, <span class="string">'acceptSslCerts'</span>, acceptSslCerts);</span><br></pre></td></tr></table></figure><h3 id="修改pom-xml，编译bootstrap，输出AppiumBootstrap-jar"><a href="#修改pom-xml，编译bootstrap，输出AppiumBootstrap-jar" class="headerlink" title="修改pom.xml，编译bootstrap，输出AppiumBootstrap.jar"></a>修改pom.xml，编译bootstrap，输出AppiumBootstrap.jar</h3><p>bootstrap工程是一个maven工程，用idea直接open这个文件夹即可，找到pom.xml，右键Maven-&gt;Reimport，我们会发现有两个maven依赖无法导入，报找不到对应的jar包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>android<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>android<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.2_r4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>android.test.uiautomator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>uiautomator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.2_r4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原因是默认的仓库是从<a href="https://repo.maven.appache.org/maven2" target="_blank" rel="noopener">https://repo.maven.appache.org/maven2</a>中找的，而这个仓库根本没有这两个库。</p><p>后来我发现Boundless的仓库<a href="http://repo.boundlessgeo.com/main/" target="_blank" rel="noopener">http://repo.boundlessgeo.com/main/</a>中是有的，在这个pom.xml中配置这个仓库就可以下载了。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>Boundless<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.boundlessgeo.com/main/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖库搞定后，cmd切换到bootstrap文件夹目录下，执行<code>mvn clean package</code>构建maven工程，我们会发现，并没有在bin目录下生成AndroidBootstrap.jar，此时要修改pom.xml中的<code>maven-jar-plugin</code>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--jar输出目录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>./bin<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--输出的jar包名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>AppiumBootstrap<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新执行<code>mvn clean package</code>，AppiumBootstrap.jar就完成了正常构建，也就是说UIAutomator1构建好了。</p><h3 id="自定义appium-android-driver，并发布"><a href="#自定义appium-android-driver，并发布" class="headerlink" title="自定义appium-android-driver，并发布"></a>自定义appium-android-driver，并发布</h3><p>找到appium-android-driver/package.json，修改name，比如修改为<code>appium-android-driver2</code>，然后顺便修改下version，然后再appium-android-driver根目录下执行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install  # 重新安装依赖</span><br><span class="line">npm publish  # 发布</span><br></pre></td></tr></table></figure><p><code>npm publish</code>是发布nodejs包的命令，需要你在<a href="[https://www.npmjs.com](https://www.npmjs.com/">npmjs.com</a>)上注册自己的账号，发布的时候需要验证你的账号。</p><h1 id="自定义Appium"><a href="#自定义Appium" class="headerlink" title="自定义Appium"></a>自定义Appium</h1><p>跟自定义appium-android-driver一样，我们找到package.json，修改name和version，比如分别是appium2和1.12.1-20190401a，顺便我们修改一下lib/main.js中的一条语句，以验证我们的修改是否生效：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logStartupInfo</span> (<span class="params">parser, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> welcome = <span class="string">`Welcome to Appium2 v<span class="subst">$&#123;APPIUM_VER&#125;</span>, modified by chengming`</span>; <span class="comment">// 我修改了此处</span></span><br><span class="line">  <span class="keyword">let</span> appiumRev = <span class="keyword">await</span> getGitRev();</span><br><span class="line">  <span class="keyword">if</span> (appiumRev) &#123;</span><br><span class="line">    welcome += <span class="string">` (REV <span class="subst">$&#123;appiumRev&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  logger.info(welcome);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> showArgs = getNonDefaultArgs(parser, args);</span><br><span class="line">  <span class="keyword">if</span> (_.size(showArgs)) &#123;</span><br><span class="line">    logNonDefaultArgsWarning(showArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> deprecatedArgs = getDeprecatedArgs(parser, args);</span><br><span class="line">  <span class="keyword">if</span> (_.size(deprecatedArgs)) &#123;</span><br><span class="line">    logDeprecationWarning(deprecatedArgs);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!_.isEmpty(args.defaultCapabilities)) &#123;</span><br><span class="line">    logDefaultCapabilitiesWarning(args.defaultCapabilities);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> bring back loglevel reporting below once logger is flushed out</span></span><br><span class="line">  <span class="comment">// logger.info('Console LogLevel: ' + logger.transports.console.level);</span></span><br><span class="line">  <span class="comment">// if (logger.transports.file) &#123;</span></span><br><span class="line">  <span class="comment">//   logger.info('File LogLevel: ' + logger.transports.file.level);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有要在<code>package.json</code>中，找到dependencies，把我们的appium的UIAutomator1的依赖改为<strong>“appium-android-driver2”:”latest”</strong>，使我们自定义的appium能够使用我们自定义的<code>UIAutomator1 driver</code></p><p>同样，重新构建和发布：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>在npmjs.com网站中，我的项目下就会看到appium2的工程：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/p72ha.png" alt="image-20190402112045705"></p><h1 id="使用自定义的appium"><a href="#使用自定义的appium" class="headerlink" title="使用自定义的appium"></a>使用自定义的appium</h1><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -g appium2</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appium</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/2ytod.png" alt="image-20190402112501248"></p><h3 id="TODO：验证自定义appium-android-driver是否生效"><a href="#TODO：验证自定义appium-android-driver是否生效" class="headerlink" title="TODO：验证自定义appium-android-driver是否生效"></a>TODO：验证自定义appium-android-driver是否生效</h3><p>这个要修改bootstrap的java代码，在启动server的时候加上你的日志即可验证，后续再补充吧。</p><p># </p><h1 id="补充：2019-04-02-17：20"><a href="#补充：2019-04-02-17：20" class="headerlink" title="补充：2019-04-02 17：20"></a>补充：2019-04-02 17：20</h1><h3 id="纠正AppiumBootstrap-jar的打包方式"><a href="#纠正AppiumBootstrap-jar的打包方式" class="headerlink" title="纠正AppiumBootstrap.jar的打包方式"></a>纠正AppiumBootstrap.jar的打包方式</h3><p>官方<a href="https://github.com/appium/appium-android-driver/tree/master/bootstrap" target="_blank" rel="noopener">readme.md</a>没有说怎么打包这个jar包的事情，我按照如上述的打包方式生成的jar是不可用的，格式不正确。jar中的内容应该是一个classes.dex文件，而不是编译好的classes。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/tn66l.png" alt="image-20190402152727758"></p><p>我们需要先把class文件打包成dex，然后再把dex打包成jar，shell代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dx --dex --output=./classes.dex target/classes</span><br><span class="line">jar -cvf AppiumBootstrap.jar -C ./ ./classes.dex</span><br></pre></td></tr></table></figure><p>你需要配置好android的环境变量，使你的dx能够全局调用。</p><p>既然打包方式知道了，并且appium是要求在appium-android-driver/bootstrap/bin下有个AppiumBootstrap.jar的，那么我们去掉此前给maven-jar-plugin设置的configuration，重新编写一个shell脚本<strong>bootstrap.sh</strong>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">mvn clean package # 清理环境，编译class文件</span><br><span class="line">dx --dex --output=./target/classes.dex target/classes # 将class文件打包，生成dex文件</span><br><span class="line">jar -cvf bin/AppiumBootstrap.jar -C ./ ./target/classes.dex # 将dex文件打包，生成jar</span><br></pre></td></tr></table></figure><h3 id="测试AppiumBootstrap-jar"><a href="#测试AppiumBootstrap-jar" class="headerlink" title="测试AppiumBootstrap.jar"></a>测试AppiumBootstrap.jar</h3><p>我们找到bootstrap工程中的<code>io.appium.android.bootstrap.Bootstrap.java</code>，在testRunServer方法的第一句，添加一段注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bootstrap</span> <span class="keyword">extends</span> <span class="title">UiAutomatorTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRunServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Logger.info(<span class="string">"这是我自定义的Bootstrap，成功啦..."</span>);</span><br><span class="line">    Find.params = getParams();</span><br><span class="line">    <span class="keyword">boolean</span> disableAndroidWatchers = Boolean.parseBoolean(getParams().getString(<span class="string">"disableAndroidWatchers"</span>));</span><br><span class="line">    <span class="keyword">boolean</span> acceptSSLCerts = Boolean.parseBoolean(getParams().getString(<span class="string">"acceptSslCerts"</span>));</span><br><span class="line"></span><br><span class="line">    SocketServer server;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      server = <span class="keyword">new</span> SocketServer(<span class="number">4724</span>);</span><br><span class="line">      server.listenForever(disableAndroidWatchers, acceptSSLCerts);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> SocketServerException e) &#123;</span><br><span class="line">      Logger.error(e.getError());</span><br><span class="line">      System.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电脑插上手机，执行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chengmingdeMacBook-Pro:bootstrap cmlanche$ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">cf02d869device</span><br></pre></td></tr></table></figure><p>确保你的手机是连上电脑的。</p><p>保存，执行bootstrap.sh，在bin目录会打包好AppiumBootstrap.jar，我们把它push到手机：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">adb push ./bin/AppiumBootstrap.jar /data/<span class="built_in">local</span>/tmp/AppiumBootstrap.jar</span><br></pre></td></tr></table></figure><p>完成后，我们启动UIAutomator1的测试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb shell uiautomator runtest /data/local/tmp/AppiumBootstrap.jar -c io.appium.android.bootstrap.Bootstrap</span><br></pre></td></tr></table></figure><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/96m4l.png" alt="image-20190402171841536"></p><p>自定义AppiumBootstrap至此流程已通，接下来就是自定义权限框处理，让Appium自主识别权限框。</p><p>—— by <a href="https://cmlanche.com" target="_blank" rel="noopener">cmlanche.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;改造appium-android-driver&quot;&gt;&lt;a href=&quot;#改造appium-android-driver&quot; class=&quot;headerlink&quot; title=&quot;改造appium-android-driver&quot;&gt;&lt;/a&gt;改造appium-android-driver&lt;/h1&gt;&lt;p&gt;这个driver是UIAutomator1的driver，负责UIAutomator1的服务启动、停止、命令接收和执行。&lt;/p&gt;
&lt;h3 id=&quot;工程结构&quot;&gt;&lt;a href=&quot;#工程结构&quot; class=&quot;headerlink&quot; title=&quot;工程结构&quot;&gt;&lt;/a&gt;工程结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;appium-android-driver(NodeJS工程)&lt;ul&gt;
&lt;li&gt;bootstrap(Maven工程)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本身appium-android-driver是一个nodejs工程，它还套着一个bootstrap的maven工程，这个maven工程就是用来打包UIAutomator1的，会再bootstrap/bin的目录下构建生成一个叫AppiumBootstrap.jar的供外层的NodeJS工程使用。代码在&lt;code&gt;appium-android-driver/lib/bootstrap.js&lt;/code&gt;的start函数中&lt;/p&gt;
    
    </summary>
    
    
      <category term="appium,自定义Appium" scheme="http://www.cmlanche.com/tags/appium-%E8%87%AA%E5%AE%9A%E4%B9%89Appium/"/>
    
  </entry>
  
  <entry>
    <title>主机排行网重大更新，移动端自适应</title>
    <link href="http://www.cmlanche.com/2019/03/31/%E4%B8%BB%E6%9C%BA%E6%8E%92%E8%A1%8C%E7%BD%91%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0%EF%BC%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%87%AA%E9%80%82%E5%BA%94/"/>
    <id>http://www.cmlanche.com/2019/03/31/主机排行网重大更新，移动端自适应/</id>
    <published>2019-03-31T08:55:24.000Z</published>
    <updated>2019-03-31T09:55:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>此前有网友反馈，<a href="https://hostingranking.cn/" target="_blank" rel="noopener">主机排行网</a>在移动端表现太丑了，希望我改改，今天周末，我专门花了两个多小时来好好把移动短整治了一下，比以前好看多了。</p><h3 id="对比改变"><a href="#对比改变" class="headerlink" title="对比改变"></a>对比改变</h3><p>对比一下吧，下图是前版本的主机排行网：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/d9fyk.gif" alt="hostingranking-old-mobile"></p><a id="more"></a><p>新版效果：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/2zaim.gif" alt="hostingranking-new-mobile"></p><p>体验地址：<a href="https://hostingranking.cn/" target="_blank" rel="noopener">https://hostingranking.cn/</a></p><h3 id="本次修改的过程"><a href="#本次修改的过程" class="headerlink" title="本次修改的过程"></a>本次修改的过程</h3><p>我此前也从没真正做过移动端适配的事情，只是初步了解是通过媒体查询来做的，即当浏览器界面满足一定大小时，就会触发该媒体查询器所包含的css。</p><p>主机排行网用的css框架是bootstrap4，而bs在自适应方面是沉淀了十多年的，很强悍。我参照官网教程：<a href="https://getbootstrap.com/" target="_blank" rel="noopener">https://getbootstrap.com/</a>，重新改版了排行页中的两列布局，此前的代码是：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-10"</span>&gt;</span></span><br><span class="line">    // part 1</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-2"</span>&gt;</span></span><br><span class="line">    // part 2</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的两列布局代码会让我的界面始终是两列的，因为这里没有其他的col修饰，<code>.col-</code>在屏幕是任何大小时都生效，如果我们想让界面缩小到一定时，两列变一列，那么就不能用<code>.col-</code>来修饰了，我根据我的需求，在界面大于960px才触发两列布局，所有这里要把<code>.col-</code>改为<code>.col-lg-</code>。</p><p>这个改动完了，我希望当界面缩小到1000px以下时，主机特征那部分隐藏掉，并且在界面小于720px时隐藏掉详细评价按钮，不然内容太挤，放不小。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/n880q.png" alt="image-20190331171600304"></p><p>此时bs就没有相关的类来帮助你了，需要自己动手写媒体查询：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">media</span>(max-width: 1000px) &#123;</span><br><span class="line">  <span class="selector-class">.features</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span>(max-width: 720px) &#123;</span><br><span class="line">  <span class="selector-class">.btns</span> &#123;</span><br><span class="line">    :nth-child(2) &#123;</span><br><span class="line">      <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结收获"><a href="#总结收获" class="headerlink" title="总结收获"></a>总结收获</h3><p>此前一直不想做移动端的适配，是因为觉得很难，其实有了bs的帮助这个功能真的很好做，凡是多尝试多探索，不要不做就放弃了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此前有网友反馈，&lt;a href=&quot;https://hostingranking.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;主机排行网&lt;/a&gt;在移动端表现太丑了，希望我改改，今天周末，我专门花了两个多小时来好好把移动短整治了一下，比以前好看多了。&lt;/p&gt;
&lt;h3 id=&quot;对比改变&quot;&gt;&lt;a href=&quot;#对比改变&quot; class=&quot;headerlink&quot; title=&quot;对比改变&quot;&gt;&lt;/a&gt;对比改变&lt;/h3&gt;&lt;p&gt;对比一下吧，下图是前版本的主机排行网：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/d9fyk.gif&quot; alt=&quot;hostingranking-old-mobile&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我也来碎碎念 - 主机排行网运营一个月小结</title>
    <link href="http://www.cmlanche.com/2019/03/29/%E6%88%91%E4%B9%9F%E6%9D%A5%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://www.cmlanche.com/2019/03/29/我也来碎碎念/</id>
    <published>2019-03-29T03:00:19.000Z</published>
    <updated>2019-03-30T10:09:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我也来碎碎念-主机排行网运营一个月小结"><a href="#我也来碎碎念-主机排行网运营一个月小结" class="headerlink" title="我也来碎碎念 - 主机排行网运营一个月小结"></a>我也来碎碎念 - 主机排行网运营一个月小结</h3><blockquote><p>学习<a href="https://toolinbox.net" target="_blank" rel="noopener">iPic作者Jason</a>每周一的碎碎念，我也来碎碎念了，只有我有新的想法灵感，我就会立马记录下来，不管内容有多少。</p></blockquote><p>今天要总结一下我的产品：主机排行网 <a href="https://hostingranking.cn" target="_blank" rel="noopener">HostingRanking.cn</a></p><a id="more"></a><h3 id="盈利模式"><a href="#盈利模式" class="headerlink" title="盈利模式"></a>盈利模式</h3><p>主机排行网的盈利模式很简单，就是<strong>推广返利</strong>，做affiliate链接推广，最终目标要把最好的主机带给大家，做好全面评测，不断优化迭代版本。带给大家价值了，我这个产品才有意义。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>目前不断更新迭代有17个版本，115个提交记录，7个分支了，主机排行网也在<a href="https://www.vultr.com/?ref=7779694-4F" target="_blank" rel="noopener">Vultr</a> 日本VPS上稳定运行一个月了。</li></ol><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/pyuba.png" alt="image-20190329111148149"></p><ol start="2"><li><p>谁说<a href="https://www.vultr.com/?ref=7779694-4F" target="_blank" rel="noopener">Vultr VPS</a>的IP总是被封，为啥我就从来没有，你被封肯定是用来搭梯子了吧。</p></li><li><p>到目前为止预计可营收大概有1100元</p><ol><li><a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=mm1tv2if" target="_blank" rel="noopener">阿里云</a>云大使：611元</li></ol><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/rwl7k.png" alt="image-20190329111728872"></p><ol start="2"><li><a href="https://www.vultr.com/?ref=7779694-4F" target="_blank" rel="noopener">Vultr VPS</a>有两个推广，50美金</li></ol><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/mfkt4.png" alt="image-20190329111809713"></p><ol start="3"><li><a href="https://m.do.co/c/3b2f0f749606" target="_blank" rel="noopener">DigitalOcean</a>有1个有效推广，25美金</li></ol></li></ol><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/5ne7c.png" alt="image-20190329111829521"></p><h3 id="关于推广"><a href="#关于推广" class="headerlink" title="关于推广"></a>关于推广</h3><p>目前网站的流量都是自己推一下才有人看，不推就没有，这不是<strong>良性</strong>的，也比较消耗自己的时间，最好是流量来自自然搜索，这样就比较省事了，关键是流量最大的百度SEO很不好做，百度SEO一向不是很公平，所以我想先做好谷歌和必应的搜索。百度慢慢做好了。</p><h3 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h3><p>通常国内独立开发不会写自己产品的盈利模式和收入来源，我这里完全开放出来，不排斥有同行跟我做一样的网站，也欢迎你做，如果你做了，到时候告诉我，我们互加友链，中国市场这么大，不怕再多你一人。😊</p><h3 id="独立开发者微信群"><a href="#独立开发者微信群" class="headerlink" title="独立开发者微信群"></a>独立开发者微信群</h3><p>目前我运营维护一个独立开发者群，里面有月入几万的大神，也有去学习的菜鸟，欢迎加入。加我微信cmlanche，我拉你进去。目前已有327人，快满了，手慢无啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;我也来碎碎念-主机排行网运营一个月小结&quot;&gt;&lt;a href=&quot;#我也来碎碎念-主机排行网运营一个月小结&quot; class=&quot;headerlink&quot; title=&quot;我也来碎碎念 - 主机排行网运营一个月小结&quot;&gt;&lt;/a&gt;我也来碎碎念 - 主机排行网运营一个月小结&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;学习&lt;a href=&quot;https://toolinbox.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iPic作者Jason&lt;/a&gt;每周一的碎碎念，我也来碎碎念了，只有我有新的想法灵感，我就会立马记录下来，不管内容有多少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要总结一下我的产品：主机排行网 &lt;a href=&quot;https://hostingranking.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HostingRanking.cn&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="碎碎念" scheme="http://www.cmlanche.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
      <category term="主机排行网" scheme="http://www.cmlanche.com/tags/%E4%B8%BB%E6%9C%BA%E6%8E%92%E8%A1%8C%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>我的最佳写作方式</title>
    <link href="http://www.cmlanche.com/2019/02/26/%E6%88%91%E7%9A%84%E6%9C%80%E4%BD%B3%E5%86%99%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.cmlanche.com/2019/02/26/我的最佳写作方式/</id>
    <published>2019-02-26T02:37:13.000Z</published>
    <updated>2019-03-01T00:02:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近喜欢上了写作，喜欢自己写的东西能被别人阅读，赞赏，也希望我写的东西能更有价值，体验也更好。</p><p>今天我分享的是我的最佳写作方式。</p><h1 id="我的最佳写作方式"><a href="#我的最佳写作方式" class="headerlink" title="我的最佳写作方式"></a>我的最佳写作方式</h1><p>工具汇总</p><table><thead><tr><th>markdown编辑器</th><th>截图工具</th><th>gif录制工具</th><th>图床工具</th></tr></thead><tbody><tr><td>Typora</td><td>QQ / wechat</td><td>licecap</td><td>iPic</td></tr></tbody></table><h3 id="markdown编辑器-·-Typora"><a href="#markdown编辑器-·-Typora" class="headerlink" title="markdown编辑器 · Typora"></a>markdown编辑器 · Typora</h3><p>完全免费的markdown编辑器，无与伦比的写作体验，让人爱不释手，具体的特性请移步官网：<a href="https://typora.io/" target="_blank" rel="noopener">https://typora.io/</a></p><p>我最常用的快捷键是<kbd>Command</kbd>+<kbd>/</kbd>，可以切换源码模式和打字机模式。</p><a id="more"></a><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/7a652.gif" alt="typora"></p><h3 id="图传工具-·-iPic"><a href="#图传工具-·-iPic" class="headerlink" title="图传工具 · iPic"></a>图传工具 · iPic</h3><p>仅仅有好的编辑器还不够，还需要图床工具将你的图片自动上传到云端，最好是能够结合你使用的markdown编辑器一起使用，最好是截图后直接粘贴，然后上传。</p><p>那么iPic是首选，因为Typora内置了iPic的功能，如下图：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/nmryc.gif" alt="ipic"></p><p>iPic支持很多种图传工具，我现在用的是腾讯COS，这个工具默认是免费的，但是默认只支持免费的新浪微博图传，如果你要使用其他图传就要收费了，年费50元。</p><p>iPic的作者是全职独立开发者Jason，已经写了很多类似的mac工具，都很优秀，官网：<a href="https://toolinbox.net/" target="_blank" rel="noopener">https://toolinbox.net/</a></p><h3 id="截图工具-·-QQ"><a href="#截图工具-·-QQ" class="headerlink" title="截图工具 · QQ"></a>截图工具 · QQ</h3><p>QQ和微信截图应该是大家都在用的，非常方便，截图后可以粘贴到任何地方，QQ还支持视频录制功能。</p><h3 id="gif录制工具-·-licecap"><a href="#gif录制工具-·-licecap" class="headerlink" title="gif录制工具 · licecap"></a>gif录制工具 · licecap</h3><p>这里我就要介绍强大的LICEcap了，用来做屏幕截图的，录制出来的gif很小，我的所有gif都是通过它来制作的。</p><p>详细请移步官网：<a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener">https://www.cockos.com/licecap/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近喜欢上了写作，喜欢自己写的东西能被别人阅读，赞赏，也希望我写的东西能更有价值，体验也更好。&lt;/p&gt;
&lt;p&gt;今天我分享的是我的最佳写作方式。&lt;/p&gt;
&lt;h1 id=&quot;我的最佳写作方式&quot;&gt;&lt;a href=&quot;#我的最佳写作方式&quot; class=&quot;headerlink&quot; title=&quot;我的最佳写作方式&quot;&gt;&lt;/a&gt;我的最佳写作方式&lt;/h1&gt;&lt;p&gt;工具汇总&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;markdown编辑器&lt;/th&gt;
&lt;th&gt;截图工具&lt;/th&gt;
&lt;th&gt;gif录制工具&lt;/th&gt;
&lt;th&gt;图床工具&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Typora&lt;/td&gt;
&lt;td&gt;QQ / wechat&lt;/td&gt;
&lt;td&gt;licecap&lt;/td&gt;
&lt;td&gt;iPic&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;markdown编辑器-·-Typora&quot;&gt;&lt;a href=&quot;#markdown编辑器-·-Typora&quot; class=&quot;headerlink&quot; title=&quot;markdown编辑器 · Typora&quot;&gt;&lt;/a&gt;markdown编辑器 · Typora&lt;/h3&gt;&lt;p&gt;完全免费的markdown编辑器，无与伦比的写作体验，让人爱不释手，具体的特性请移步官网：&lt;a href=&quot;https://typora.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://typora.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我最常用的快捷键是&lt;kbd&gt;Command&lt;/kbd&gt;+&lt;kbd&gt;/&lt;/kbd&gt;，可以切换源码模式和打字机模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="写作方式" scheme="http://www.cmlanche.com/tags/%E5%86%99%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSDN、博客园等6大技术博客平台的写作体验测评</title>
    <link href="http://www.cmlanche.com/2019/02/25/CSDN%E3%80%81%E5%8D%9A%E5%AE%A2%E5%9B%AD%E7%AD%896%E5%A4%A7%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%86%99%E4%BD%9C%E4%BD%93%E9%AA%8C%E6%B5%8B%E8%AF%84/"/>
    <id>http://www.cmlanche.com/2019/02/25/CSDN、博客园等6大技术博客平台的写作体验测评/</id>
    <published>2019-02-25T07:38:38.000Z</published>
    <updated>2019-03-12T12:12:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="功能对比"><a href="#功能对比" class="headerlink" title="功能对比"></a>功能对比</h1><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/kgs2s.png" alt="QQ20190312-201125@2x"></p><a id="more"></a><h1 id="markdown编辑器写作体验比较"><a href="#markdown编辑器写作体验比较" class="headerlink" title="markdown编辑器写作体验比较"></a>markdown编辑器写作体验比较</h1><blockquote><p>markdown标准语法请参考：<a href="https://commonmark.org/" target="_blank" rel="noopener">CommonMark</a>, 学习指南<a href="https://commonmark.org/help/tutorial/，而本文要比较的各家markdown编辑器遵守的协议都不太一样，比如csdn在标准语法上做了更多事情，如图片支持大小和居中设定，这一点虽好，但其他平台不支持，那也导致你的文章不具备通用性。所以我们并不需要独特的支持，都遵守标准语法，文章的移植性就更强。" target="_blank" rel="noopener">https://commonmark.org/help/tutorial/，而本文要比较的各家markdown编辑器遵守的协议都不太一样，比如csdn在标准语法上做了更多事情，如图片支持大小和居中设定，这一点虽好，但其他平台不支持，那也导致你的文章不具备通用性。所以我们并不需要独特的支持，都遵守标准语法，文章的移植性就更强。</a></p></blockquote><h3 id="1-segmentfault-com-体验5星，极好"><a href="#1-segmentfault-com-体验5星，极好" class="headerlink" title="1. segmentfault.com  体验5星，极好"></a>1. segmentfault.com  体验5星，极好</h3><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/fami8.png" alt="sf-markdown"></p><p>markdown语法说明：<a href="https://segmentfault.com/markdown" target="_blank" rel="noopener">https://segmentfault.com/markdown</a></p><p>segmentfault只支持markdonwn编辑器，是因为它是最新的平台，然后面向的用户都是程序员群体，而markdown已经是大家默认的使用的编辑器，这是共识，csdn前几年都不支持markdown，现在都支持了，会用markdown已经是程序员群体最基础的能力，所以它不需要支持富文本编辑器，有点多余。</p><p><strong>特点：</strong></p><ol><li><p>界面<strong>简洁</strong>，没有多余的东西</p></li><li><p><strong>聚焦当前写作行</strong>，实时预览</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/2i6hz.gif" alt="sf-hotline"></p></li><li><p>发布原创可<strong>注明版权</strong>，同时可以<strong>同步到新浪微博</strong>，支持<strong>定时发布</strong></p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/eojwa.gif" alt="sf-pub"></p></li></ol><ol start="4"><li><p>可以给文章设置预定的标签，创建一个系统不存在的标签要求你的声望值达到1500。这样其实很有好处，可以让segmentfault整个系统共用一套标签体系，可以把相同兴趣的人组织到一块，同时也避免了标签混乱。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/nhb9e.gif" alt="sf-tags"></p></li></ol><h3 id="2-CSDN-体验5星，极好"><a href="#2-CSDN-体验5星，极好" class="headerlink" title="2. CSDN 体验5星，极好"></a>2. CSDN 体验5星，极好</h3><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/294mx.png" alt="csdn-overview"></p><p>csdn的markdown编辑器很强大，支持很全面，图片也支持大小和居中设置。刚打开编辑器的时候，就告诉你所有csdn的增强版markdown语法知识。</p><p>markdown增强点有：</p><ol><li><p>新增文章目录语法：<code>@[TOC](文章目录)</code></p></li><li><p>图片支持大小和居中设定</p></li><li><strong>全新的界面设计</strong> ，将会带来全新的写作体验；<ol start="4"><li>在创作中心设置你喜爱的代码高亮样式，Markdown <strong>将代码片显示选择的高亮样式</strong> 进行展示；</li><li>增加了 <strong>图片拖拽</strong> 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；</li><li>全新的 <strong>KaTeX数学公式</strong> 语法；</li><li>增加了支持<strong>甘特图的mermaid语法[^1]</strong> 功能；</li><li>增加了 <strong>多屏幕编辑</strong> Markdown文章功能；</li><li>增加了 <strong>焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置</strong> 等功能，功能按钮位于编辑区域与预览区域中间；</li><li>增加了 <strong>检查列表</strong> 功能。</li></ol></li></ol><h3 id="3-开源中国-OSChina-net-体验3星，一般"><a href="#3-开源中国-OSChina-net-体验3星，一般" class="headerlink" title="3. 开源中国 OSChina.net  体验3星，一般"></a>3. 开源中国 OSChina.net  体验3星，一般</h3><p>开源中国的markdown编辑器体验很差，做的比较敷衍，我随便找个开源的都能做成这样。</p><p>而且markdown也不是默认编辑器，说明也不注重这一块。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/7mpls.gif" alt="oschina-overvie"></p><h3 id="4-博客园-cnblogs-com-体验1星，极差"><a href="#4-博客园-cnblogs-com-体验1星，极差" class="headerlink" title="4. 博客园 cnblogs.com 体验1星，极差"></a>4. 博客园 cnblogs.com 体验1星，极差</h3><p>博客园的markdown编辑器就太差了，没有任何写作体验，就是一个输入框，让你把提前写好的markdown文本贴进去了事，也没有预览功能，写了啥也不知道。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/4xe8k.gif" alt="cnblogs-overview"></p><p>可能有很多朋友还不知道怎么启用markdown编辑器呢，在后台页面【选项】-【默认编辑器】-【Markdown】</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/z3wqy.gif" alt="cnblogs-sddf"></p><h3 id="5-知乎-无markdown编辑器，富文本编辑器体验5星，极好"><a href="#5-知乎-无markdown编辑器，富文本编辑器体验5星，极好" class="headerlink" title="5. 知乎 无markdown编辑器，富文本编辑器体验5星，极好"></a>5. 知乎 无markdown编辑器，富文本编辑器体验5星，极好</h3><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/6ixt6.png" alt="image-20190225174431609"></p><p>知乎面向的客户是全社会各类的人，绝大多数并不是程序员群体，所有知乎是不会支持markdown编辑器的。</p><p>虽然这样，知乎还是提供给我们强大的定制的富文本编辑器，主要特性有：</p><ol><li>界面简洁</li><li>图片支持一次性上传多张</li><li>支持文章封面</li></ol><h3 id="6-简书-评价5星，很好"><a href="#6-简书-评价5星，很好" class="headerlink" title="6. 简书 评价5星，很好"></a>6. 简书 评价5星，很好</h3><p>简书面向的群体也不只是it技术人员，程序员群体仅仅是很小的一部分，但仍旧支持markdown编辑器，只是不是默认的编辑器而已，富文本的支持也很好，主要有如下特点：</p><ol><li><p>文集形式，不仅仅包含编辑器，一次性打开所有文章，方便你随时切换其他文章进行修改</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/rxvql.png" alt="image-20190225175222900"></p></li><li><p>和知乎一样，一次性可上传多张图片</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/tja3e.png" alt="image-20190225175542580"></p></li><li><p>支持数学公式，并有友好的提示。</p><ol><li>常用表达式</li><li>常用函数</li><li>希腊字母</li><li>常用符号</li><li>特殊符号</li></ol><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/z4trn.gif" alt="jianshu"></p><p>简书切换markdown的方式比较隐蔽，在左下角的设置切换：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/c9v2f.png" alt="image-20190226115056789"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;功能对比&quot;&gt;&lt;a href=&quot;#功能对比&quot; class=&quot;headerlink&quot; title=&quot;功能对比&quot;&gt;&lt;/a&gt;功能对比&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/kgs2s.png&quot; alt=&quot;QQ20190312-201125@2x&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="评测" scheme="http://www.cmlanche.com/tags/%E8%AF%84%E6%B5%8B/"/>
    
      <category term="csdn" scheme="http://www.cmlanche.com/tags/csdn/"/>
    
      <category term="博客园" scheme="http://www.cmlanche.com/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>面试题·HashMap和Hashtable的区别(转载再整理)</title>
    <link href="http://www.cmlanche.com/2019/02/25/HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB(%E8%BD%AC)/"/>
    <id>http://www.cmlanche.com/2019/02/25/HashMap和Hashtable的区别(转)/</id>
    <published>2019-02-25T03:26:49.000Z</published>
    <updated>2019-02-26T06:41:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接： <a href="http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html" target="_blank" rel="noopener">Javarevisited</a> 翻译： <a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew.com </a>- <a href="http://www.importnew.com/author/tangxiaojuan" target="_blank" rel="noopener">唐小娟</a><br>译文链接： <a href="http://www.importnew.com/7010.html" target="_blank" rel="noopener">http://www.importnew.com/7010.html</a></p></blockquote><p>HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分。Hashtable和HashMap在Java面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何Java面试之前，都不要忘了准备这一题。</p><p>这篇文章中，我们不仅将会看到HashMap和Hashtable的区别，还将看到它们之间的相似之处。</p><a id="more"></a><h3 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h3><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p><ol><li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li><li>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li><li>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li><li>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li><li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li></ol><h3 id="要注意的一些重要术语："><a href="#要注意的一些重要术语：" class="headerlink" title="要注意的一些重要术语："></a>要注意的一些重要术语：</h3><ol><li><p>sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。</p></li><li><p>Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</p></li><li><p>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p></li></ol><h3 id="我们能否让HashMap同步？"><a href="#我们能否让HashMap同步？" class="headerlink" title="我们能否让HashMap同步？"></a>我们能否让HashMap同步？</h3><p>HashMap可以通过下面的语句进行同步：<br>Map m = Collections.synchronizeMap(hashMap);</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，Hashtable是java 4时代的过时产物，ConcurrentHashMap是它的替代品。而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文链接： &lt;a href=&quot;http://javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Javarevisited&lt;/a&gt; 翻译： &lt;a href=&quot;http://www.importnew.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ImportNew.com &lt;/a&gt;- &lt;a href=&quot;http://www.importnew.com/author/tangxiaojuan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;唐小娟&lt;/a&gt;&lt;br&gt;译文链接： &lt;a href=&quot;http://www.importnew.com/7010.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.importnew.com/7010.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分。Hashtable和HashMap在Java面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何Java面试之前，都不要忘了准备这一题。&lt;/p&gt;
&lt;p&gt;这篇文章中，我们不仅将会看到HashMap和Hashtable的区别，还将看到它们之间的相似之处。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hashmap" scheme="http://www.cmlanche.com/tags/hashmap/"/>
    
      <category term="hashtable" scheme="http://www.cmlanche.com/tags/hashtable/"/>
    
      <category term="面试题" scheme="http://www.cmlanche.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>hostingranking.cn·基于ghost的轻量技术架构整理</title>
    <link href="http://www.cmlanche.com/2019/02/24/hostingranking.cn%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.cmlanche.com/2019/02/24/hostingranking.cn技术架构/</id>
    <published>2019-02-24T05:40:05.000Z</published>
    <updated>2019-03-13T03:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇纯粹只讲<a href="https://hostingranking.cn" target="_blank" rel="noopener">hostingranking.cn</a>网站的技术架构，也就是怎么做到的，达到什么效果。至于它是什么，为什么要做暂且不说，另篇会分享。</p></blockquote><h3 id="技术组成"><a href="#技术组成" class="headerlink" title="技术组成"></a>技术组成</h3><p>首先hostingranking.cn是基于ghost博客平台而构建的，ghost最强大的部分就是可以最大限度的让你DIY网站，能力特别强。如下是技术组成图：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/o6rge.png" alt="image-20190224143748243"></p><h3 id="技术讲解"><a href="#技术讲解" class="headerlink" title="技术讲解"></a>技术讲解</h3><table><thead><tr><th></th><th>运行环境</th><th>用途</th></tr></thead><tbody><tr><td>Ghost</td><td>Nodejs</td><td>博客平台，可供主题创作的环境，博客管理，SEO等一系列可插拔的功能</td></tr><tr><td>JQuery</td><td>Javascript</td><td>前端js交互</td></tr><tr><td>handlebar</td><td>-</td><td>网页模板</td></tr><tr><td>spring boot</td><td>java</td><td>提供后端服务，连接第三方服务</td></tr><tr><td>typeform</td><td></td><td>第三方问卷调查服务</td></tr><tr><td>mailchimp</td><td></td><td>第三方邮件服务</td></tr></tbody></table><a id="more"></a><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol><li>ghost主题制作，呈现网站基本内容</li><li>个性化主机推荐</li><li>博客</li></ol><h4 id="ghost主题制作"><a href="#ghost主题制作" class="headerlink" title="ghost主题制作"></a>ghost主题制作</h4><p>ghost主题制作非常简单，只要你会写js+html+css即可制作，另外最好要学会handlebar模板语言，会让你制作主题事半功倍，入门制作教程参考我另一篇文章：<a href="https://cmlanche.com/2018/08/26/%E5%88%B6%E4%BD%9Cghost%E4%B8%BB%E9%A2%98/" target="_blank" rel="noopener">https://cmlanche.com/2018/08/26/%E5%88%B6%E4%BD%9Cghost%E4%B8%BB%E9%A2%98/</a></p><h4 id="个性化主机推荐"><a href="#个性化主机推荐" class="headerlink" title="个性化主机推荐"></a>个性化主机推荐</h4><p>#####基本流程如下</p><ol><li>采用typeform来制作表单</li><li>开启typeform的webhook，意思就是当客户提交表单的时候，会往这个webhook url发送一个post请求，来告诉你有用户提交了，以及提交的数据。</li><li>spring boot是我们的后端服务，专门用来制作webhook接口的，不要把webhook想的很神圣，没什么难的，webhook接口其实就是一个普通接口，只是它被用来处理webhook发送来的数据罢了。</li><li>spring boot收到typeform提交的问卷信息后，去调用mailchimp的api，创建邮件，发送给客户。</li></ol><h5 id="活动图如下"><a href="#活动图如下" class="headerlink" title="活动图如下"></a>活动图如下</h5><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/7yo6p.png" alt="image-20190224145254076"></p><p>我最终通过spring Boot接收webhook传递过来的不同数据，生成不同的推荐结果。</p><p>你可以在<a href="https://hostingranking.cn" target="_blank" rel="noopener">hostingranking.cn</a>的实现效果，看自己是否能收到邮件，收到的是什么。</p><h3 id="typeform"><a href="#typeform" class="headerlink" title="typeform"></a>typeform</h3><p>强大的问卷调查产品，体验无与伦比，生成的文件简单简洁，完整的api支撑，对刚起步的新手产品免费支持，更重要的是，支持中文！在国内访问畅通无阻！下图是我hostingranking.cn产品涉及到的问卷设计：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/g3dpx.png" alt="QQ20190224-145959@2x"></p><h3 id="mailchimp"><a href="#mailchimp" class="headerlink" title="mailchimp"></a>mailchimp</h3><p>世界上最常用的邮箱市场营销工具，好处如下：</p><ol><li>完全的开放，完整的api支持，支持用zapper连接上百款常用产品</li><li>中国访问速度还可以，用api调用无碍</li><li>诚意满满的新手产品扶助计划，帮助新产品达到足够规模再收费！</li></ol><p>按照上面说的个性化功能，当你提交问卷之后，我的mailchimp后台会看到发送状态，以及打开和点击的状态，如下图：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/cdi8l.png" alt="QQ20190224-150720@2x"></p><blockquote><p>一点吐槽：看到typeform和mailchimp，我想国外的东西做的真是开放，各种api都支持，反观国内，则各种保护，就比如知乎、博客园、segmentfault等都是不开放api的，这点让我觉得国内还不够开放。</p></blockquote><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>博客功能是ghost内置的核心功能，刚刚开发好(2019-03-13)，访问：<a href="https://hostingranking.cn/blog" target="_blank" rel="noopener">https://hostingranking.cn/blog</a></p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p>hostingranking.cn网站托管在<a href="http://bit.ly/tryvultr" target="_blank" rel="noopener">Vultr</a>主机上，买的最低配的VPS，每个月5美金</p><p>如果你要买它的主机并且你的主要客户在大陆的话，你一定要买日本的主机，不要买美国和新加坡的，因为日本的平均ping值是最低的，大约一百多，新加坡的主机会绕过日本再到中国，慢一些，而美国的大概两三百。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇纯粹只讲&lt;a href=&quot;https://hostingranking.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;hostingranking.cn&lt;/a&gt;网站的技术架构，也就是怎么做到的，达到什么效果。至于它是什么，为什么要做暂且不说，另篇会分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;技术组成&quot;&gt;&lt;a href=&quot;#技术组成&quot; class=&quot;headerlink&quot; title=&quot;技术组成&quot;&gt;&lt;/a&gt;技术组成&lt;/h3&gt;&lt;p&gt;首先hostingranking.cn是基于ghost博客平台而构建的，ghost最强大的部分就是可以最大限度的让你DIY网站，能力特别强。如下是技术组成图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/o6rge.png&quot; alt=&quot;image-20190224143748243&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;技术讲解&quot;&gt;&lt;a href=&quot;#技术讲解&quot; class=&quot;headerlink&quot; title=&quot;技术讲解&quot;&gt;&lt;/a&gt;技术讲解&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;运行环境&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ghost&lt;/td&gt;
&lt;td&gt;Nodejs&lt;/td&gt;
&lt;td&gt;博客平台，可供主题创作的环境，博客管理，SEO等一系列可插拔的功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JQuery&lt;/td&gt;
&lt;td&gt;Javascript&lt;/td&gt;
&lt;td&gt;前端js交互&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;handlebar&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;网页模板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spring boot&lt;/td&gt;
&lt;td&gt;java&lt;/td&gt;
&lt;td&gt;提供后端服务，连接第三方服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;typeform&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;第三方问卷调查服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mailchimp&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;第三方邮件服务&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="hostingranking.cn" scheme="http://www.cmlanche.com/tags/hostingranking-cn/"/>
    
      <category term="技术架构" scheme="http://www.cmlanche.com/tags/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>程序员的微创业</title>
    <link href="http://www.cmlanche.com/2019/02/24/%E5%BE%AE%E5%88%9B%E4%B8%9A/"/>
    <id>http://www.cmlanche.com/2019/02/24/微创业/</id>
    <published>2019-02-24T01:00:10.000Z</published>
    <updated>2019-03-13T03:08:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/zgc28.jpg" alt="v2-6cea99c48c9aa053b6bd6bbcd70f3631_hd"></p><p>不知道有没有觉得程序员是吃青春饭的；</p><p>有没有发现很多公司的招聘需求上写着35岁以上不要；</p><p>有没有发现一转眼都已奔三，却依旧一事无成，无房无车；</p><h3 id="怎么办？"><a href="#怎么办？" class="headerlink" title="怎么办？"></a>怎么办？</h3><p>我想过创业，我也创业过，15年的时候和同学一块做人脸识别，种种原因最后没成功，此前两年的积蓄也清零，创业？人家都说是九死一生，我说就是，在你没有足够人脉钱脉的时候你去创业，无异于以卵击石。</p><p>程序员是吃请青春饭的，因为这个行业加班最严重，年轻人不断涌上，没时间谈恋爱，谈了恋爱的不敢结婚，结婚的不敢生孩子，生孩子了也不能自己养，要爸妈带，中国现在社会就是这样，年轻人压力巨大，上有老下有小，奔三的我感觉鸭梨山大。</p><p>既然不能创业那就好好工作，把工作的事情做好，我也觉得，但是2018年底都知道大裁员，公司也未必是可靠的，如果你没有足够好的技能和其他的收入傍身，最后哭的怎么不会是你？</p><a id="more"></a><h3 id="地心引力"><a href="#地心引力" class="headerlink" title="地心引力"></a>地心引力</h3><p>这个社会是一张网紧紧的黏住你，让你无法动弹，无法很好的去世界各地自己想去的地方，无法任性而为还本真的自我，要想摆脱这种地心引力，你要实现的目标就是要实现财务自由，这样你将不再受到工作、家庭的制约。</p><h3 id="财务自由"><a href="#财务自由" class="headerlink" title="财务自由"></a>财务自由</h3><p>近十几年，不同的人，实现财务自由的方式不尽然相同。</p><p>有些人天生就财务自由，爸妈给的，就像王思聪，可能你姓王，但是你爸不是王健林；</p><p>有些人搭上了不错的“班车”，比如滴滴，美团，小米，公司给予了丰厚股票奖励，也实现了财务自由，很可惜我并没有搭上。</p><p>有些人运气比较好，赶上14年股市普涨，又能及时悬崖勒马，狠狠赚了一匹，但我觉得这只是让你一下子突然获得了一箩筐的“鱼”，你没有鱼竿，等你的鱼都吃完的时候，你还是没法学会更好的生存。</p><p>同样的还有炒比特币的，赌场要是赚了，不要高兴太早，及早收心。</p><p>而绝大多数人，是没有这个福气和运气的，很多都同我一样，默默无闻。</p><p>我想实现财务自由，那怎么办呢？</p><h3 id="让我们微创业吧"><a href="#让我们微创业吧" class="headerlink" title="让我们微创业吧"></a>让我们微创业吧</h3><p>先让我们牢记第一条使命，就是把工作上老板交代的活干好</p><p>然后是<strong>有余力</strong>，就<strong>微创业</strong>吧</p><p>微创业，目标是在不影响工作的情况下，额外的创收。</p><h3 id="都有哪些做法？"><a href="#都有哪些做法？" class="headerlink" title="都有哪些做法？"></a>都有哪些做法？</h3><p>第一就是接外包，这种方式来钱明显，但是很多外包都是想要最少的钱，让别人干最多的活，十分的累，还不如工作赚的多，而且十分影响你现在的工作，我极力反对用这个方式创收。</p><p>第二就是要在工作之外把自己变成独立的开发者，依靠我们自身的技术优势，来做点小而美的产品，例如iPic的作者Jason（产品经理出生，为了做独立开发者，自学ios相关的技术，<a href="https://toolinbox.net/" target="_blank" rel="noopener">https://toolinbox.net/</a>），还有码力全开工作室<a href="http://maliquankai.com/" target="_blank" rel="noopener">http://maliquankai.com/</a>的Larry，虽然我们中绝大多数人没办法像他们一样做全职的独立开发者，但是我们在工作中好好打磨一款产品，等它的收入达到一定时，你就可以全职来彻底搞它了。</p><h3 id="关键：坚持"><a href="#关键：坚持" class="headerlink" title="关键：坚持"></a>关键：坚持</h3><p>选好点子，然后就是要长期坚持，如果你放弃了，这一切都完了！</p><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><ol><li>我一直在努力的网站：主机排行网 <a href="https://hostingranking.cn/" target="_blank" rel="noopener">https://hostingranking.cn/</a></li><li>后续我会慢慢分享独立开发者心得和干货</li><li>加我好友，拉你进独立开发者群</li></ol><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/kz0mn.png" alt="image-20190227154108985"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/zgc28.jpg&quot; alt=&quot;v2-6cea99c48c9aa053b6bd6bbcd70f3631_hd&quot;&gt;&lt;/p&gt;
&lt;p&gt;不知道有没有觉得程序员是吃青春饭的；&lt;/p&gt;
&lt;p&gt;有没有发现很多公司的招聘需求上写着35岁以上不要；&lt;/p&gt;
&lt;p&gt;有没有发现一转眼都已奔三，却依旧一事无成，无房无车；&lt;/p&gt;
&lt;h3 id=&quot;怎么办？&quot;&gt;&lt;a href=&quot;#怎么办？&quot; class=&quot;headerlink&quot; title=&quot;怎么办？&quot;&gt;&lt;/a&gt;怎么办？&lt;/h3&gt;&lt;p&gt;我想过创业，我也创业过，15年的时候和同学一块做人脸识别，种种原因最后没成功，此前两年的积蓄也清零，创业？人家都说是九死一生，我说就是，在你没有足够人脉钱脉的时候你去创业，无异于以卵击石。&lt;/p&gt;
&lt;p&gt;程序员是吃请青春饭的，因为这个行业加班最严重，年轻人不断涌上，没时间谈恋爱，谈了恋爱的不敢结婚，结婚的不敢生孩子，生孩子了也不能自己养，要爸妈带，中国现在社会就是这样，年轻人压力巨大，上有老下有小，奔三的我感觉鸭梨山大。&lt;/p&gt;
&lt;p&gt;既然不能创业那就好好工作，把工作的事情做好，我也觉得，但是2018年底都知道大裁员，公司也未必是可靠的，如果你没有足够好的技能和其他的收入傍身，最后哭的怎么不会是你？&lt;/p&gt;
    
    </summary>
    
    
      <category term="程序员" scheme="http://www.cmlanche.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="微创业" scheme="http://www.cmlanche.com/tags/%E5%BE%AE%E5%88%9B%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>安装指定版本的node的方法</title>
    <link href="http://www.cmlanche.com/2019/01/23/%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E7%9A%84node/"/>
    <id>http://www.cmlanche.com/2019/01/23/安装指定版本的node/</id>
    <published>2019-01-23T13:19:19.000Z</published>
    <updated>2019-02-24T00:51:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装指定版本的node的方法"><a href="#安装指定版本的node的方法" class="headerlink" title="安装指定版本的node的方法"></a>安装指定版本的node的方法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm cache clean -f  # 清除缓存</span><br><span class="line">sudo npm install -g n # 安装node版本工具n</span><br><span class="line">sudo n 10.13.0 # 10.13.0 是版本号</span><br><span class="line"><span class="meta">#</span> sudo n stable # 安装当前最新的最稳定版本的node</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装指定版本的node的方法&quot;&gt;&lt;a href=&quot;#安装指定版本的node的方法&quot; class=&quot;headerlink&quot; title=&quot;安装指定版本的node的方法&quot;&gt;&lt;/a&gt;安装指定版本的node的方法&lt;/h3&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="nodejs" scheme="http://www.cmlanche.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>开闭原则</title>
    <link href="http://www.cmlanche.com/2018/12/10/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    <id>http://www.cmlanche.com/2018/12/10/开闭原则/</id>
    <published>2018-12-10T03:00:57.000Z</published>
    <updated>2019-02-26T06:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="再谈开闭原则"><a href="#再谈开闭原则" class="headerlink" title="再谈开闭原则"></a>再谈开闭原则</h1><p>最开始了解设计模式之开闭原则是在6年前，那个时候我还是在校大学生，我是读《设计模式之禅》了解到它的。开闭原则是说，对扩展开发，对修改关闭，当时我看书的时候还不太了解它的含义，只知道这是设计模式最重要的原则，其他5大原则（如最小接口原则、迪米特原则、里式替换原则等）都是为了更好的实现开闭原则而总结出来的一套方法论，而书中说的23大设计模式都是基于这些模式的实践。</p><p>今天我又一次感受到了开闭原则的牛逼，我感受到，它不仅仅可以用在实际的代码编写上，对整个系统的架构都有指导借鉴意义。</p><a id="more"></a><p>我目前负责的是我司自动化测试的执行流程，今天有个需求是要给各个手机agent server添加一个doctor的诊断命令。目前的架构是这样的，有3个手机agent server，分别是Robotium、UIAutomator和iOS的XCUTest，执行端这边负责建立socket短连接与这3个agent server进行通信，目前在我写的一个AgentManger来协调管理他们，这部分已经完美运行一年半了，改动很小，需求是现在要添加一个新命令doctor，然而我发现这三个agent server都通过socket连接，但他们的通信内容的协议居然完全不一样，Robotium agent server这边是以“OKEY%s”来格式化返回值，单不看整个的通信架构是否合理，就这个返回的字符串我就很想吐槽，哪有这样的？！通常都是用统一格式的JSON来表达返回结果的，不管是几个agent server，都可以用一套处理模式来处理，甚至分出一个独立的工程模块来做这件事情，而UIAutomator Agent server它的返回值的结构则是{‘success’: true, ‘msg’: ‘xxxxx’}的一个json结构，这个表示也很糟糕，虽然是json的，但是只有true和false两种状态，如果你说你把它改一下不就行了吗，但是你要知道，以往的工程已经积累了几十个接口了，如果去改它以前的通信结构，那么会改动特别大，整个程序要进行回归测试才可以重新上线，所以从一开始就设计出统一的通信协议是多么重要，而如果是在统一的模块中处理的话，那就更容易了，只要在这个模块中更改协议就好了，做少量测试就可以知道你的改动是否覆盖所有的接口，这样可以大大减少后面的工作量！</p><p>再联系到我们的开闭原则，原则说，要对修改关闭，对扩展开放，上面的那个垃圾通信协议结构，你要对它进行修改是无比的困难，而添加新的接口，又会让这样的垃圾结构继续存在，当某一天你发现这样的通信结构无法满足要求时，你会发现你必须得修改，也就是要重构了。所以从一开始设计出一套能够更容易扩展，无需修改的结构是多么重要！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;再谈开闭原则&quot;&gt;&lt;a href=&quot;#再谈开闭原则&quot; class=&quot;headerlink&quot; title=&quot;再谈开闭原则&quot;&gt;&lt;/a&gt;再谈开闭原则&lt;/h1&gt;&lt;p&gt;最开始了解设计模式之开闭原则是在6年前，那个时候我还是在校大学生，我是读《设计模式之禅》了解到它的。开闭原则是说，对扩展开发，对修改关闭，当时我看书的时候还不太了解它的含义，只知道这是设计模式最重要的原则，其他5大原则（如最小接口原则、迪米特原则、里式替换原则等）都是为了更好的实现开闭原则而总结出来的一套方法论，而书中说的23大设计模式都是基于这些模式的实践。&lt;/p&gt;
&lt;p&gt;今天我又一次感受到了开闭原则的牛逼，我感受到，它不仅仅可以用在实际的代码编写上，对整个系统的架构都有指导借鉴意义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="开闭原则" scheme="http://www.cmlanche.com/tags/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    
      <category term="设计模式" scheme="http://www.cmlanche.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面基</title>
    <link href="http://www.cmlanche.com/2018/08/26/%E9%9D%A2%E5%9F%BA%E9%9D%92%E6%98%A5%E6%97%A0%E7%BD%AA/"/>
    <id>http://www.cmlanche.com/2018/08/26/面基青春无罪/</id>
    <published>2018-08-26T10:41:07.000Z</published>
    <updated>2019-02-24T00:56:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>“青春无罪”是我QQ群（518914410）的一个网友，是我第一个线下交流的网友，是北工大仪器测量专业方向的博士生，为人非常爽朗，乐于助人。今天跟他见面非常开心，跟他学习了很多，主要有两点要说的：</p><p>第一就是不要着急，做好当下需要做的事情，一步一个脚印，一个大的目标的达成不是一下子就能达成的，需要慢慢积累；</p><p>第二个就是对怎么做好一个产品刷新了我的认识，以前我太过于盲目，自己的需求并不是大众的需求，做好一个产品是要找准大众的一个需求才行，更不能没想清楚就开始写代码实现，一个产品的实际需求可能需要结合产品的实际情况来分析，马斯洛金字塔需求最底下是生理需求，比如吃喝拉撒睡，中间是安全需求，最顶层是自我价值的实现与超越，你的产品需要根据实际场景来具体分析，不能你想是什么就是什么。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“青春无罪”是我QQ群（518914410）的一个网友，是我第一个线下交流的网友，是北工大仪器测量专业方向的博士生，为人非常爽朗，乐于助人。今天跟他见面非常开心，跟他学习了很多，主要有两点要说的：&lt;/p&gt;
&lt;p&gt;第一就是不要着急，做好当下需要做的事情，一步一个脚印，一个大的
      
    
    </summary>
    
    
      <category term="面基" scheme="http://www.cmlanche.com/tags/%E9%9D%A2%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>制作ghost主题</title>
    <link href="http://www.cmlanche.com/2018/08/26/%E5%88%B6%E4%BD%9Cghost%E4%B8%BB%E9%A2%98/"/>
    <id>http://www.cmlanche.com/2018/08/26/制作ghost主题/</id>
    <published>2018-08-26T05:16:04.000Z</published>
    <updated>2019-02-26T06:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="以开发模式启动ghost"><a href="#以开发模式启动ghost" class="headerlink" title="以开发模式启动ghost"></a>以开发模式启动ghost</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd yourghostpath</span><br><span class="line">ghost start --development</span><br><span class="line"><span class="meta">#</span> 如果你已经启动了ghost，但不是开发模式，你可以用ghost stop来结束ghost</span><br></pre></td></tr></table></figure><h3 id="建立主题目录"><a href="#建立主题目录" class="headerlink" title="建立主题目录"></a>建立主题目录</h3><p>首先主题的开发环境是nodejs，所以要我们要先用nodejs构建一个项目，比如我们的项目是example:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd yourghostpath/content/themes</span><br><span class="line">mkdir example</span><br><span class="line">cd example</span><br><span class="line">npm init</span><br></pre></td></tr></table></figure><p>按照提示建立好基本的package.json，ghost主题最少的要求是有2个文件：index.hbs和post.hbs，这里hbs文件是<a href="https://themes.ghost.org/docs/handlebars" target="_blank" rel="noopener">handlerbars</a>文件，它是一个模板引擎，而ghost只支持用handlerbars，所以掌握handlerbars很重要，其实也不难，关键是要了解怎么传递值的。<br>目录和文件建立好了，主题就算完成了，虽然一句代码都没有，但他确实能够正常运转！</p><a id="more"></a><h3 id="激活主题"><a href="#激活主题" class="headerlink" title="激活主题"></a>激活主题</h3><p>打开你的网站后台<code>http://localhost:2368/ghost</code>，在<code>Design</code>-<code>Themes</code>中可以看到你的主题example，然后点击<code>active</code>激活，此时会弹出一个警告框，不管它，主题已经可以正常使用了，只是它是个空的，打开<code>http://localhost:2368</code>验证一下</p><p>###热加载</p><p>它的目的是可以实时加载刷新页面，你需要安装<a href="https://docs.ghost.org/docs/install-local#section-developing-themes" target="_blank" rel="noopener">nodemon</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 需要先停止ghost</span><br><span class="line">ghost stop</span><br><span class="line"><span class="meta">#</span> 安装nodemon</span><br><span class="line">npm install -g nodemon@latest</span><br><span class="line"><span class="meta">#</span> 切换到你的主题目录下</span><br><span class="line">cd yourthemedevpath</span><br><span class="line"><span class="meta">#</span> 热加载</span><br><span class="line">nodemon index.js --watch ./ --ext hbs,js,css</span><br></pre></td></tr></table></figure><p>这是制作主题的基本套路，完成这些后就需要编写主题的代码了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;以开发模式启动ghost&quot;&gt;&lt;a href=&quot;#以开发模式启动ghost&quot; class=&quot;headerlink&quot; title=&quot;以开发模式启动ghost&quot;&gt;&lt;/a&gt;以开发模式启动ghost&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd yourghostpath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ghost start --development&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; 如果你已经启动了ghost，但不是开发模式，你可以用ghost stop来结束ghost&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;建立主题目录&quot;&gt;&lt;a href=&quot;#建立主题目录&quot; class=&quot;headerlink&quot; title=&quot;建立主题目录&quot;&gt;&lt;/a&gt;建立主题目录&lt;/h3&gt;&lt;p&gt;首先主题的开发环境是nodejs，所以要我们要先用nodejs构建一个项目，比如我们的项目是example:&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd yourghostpath/content/themes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir example&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd example&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;按照提示建立好基本的package.json，ghost主题最少的要求是有2个文件：index.hbs和post.hbs，这里hbs文件是&lt;a href=&quot;https://themes.ghost.org/docs/handlebars&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;handlerbars&lt;/a&gt;文件，它是一个模板引擎，而ghost只支持用handlerbars，所以掌握handlerbars很重要，其实也不难，关键是要了解怎么传递值的。&lt;br&gt;目录和文件建立好了，主题就算完成了，虽然一句代码都没有，但他确实能够正常运转！&lt;/p&gt;
    
    </summary>
    
    
      <category term="ghost" scheme="http://www.cmlanche.com/tags/ghost/"/>
    
      <category term="ghost主题" scheme="http://www.cmlanche.com/tags/ghost%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
</feed>
