<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cmlanche</title>
  
  <subtitle>越努力越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.cmlanche.com/"/>
  <updated>2019-07-19T02:27:39.000Z</updated>
  <id>http://www.cmlanche.com/</id>
  
  <author>
    <name>cmlanche</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashTable相关整理</title>
    <link href="http://www.cmlanche.com/2019/07/19/HashTable%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/"/>
    <id>http://www.cmlanche.com/2019/07/19/HashTable相关整理/</id>
    <published>2019-07-19T01:58:48.000Z</published>
    <updated>2019-07-19T02:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashTable相关"><a href="#HashTable相关" class="headerlink" title="HashTable相关"></a>HashTable相关</h1><p> hashTable类图，此hashTable来自于jdk1.8<br> // 缺图再补<br> 继承抽象类Dictionary,实现序列化接口，实现map接口，实现copy接口.有好多方法都不用了额</p><a id="more"></a><h2 id="1-重要参数"><a href="#1-重要参数" class="headerlink" title="1.重要参数"></a>1.重要参数</h2><pre><code>1.Entry&lt;?,?&gt;[] table 存放数据的桶2.阈值 threshold 同hashMap3.负载因子 loadFactor 默认0.754.初始化默认长度 11 hashTable选择了一个质数，这里就很秀，这里因是因为除（近似）质数求余的分散效果好，具体请看这里https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/9413966/why-initialcapacity-of-hashtable-is-11-while-the-default-initial-capacity-in-has5.MAX_ARRAY_SIZE 最大值，也就是最大长度，Integer.MAX_VALUE - 8</code></pre><h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//默认构造器，可以看到长度是11，负载因子是0.75</span><br><span class="line"> public Hashtable() &#123;</span><br><span class="line">        this(11, 0.75f);</span><br><span class="line">    &#125;</span><br><span class="line">//这里有2个参数，1是长度，2是负载因子</span><br><span class="line">    public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    //如果长度小于0，直接出异常</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity);</span><br><span class="line">        //如果负载因子小于0，或者不合法直接丢出异常</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line">        //如果长度=0那么就给一个1长度</span><br><span class="line">        if (initialCapacity==0)</span><br><span class="line">            initialCapacity = 1;</span><br><span class="line">        //负载因子=0.75</span><br><span class="line">        this.loadFactor = loadFactor;</span><br><span class="line">        //初始化initialCapacity个长度的二维数组</span><br><span class="line">        table = new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">        //阈值 取一个最小值</span><br><span class="line">        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-内部类解析"><a href="#3-内部类解析" class="headerlink" title="3.内部类解析"></a>3.内部类解析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//hahs table内部类，实现了 map.entry</span><br><span class="line">private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        //hash值</span><br><span class="line">        final int hash;</span><br><span class="line">        // key</span><br><span class="line">        final K key;</span><br><span class="line">        // vlaue</span><br><span class="line">        V value;</span><br><span class="line">        //下一个节点</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key =  key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        protected Object clone() &#123;</span><br><span class="line">            return new Entry&lt;&gt;(hash, key, value,</span><br><span class="line">                                  (next==null ? null : (Entry&lt;K,V&gt;) next.clone()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Map.Entry Ops</span><br><span class="line"></span><br><span class="line">        public K getKey() &#123;</span><br><span class="line">            return key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public V getValue() &#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public V setValue(V value) &#123;</span><br><span class="line">            if (value == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">            V oldValue = this.value;</span><br><span class="line">            this.value = value;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //只有key和value一样的时候才会返回true</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line"></span><br><span class="line">            return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp;</span><br><span class="line">               (value==null ? e.getValue()==null : value.equals(e.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //hashCode hash 异或了value生成的值</span><br><span class="line">        public int hashCode() &#123;</span><br><span class="line">            return hash ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return key.toString()+&quot;=&quot;+value.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="4-put流程解析"><a href="#4-put流程解析" class="headerlink" title="4.put流程解析"></a>4.put流程解析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//划重点，以后再有人问为什么hashtable的key为什么不能是null，</span><br><span class="line">//可以看到，这个方法添加了synchronized 做为表示，</span><br><span class="line">//在多线程的情况下，只有一个线程才能抢到锁，所以这里是线程安全的</span><br><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">        // 这里直接过滤掉了 key为null的情况，key必须有值</span><br><span class="line">        if (value == null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //确保key不在table里</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        int hash = key.hashCode();</span><br><span class="line">        //计算数组下标，hash&amp;Integer.Max 然后取余 桶长度</span><br><span class="line">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        //根据索引查询桶的位置</span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        //如果出现hash冲突，那么久循环当前桶的下一个节点</span><br><span class="line">        for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">            //如果hash相同  key值也相同，那么久替换value，</span><br><span class="line">            if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old = entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                return old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加到enrty中</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//添加到桶中 4个参数，hash值， key值， value值，下标索引</span><br><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">        //计数器++ 这里的这个值是安全的，因为只有一个线程去访问</span><br><span class="line">        modCount++;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        //如果超过阈值，那么久扩容</span><br><span class="line">        if (count &gt;= threshold) &#123;</span><br><span class="line">            //扩容</span><br><span class="line">            rehash();</span><br><span class="line">            tab = table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            //这里的又做了一次hash &amp; Integer.max 取余 表的长度</span><br><span class="line">            index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建一个新的值，这里先扩容，然后在放的值</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">        tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        //计数 ++</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//扩容</span><br><span class="line"> protected void rehash() &#123;</span><br><span class="line">        //先获取旧的桶的长度</span><br><span class="line">        int oldCapacity = table.length;</span><br><span class="line">        Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">        //计算新的长度，一倍的长度+1</span><br><span class="line">        int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">        //如果新长度减最大长度大于0</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        //如果旧的长度等于最大长度</span><br><span class="line">            if (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            //直接返回</span><br><span class="line">                return;</span><br><span class="line">            //新长度=最大长度</span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line">        modCount++;</span><br><span class="line">        //计算阈值 新的值</span><br><span class="line">        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">        table = newMap;</span><br><span class="line">        //循环存放</span><br><span class="line">        for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">            //根据i获取桶，</span><br><span class="line">            for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; e = old;</span><br><span class="line">                old = old.next;</span><br><span class="line">                //计算新的索引下标</span><br><span class="line">                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">                e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] = e;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##5.get流程解析</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这里的get非常的简单奥，没有hashmap的那么复杂，</span><br><span class="line">  public synchronized V get(Object key) &#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        int hash = key.hashCode();</span><br><span class="line">        //计算下标索引，</span><br><span class="line">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">        //根据index来循环，如果有hash冲突的化</span><br><span class="line">        for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;</span><br><span class="line">            //hash相同，key也相同，就返回value</span><br><span class="line">            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                return (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //返回空</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>##6.问题总结<br>1.初始化是质数的问题<a href="https://www.zhihu.com/question/29587252" target="_blank" rel="noopener">https://www.zhihu.com/question/29587252</a><br>2.多线程安全的问题,hashtable的的put,get方法都是线程安全的，使用了synchronized来修饰，这样在多线程的情况下，只有一个线程去读去写，这里感觉get可以修改成无锁的方式<br>3.使用场景，设计到线程安全的问题（1.5之前使用的多一些）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashTable相关&quot;&gt;&lt;a href=&quot;#HashTable相关&quot; class=&quot;headerlink&quot; title=&quot;HashTable相关&quot;&gt;&lt;/a&gt;HashTable相关&lt;/h1&gt;&lt;p&gt; hashTable类图，此hashTable来自于jdk1.8&lt;br&gt; // 缺图再补&lt;br&gt; 继承抽象类Dictionary,实现序列化接口，实现map接口，实现copy接口.有好多方法都不用了额&lt;/p&gt;
    
    </summary>
    
      <category term="小胖出品" scheme="http://www.cmlanche.com/categories/%E5%B0%8F%E8%83%96%E5%87%BA%E5%93%81/"/>
    
    
      <category term="hashtable" scheme="http://www.cmlanche.com/tags/hashtable/"/>
    
  </entry>
  
  <entry>
    <title>HashMap相关整理</title>
    <link href="http://www.cmlanche.com/2019/07/19/HashMap%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/"/>
    <id>http://www.cmlanche.com/2019/07/19/HashMap相关整理/</id>
    <published>2019-07-19T01:57:47.000Z</published>
    <updated>2019-07-19T02:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap相关"><a href="#HashMap相关" class="headerlink" title="HashMap相关"></a>HashMap相关</h1><p>首先先查看类图，此hashMap为jdk1.8<br><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/2fxhd.png?x-oss-process=style/logomark" alt="image-20190719095818991"><br>Hahsmap继承了AbstractMap实现了Map接口</p><a id="more"></a><h2 id="1-重要参数"><a href="#1-重要参数" class="headerlink" title="1. 重要参数"></a>1. 重要参数</h2><pre><code>1.负载因子 DEFAULT_LOAD_FACTOR = 0.75  如果初始化的时候不指定负载因子的值得话默认值就是0.752.默认初始化长度 DEFAULT_INITIAL_CAPACITY = 1&lt;&lt;4 //16个长度 这里必须是2的次幂 为什么必须是2的次幂下文解释,所以默认的hashMap到了12个长度就会进行一次扩容（16*0.75）3.链表转红黑树的阈值 TREEIFY_THRESHOLD = 8,如果hash桶的链表长度大于等于8并且总长度大于等于64的话才会转红黑树4. 红黑树转链表的阈值 UNTREEIFY_THRESHOLD = 6 5. 链表转红黑树的第二个条件MIN_TREEIFY_CAPACITY = 64,如果这个链表的总长度小于64的话，那么还会进行扩容6. Node类，是hashMap里的内部类，实现了Map.Enrty的接口,主要有 getKey，getValue等方法。7. 真正的负载有因子 loadFactor 如果初始化的适合不给值，默认就是DEFAULT_LOAD_FACTOR8. 最大长度，MAXIMUM_CAPACITY  1 &lt;&lt; 30(1073741824) 其实这个是对传入的值做的控制，最大值还是Integer.Max</code></pre><h2 id="2-内部类Node解析"><a href="#2-内部类Node解析" class="headerlink" title="2.内部类Node解析"></a>2.内部类Node解析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Node 实现了Map.Entry&lt;K,V&gt;,其本质还是一个键值对的类，它重写了</span><br><span class="line">hashCode,equals方法</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; </span><br><span class="line">    //hash 值                  </span><br><span class="line">    final int hash;   </span><br><span class="line">    //key                                               </span><br><span class="line">    final K key;   </span><br><span class="line">    //value                                                  </span><br><span class="line">    V value;      </span><br><span class="line">    //下一个节点                                                   </span><br><span class="line">    Node&lt;K,V&gt; next;                                                  </span><br><span class="line">    //构造器                                                      </span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;                 </span><br><span class="line">        this.hash = hash;                                            </span><br><span class="line">        this.key = key;                                              </span><br><span class="line">        this.value = value;                                          </span><br><span class="line">        this.next = next;                                            </span><br><span class="line">    &#125;                                                                </span><br><span class="line">                                                                     </span><br><span class="line">    public final K getKey()        &#123; return key; &#125;                   </span><br><span class="line">    public final V getValue()      &#123; return value; &#125;                 </span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;     </span><br><span class="line">    //这里重写了hashCode值，坐了一次扰动                                                         </span><br><span class="line">    public final int hashCode() &#123;                                    </span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(value);      </span><br><span class="line">    &#125;                                                                </span><br><span class="line">                                                                     </span><br><span class="line">    public final V setValue(V newValue) &#123;                            </span><br><span class="line">        V oldValue = value;                                          </span><br><span class="line">        value = newValue;                                            </span><br><span class="line">        return oldValue;                                             </span><br><span class="line">    &#125;                                                                </span><br><span class="line">    //这里要判断2个Entry是否相等，key和value必须相等才会返回ture                                                 </span><br><span class="line">    public final boolean equals(Object o) &#123;                          </span><br><span class="line">        if (o == this)                                               </span><br><span class="line">            return true;                                             </span><br><span class="line">        if (o instanceof Map.Entry) &#123;                                </span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;                    </span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;                   </span><br><span class="line">                Objects.equals(value, e.getValue()))                 </span><br><span class="line">                return true;                                         </span><br><span class="line">        &#125;                                                            </span><br><span class="line">        return false;                                                </span><br><span class="line">    &#125;                                                                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-红黑树的实现"><a href="#3-红黑树的实现" class="headerlink" title="3.红黑树的实现"></a>3.红黑树的实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;   </span><br><span class="line">    // 父节点</span><br><span class="line">     TreeNode&lt;K,V&gt; parent;        </span><br><span class="line">     //左子树</span><br><span class="line">     TreeNode&lt;K,V&gt; left;  </span><br><span class="line">     //右子树                                             </span><br><span class="line">     TreeNode&lt;K,V&gt; right;    </span><br><span class="line">     //辅助节点                                          </span><br><span class="line">     TreeNode&lt;K,V&gt; prev;  </span><br><span class="line">     //是不是红节点</span><br><span class="line">     boolean red;                                                      </span><br><span class="line">     TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;                </span><br><span class="line">         super(hash, key, val, next);                                  </span><br><span class="line">     &#125;                                                                 </span><br><span class="line">                                                                       </span><br><span class="line">    //查询根节点                                                           </span><br><span class="line">     final TreeNode&lt;K,V&gt; root() &#123;                                      </span><br><span class="line">         for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;                           </span><br><span class="line">             if ((p = r.parent) == null)                               </span><br><span class="line">                 return r;                                             </span><br><span class="line">             r = p;                                                    </span><br><span class="line">         &#125;                                                             </span><br><span class="line">     &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>红黑树的5个特点:<br>    1.每个子节点到root节点上黑节点数相同<br>    2.每个结点要么是红的，要么是黑的。<br>    3.根节点是黑色的<br>    4.每个叶节点（就是空点）是黑色的<br>    5.如果一个节点是红色的，那么他的两个子节点都是黑的</p><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4.构造方法"></a>4.构造方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//默认的构造方法，负载因子=0.75</span><br><span class="line"> public HashMap() &#123;                        </span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//2个参数，initialCapacity 初始化长度，loadFactor 负载因子</span><br><span class="line"> public HashMap(int initialCapacity, float loadFactor) &#123;                     </span><br><span class="line">     //如果长度为0 跑出异常</span><br><span class="line">     if (initialCapacity &lt; 0)                                                </span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +   </span><br><span class="line">                                            initialCapacity);    </span><br><span class="line">      //如果传入的长度大于上变规定的最大长度 那初始化的最大长度就等于1&gt;&gt;30</span><br><span class="line">     if (initialCapacity &gt; MAXIMUM_CAPACITY)                                 </span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;    </span><br><span class="line">         //如果传入的负载因子小于0 或者不是个数字就跑出异常                             </span><br><span class="line">     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))                         </span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +        </span><br><span class="line">                                            loadFactor);                </span><br><span class="line">    //设置 加载因子                                        </span><br><span class="line">     this.loadFactor = loadFactor;          </span><br><span class="line">     //设置 扩容阈值,这里不是真正的扩容至,返回给定目标容量的两个大小的幂,这个后边会自己计算的                 </span><br><span class="line">     this.threshold = tableSizeFor(initialCapacity);                         </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//只是指定长度的初始化方法，由此可见负载因子还是默认的0.75</span><br><span class="line">public HashMap(int initialCapacity) &#123;          </span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//传入构造出来的HashMap包含传入Map的映射关系，加载因子是默认的值</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;    </span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;  </span><br><span class="line">    //将传入的子Map中的全部元素逐个添加到HashMap中         </span><br><span class="line">    putMapEntries(m, false);                         </span><br><span class="line">&#125;</span><br><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt;m, boolean evict) &#123;   </span><br><span class="line">        //</span><br><span class="line">     int s = m.size();                                                        </span><br><span class="line">     if (s &gt; 0) &#123;       </span><br><span class="line">        //如果table是null                                                      </span><br><span class="line">         if (table == null) &#123; </span><br><span class="line">            //这里计算预长度                       </span><br><span class="line">             float ft = ((float)s / loadFactor) + 1.0F;                       </span><br><span class="line">             int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                        </span><br><span class="line">                      (int)ft : MAXIMUM_CAPACITY);                     </span><br><span class="line">             if (t &gt; threshold)                                               </span><br><span class="line">                 threshold = tableSizeFor(t);                                 </span><br><span class="line">         &#125;    </span><br><span class="line">         //table不是null，s大于阈值                                                                </span><br><span class="line">         else if (s &gt; threshold)    </span><br><span class="line">            //扩容                                          </span><br><span class="line">             resize();   </span><br><span class="line">             //循环放入                                                     </span><br><span class="line">         for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;         </span><br><span class="line">             K key = e.getKey();                                              </span><br><span class="line">             V value = e.getValue();                                          </span><br><span class="line">             putVal(hash(key), key, value, false, evict);                     </span><br><span class="line">         &#125;                                                                    </span><br><span class="line">     &#125;                                                                        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>##5 hash值得生成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//这里做了2次扰动，异或一次，h&gt;&gt;16 位移一次，其主要目的让hash值分布均匀，减少冲突 ,</span><br><span class="line">//1. 取hashCode值： h = key.hashCode()  </span><br><span class="line">//2.高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span><br><span class="line">static final int hash(Object key) &#123;                                   </span><br><span class="line">    int h;                                                            </span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^(h &gt;&gt;&gt; 16);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-put流程"><a href="#6-put流程" class="headerlink" title="6.put流程"></a>6.put流程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//put 调用了 putVal，hash(key) ，如上hash的生成，先生成了hahs值，然后传入key,value,</span><br><span class="line"> public V put(K key, V value) &#123;                                        </span><br><span class="line">     return putVal(hash(key), key, value, false, true);                </span><br><span class="line"> &#125;         </span><br><span class="line"> //hash: 生成的hash值</span><br><span class="line"> //key, value 是传入的</span><br><span class="line"> //onlyIfAbsent: 如果ture，则不要更改现有值， 由此可见，这里会修改现有的值</span><br><span class="line">//evict 如果是fasle 那么就是创建模式</span><br><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;        </span><br><span class="line">                                                      </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;      </span><br><span class="line">    //如果table是空， 并且tab的长度为0,那就进行扩容                                        </span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)                                  </span><br><span class="line">        n = (tab = resize()).length;    </span><br><span class="line">    //这里判断有没有hash冲突，如果不存在，那么久直接创建一个新的节点，否者就是存在hash冲突，先判断                                                 </span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)                                           </span><br><span class="line">        tab[i] = newNode(hash, key, value, null);                                        </span><br><span class="line">    else &#123;                                                                               </span><br><span class="line">        Node&lt;K,V&gt; e; K k;        </span><br><span class="line">        //判断 table[i]的元素的key是否与 需插入的key一样，若相同则 直接用新value 覆盖 旧value                                                        </span><br><span class="line">        if (p.hash == hash &amp;&amp;                                                            </span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                      </span><br><span class="line">            e = p;</span><br><span class="line">            // 优先判断P 是不是红黑树                                                                 </span><br><span class="line">        else if (p instanceof TreeNode)   </span><br><span class="line">            //如果p是实现了红黑树，那么直接put数节点                                               </span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);   </span><br><span class="line">            //不是红黑树，那么循环链表           </span><br><span class="line">        else &#123;                                                                           </span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123; </span><br><span class="line">                    //p的下一个节点是不是null，如果是null,直接插入，判断长度是不是大于7                                     </span><br><span class="line">                if ((e = p.next) == null) &#123;    </span><br><span class="line">                        //这里的插入是在链表的尾部插入，解决了1.7头部插入多线程的情况下 形成环形循环的问题                                  </span><br><span class="line">                    p.next = newNode(hash, key, value, null);                            </span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1)                     </span><br><span class="line">                         //转红黑树，</span><br><span class="line">                        treeifyBin(tab, hash);                                           </span><br><span class="line">                    break;                                                               </span><br><span class="line">                &#125;                                                        </span><br><span class="line">                if (e.hash == hash &amp;&amp;                                                    </span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))              </span><br><span class="line">                    break;      </span><br><span class="line">                //更新p指向下一个节点，继续遍历                                                         </span><br><span class="line">                p = e;                                                                   </span><br><span class="line">            &#125;                                                                            </span><br><span class="line">        &#125;     </span><br><span class="line">        //如果e不是空，说明存在这个映射                                                                          </span><br><span class="line">        if (e != null) &#123; </span><br><span class="line">            //替换新的vlaue                                 </span><br><span class="line">            V oldValue = e.value;                                                        </span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)                                       </span><br><span class="line">                e.value = value;  </span><br><span class="line">            //替换旧值时会调用的方法（默认实现为空）                                                       </span><br><span class="line">            afterNodeAccess(e);                                                          </span><br><span class="line">            return oldValue;                                                             </span><br><span class="line">        &#125;                                                                                </span><br><span class="line">    &#125;           </span><br><span class="line">    //计算长度                                                                         </span><br><span class="line">    ++modCount;    </span><br><span class="line">    //判断是否需要扩容 这里的扩容有问题，应该提到头部，判断完初始化的扩容后，就判断是不是需要扩容，要不容易形成的扩完容以后这个map就没人使用                                                             </span><br><span class="line">    if (++size &gt; threshold)                                                              </span><br><span class="line">        resize();    </span><br><span class="line">    //这里的的默认也为空                                                                    </span><br><span class="line">    afterNodeInsertion(evict);                                                           </span><br><span class="line">    return null;                                                                         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> //存放树节点</span><br><span class="line"> //歪日，我不是特别明白红黑树的这个东西，先记录</span><br><span class="line">  final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,          </span><br><span class="line">                                 int h, K k, V v) &#123;                          </span><br><span class="line">      Class&lt;?&gt; kc = null;                                                    </span><br><span class="line">      boolean searched = false;                                              </span><br><span class="line">      TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;</span><br><span class="line">      //循环树节点                 </span><br><span class="line">      for (TreeNode&lt;K,V&gt; p = root;;) &#123;                                       </span><br><span class="line">          int dir, ph; K pk;                                                 </span><br><span class="line">          if ((ph = p.hash) &gt; h)                                             </span><br><span class="line">              dir = -1;                                                      </span><br><span class="line">          else if (ph &lt; h)                                                   </span><br><span class="line">              dir = 1;                                                       </span><br><span class="line">          else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))         </span><br><span class="line">              return p;                                                      </span><br><span class="line">          else if ((kc == null &amp;&amp;                                            </span><br><span class="line">                    (kc = comparableClassFor(k)) == null) ||                 </span><br><span class="line">                   (dir = compareComparables(kc, k, pk)) == 0) &#123;             </span><br><span class="line">              if (!searched) &#123;                                               </span><br><span class="line">                  TreeNode&lt;K,V&gt; q, ch;                                       </span><br><span class="line">                  searched = true;                                           </span><br><span class="line">                  if (((ch = p.left) != null &amp;&amp;                              </span><br><span class="line">                       (q = ch.find(h, k, kc)) != null) ||                   </span><br><span class="line">                      ((ch = p.right) != null &amp;&amp;                             </span><br><span class="line">                       (q = ch.find(h, k, kc)) != null))                     </span><br><span class="line">                      return q;                                              </span><br><span class="line">              &#125;                                                              </span><br><span class="line">              dir = tieBreakOrder(k, pk);                                    </span><br><span class="line">          &#125;                                                                  </span><br><span class="line">                                                                             </span><br><span class="line">          TreeNode&lt;K,V&gt; xp = p;                                              </span><br><span class="line">          if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;                 </span><br><span class="line">              Node&lt;K,V&gt; xpn = xp.next;                                       </span><br><span class="line">              TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);               </span><br><span class="line">              if (dir &lt;= 0)                                                  </span><br><span class="line">                  xp.left = x;                                               </span><br><span class="line">              else                                                           </span><br><span class="line">                  xp.right = x;                                              </span><br><span class="line">              xp.next = x;                                                   </span><br><span class="line">              x.parent = x.prev = xp;                                        </span><br><span class="line">              if (xpn != null)                                               </span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)xpn).prev = x;                             </span><br><span class="line">              moveRootToFront(tab, balanceInsertion(root, x));               </span><br><span class="line">              return null;                                                   </span><br><span class="line">          &#125;                                                                  </span><br><span class="line">      &#125;                                                                      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="7-扩容"><a href="#7-扩容" class="headerlink" title="7.扩容"></a>7.扩容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//扩容</span><br><span class="line">//这里有2种情况，1.初始化哈希表 2.当前数组容量过小，需扩容</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;   </span><br><span class="line">    // 把当前table 赋值给oldTba                                                                                           </span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;                                                                                           </span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;                                                                    </span><br><span class="line">    int oldThr = threshold;                                                                                               </span><br><span class="line">    int newCap, newThr = 0; </span><br><span class="line">    //如果扩容前的长度大于0                                                                                              </span><br><span class="line">    if (oldCap &gt; 0) &#123;         </span><br><span class="line">            //这里针对情况2 判断这个值是不是大于最大值                                                                                            </span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;    </span><br><span class="line">            //如果是最大值，那么久把Interger的值赋值过去                                                                             </span><br><span class="line">            threshold = Integer.MAX_VALUE;                                                                                </span><br><span class="line">            return oldTab;                                                                                                </span><br><span class="line">        &#125;                 </span><br><span class="line">        //这里针对情况2 若无超过最大值，就扩充为原来的2倍                                                                                                </span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                                                             </span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                                                                      </span><br><span class="line">            newThr = oldThr &lt;&lt; 1;                                                                    </span><br><span class="line">    &#125;     </span><br><span class="line">   // 针对情况1：初始化哈希表采用初始化指定值或者默认值的方式                                                                                                            </span><br><span class="line">    else if (oldThr &gt; 0)</span><br><span class="line">        newCap = oldThr;                                                                                                  </span><br><span class="line">    else &#123;                                               </span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;                                                                                </span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);                                                   </span><br><span class="line">    &#125;     </span><br><span class="line">  //这里重新计算新的桶的长度的上限                                                                                                                </span><br><span class="line">    if (newThr == 0) &#123;                                                                                                    </span><br><span class="line">        float ft = (float)newCap * loadFactor;                                                                            </span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);                                                                           </span><br><span class="line">    &#125;                                                                                                                     </span><br><span class="line">    threshold = newThr;              </span><br><span class="line">                                                                                         </span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)                                                                           </span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];                                                                   </span><br><span class="line">    table = newTab;                 </span><br><span class="line">    //如果扩容前的值不是null                                                                                      </span><br><span class="line">    if (oldTab != null) &#123;      </span><br><span class="line">        //循环放入新的桶中                                                                                           </span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;                                                                                </span><br><span class="line">            Node&lt;K,V&gt; e;       </span><br><span class="line">            //把 索引为j的节点赋值给e                                                                                           </span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;                                                                                </span><br><span class="line">                oldTab[j] = null;     </span><br><span class="line">                //如果e的下一个节点为空                                                                                  </span><br><span class="line">                if (e.next == null) </span><br><span class="line">                    //直接创建新的节点， e.hash&amp;新的长度-1                                                                                      </span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                    //这里还是优先判断了是不是树结构                                                                    </span><br><span class="line">                else if (e instanceof TreeNode)                                                                           </span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);              </span><br><span class="line">                //链表优化逻辑                                          </span><br><span class="line">                else &#123;                                                                    </span><br><span class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;                                                               </span><br><span class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                                                               </span><br><span class="line">                    Node&lt;K,V&gt; next;                                                                                       </span><br><span class="line">                    do &#123;                                                                                           </span><br><span class="line">                        next = e.next;   </span><br><span class="line">                        //原来的索引                                                       </span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;                                                                     </span><br><span class="line">                            if (loTail == null)                                                                           </span><br><span class="line">                                loHead = e;                                                                               </span><br><span class="line">                            else                                                                                          </span><br><span class="line">                                loTail.next = e;                                                                          </span><br><span class="line">                            loTail = e;                                                                                   </span><br><span class="line">                        &#125;   </span><br><span class="line">                          // 原索引 + oldCap                                                                                              </span><br><span class="line">                        else &#123;                                                                                            </span><br><span class="line">                            if (hiTail == null)                                                                           </span><br><span class="line">                                hiHead = e;                                                                               </span><br><span class="line">                            else                                                                                          </span><br><span class="line">                                hiTail.next = e;                                                                          </span><br><span class="line">                            hiTail = e;                                                                                   </span><br><span class="line">                        &#125;                                                                                                 </span><br><span class="line">                    &#125; while ((e = next) != null);   </span><br><span class="line">                    // 原索引放到bucket里                                                                      </span><br><span class="line">                    if (loTail != null) &#123;                                                                                 </span><br><span class="line">                        loTail.next = null;                                                                               </span><br><span class="line">                        newTab[j] = loHead;                                                                               </span><br><span class="line">                    &#125;      </span><br><span class="line">                    // 原索引+oldCap放到bucket里                                                                                              </span><br><span class="line">                    if (hiTail != null) &#123;                                                                                 </span><br><span class="line">                        hiTail.next = null;                                                                               </span><br><span class="line">                        newTab[j + oldCap] = hiHead;                                                                      </span><br><span class="line">                    &#125;                                                                                                     </span><br><span class="line">                &#125;                                                                                                         </span><br><span class="line">            &#125;                                                                                                             </span><br><span class="line">        &#125;                                                                                                                 </span><br><span class="line">    &#125;                                                                                                                     </span><br><span class="line">    return newTab;                                                                                                        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-get"><a href="#8-get" class="headerlink" title="8.get"></a>8.get</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//get key</span><br><span class="line"> public V get(Object key) &#123;                                           </span><br><span class="line">     Node&lt;K,V&gt; e;                                                     </span><br><span class="line">     return (e = getNode(hash(key), key)) == null ? null : e.value;   </span><br><span class="line"> &#125;         </span><br><span class="line"> </span><br><span class="line">  final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;                              </span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    </span><br><span class="line">     //计算存放在数组table中的位置          </span><br><span class="line">     if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;                     </span><br><span class="line">         (first = tab[(n - 1) &amp; hash]) != null) &#123;  </span><br><span class="line">         //依次在数组、红黑树、链表中查找（通过equals（）判断） </span><br><span class="line">         //1.先在数组中找，若存在，则直接返回                          </span><br><span class="line">         if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))      </span><br><span class="line">             return first; </span><br><span class="line">                                                           </span><br><span class="line">         if ((e = first.next) != null) &#123; </span><br><span class="line">            //2.如果数组里没有获取树节点 直接从树里边拿                                     </span><br><span class="line">             if (first instanceof TreeNode)                                   </span><br><span class="line">                 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);        </span><br><span class="line">            //3.在连表里循环查找</span><br><span class="line">             do &#123;                                                             </span><br><span class="line">                 if (e.hash == hash &amp;&amp;                                        </span><br><span class="line">                     ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))  </span><br><span class="line">                     return e;                                                </span><br><span class="line">             &#125; while ((e = e.next) != null);                                  </span><br><span class="line">         &#125;                                                                    </span><br><span class="line">     &#125;                                                                        </span><br><span class="line">     return null;                                                             </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="9-hashMap的总结以及存在的问题"><a href="#9-hashMap的总结以及存在的问题" class="headerlink" title="9 hashMap的总结以及存在的问题"></a>9 hashMap的总结以及存在的问题</h2><h3 id="1-为什么hashMap的长度为2的次幂"><a href="#1-为什么hashMap的长度为2的次幂" class="headerlink" title="1.为什么hashMap的长度为2的次幂"></a>1.为什么hashMap的长度为2的次幂</h3><p>一句话来说HashMap的长度为2的幂次方的原因是为了减少Hash碰撞，尽量使Hash算法的结果均匀分布。<br>因为2的次幂的Length - 1的值的二进制所有的位均为1，这种情况下，Index的结果等于hashCode的最后几位，所以输入的hashCode本身符合均匀分布，Hash算法的结果就是均匀的。</p><h3 id="2-为什么不用hash码作为数组的下标"><a href="#2-为什么不用hash码作为数组的下标" class="headerlink" title="2.为什么不用hash码作为数组的下标"></a>2.为什么不用hash码作为数组的下标</h3><p> 1.可能长度不够,也就是说算出来的hash可能不在数组的大小范围内，导致无法存储<br> 2.hashMap可能用不到这么大的空间</p><h3 id="3-为什么生成hash值要做2次扰动操作（一次位移，一次异或）"><a href="#3-为什么生成hash值要做2次扰动操作（一次位移，一次异或）" class="headerlink" title="3.为什么生成hash值要做2次扰动操作（一次位移，一次异或）"></a>3.为什么生成hash值要做2次扰动操作（一次位移，一次异或）</h3><p>一句话来说就是为了减少hash的冲突，使其hash值均匀分布</p><h3 id="4-为什么计算数组下标的时候还要做一次扰动"><a href="#4-为什么计算数组下标的时候还要做一次扰动" class="headerlink" title="4.为什么计算数组下标的时候还要做一次扰动"></a>4.为什么计算数组下标的时候还要做一次扰动</h3><p> 加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 &amp; 均匀性，最终减少Hash冲突说就是为了减少hash的冲突，使其hash值均匀分布 </p><h3 id="5-多线程下的问题"><a href="#5-多线程下的问题" class="headerlink" title="5. 多线程下的问题"></a>5. 多线程下的问题</h3><p>1.8的修改了1.7头部插入的方式，所以不会出现环形链表的形式</p><p>​                                                                     </p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashMap相关&quot;&gt;&lt;a href=&quot;#HashMap相关&quot; class=&quot;headerlink&quot; title=&quot;HashMap相关&quot;&gt;&lt;/a&gt;HashMap相关&lt;/h1&gt;&lt;p&gt;首先先查看类图，此hashMap为jdk1.8&lt;br&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/2fxhd.png?x-oss-process=style/logomark&quot; alt=&quot;image-20190719095818991&quot;&gt;&lt;br&gt;Hahsmap继承了AbstractMap实现了Map接口&lt;/p&gt;
    
    </summary>
    
      <category term="小胖出品" scheme="http://www.cmlanche.com/categories/%E5%B0%8F%E8%83%96%E5%87%BA%E5%93%81/"/>
    
    
      <category term="hashmap" scheme="http://www.cmlanche.com/tags/hashmap/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPool相关整理</title>
    <link href="http://www.cmlanche.com/2019/07/19/ThreadPool%E7%9B%B8%E5%85%B3%E6%95%B4%E7%90%86/"/>
    <id>http://www.cmlanche.com/2019/07/19/ThreadPool相关整理/</id>
    <published>2019-07-19T01:57:25.000Z</published>
    <updated>2019-07-19T02:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadPool相关"><a href="#ThreadPool相关" class="headerlink" title="ThreadPool相关"></a>ThreadPool相关</h1><p>如类图<br><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/tnu2q.png?x-oss-process=style/logomark" alt="image-20190719095600612"><br>ThreaPoolExecutor继承了AbstractExecutorService<br>AbstractExecutorService 实现了ExecutorService接口</p><a id="more"></a><p>##重要参数<br>    1.AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 线程状态<br>    2.COUNT_BITS =  Integer.SIZE - 3 线程个数掩码位数<br>    3.CAPACITY =(1 &lt;&lt; COUNT_BITS) - 1;线程最大个数<br>    4.workQueue 工作队列<br>    5.ReentrantLock<br>    6.Condition termination 持有锁的某个节点<br>    7.HashSet<worker> workers 任务集合<br>    8.RejectedExecutionHandler handler 拒绝策略<br>    9.long keepAliveTime 空闲线程的存活时间<br>    10.corePoolSize 核心线程数<br>    11.volatile maximumPoolSize 最大线程数</worker></p><p>​    </p><p>##状态变化<br>    running -&gt;shown 显式的调用showdown方法，或者隐式的调用finalize（这里会执行showdown）<br>    running -&gt;stop 显式的调用shutdownNow方法。<br>    showdown-&gt;stop 显式调用 shutdownNow方法<br>    shutdown-&gt;tidying 线程池和任务队列都为空的情况<br>    stop-&gt;tidying   当线程池都为空的时候<br>    tidying-&gt;terminated   当 terminated() 钩子方法执行完成时候。</p><p>##方法解析</p><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//如果是null直接抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="comment">//获取状态然后计算线程数。是不是小于核心线程数</span></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="comment">//直接添加。这里执行addWorker方法 传入了command,和true 。添加成功后直接返回</span></span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//检查是不是运行并且队列放入成功</span></span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="comment">//再次获取线程的状态</span></span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="comment">//如果不是运行状态那就删除任务</span></span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               <span class="comment">//执行拒绝策略</span></span><br><span class="line">               reject(command);</span><br><span class="line">           <span class="comment">//如果当前线程池线程空，则添加一个线程</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">               <span class="comment">//这里就直接返回fasel了，为了保证core线程数</span></span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果队列满了，新增线程，如果失败执行拒绝策略</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拒绝策略 默认的是 AbortPolicy 当线程中线程都在跑，并且队列满了的话，直接丢弃任务并抛出</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.firstTask 第一个任务</span><br><span class="line"><span class="number">2</span>.core是否核心线程执行</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">            <span class="comment">//检查这个队列是不是为null</span></span><br><span class="line">            <span class="comment">//1 线程池运行状态是停止,或者是中断状态 会返回false</span></span><br><span class="line">            <span class="comment">//2 第一个任务是null ，3，检查队列是不是null</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取工作线程个数</span></span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">//工作线程是否大于最大线程数，或者大于核心线程数，返回false</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize :maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//cas 设置设置工作线程数</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                <span class="comment">//获取运行状态，然后终止当前循环</span></span><br><span class="line">                c = ctl.get();</span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里说明cas设置工作线程数成功</span></span><br><span class="line">        <span class="comment">//workerStarted 是否启动。workerAdded 是否添加成功</span></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//新建一个工作任务</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//加锁，因为可能有多个线程来执行addWorker</span></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取线程池运行状态</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                    <span class="comment">//检查线程池运行状态是否停止，或者任务是null</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;                <span class="comment">//如果t是存活的 那么久抛出异常</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive())                             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">//set集合添加工作任务</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="comment">//获取集合的的长度</span></span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="comment">//集合长度大于最大的长度</span></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        <span class="comment">//这里添加成功</span></span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//添加成功后启动</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    <span class="comment">//启动成功</span></span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//如果任务是null,或者状态是停止，那么久走添加失败</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                <span class="comment">//任务添加失败</span></span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="addWorkerFailed-方法"><a href="#addWorkerFailed-方法" class="headerlink" title="addWorkerFailed 方法"></a>addWorkerFailed 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务添加失败 ，参数 工作任务</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可能有多个线程在执行</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是null</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//集合删除任务</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">//删除线程数</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">//尝试终止</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runWorker-执行任务"><a href="#runWorker-执行任务" class="headerlink" title="runWorker 执行任务"></a>runWorker 执行任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加工作任务，参数Worker</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        <span class="comment">//赋值为null</span></span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//释放锁。如果此时线程池的状态要是showdown那么要停止线程</span></span><br><span class="line">        w.unlock(); </span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//这里如果发生异常，直接走finally，processWorkerExit传入的参数就是w，和true</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果task不是null,或者task = getTask()不等于null</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">//如果是stop状态。或者中断</span></span><br><span class="line">               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                    <span class="comment">//打断线程</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//beforeExecute 这个是个空的方法</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//afterExecute 这个是个空的方法</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//任务技术器增加</span></span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    <span class="comment">//释放锁</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//清理线程任务</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="processWorkerExit清理工作"><a href="#processWorkerExit清理工作" class="headerlink" title="processWorkerExit清理工作"></a>processWorkerExit清理工作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2个参数，Worker 工作对象，completedAbruptly</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果是true，说明执行任务发生异常，减少工作任务计数器</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly)  </span><br><span class="line">         decrementWorkerCount();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终止</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="comment">//获取运行状态，</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果运行状态小于stop</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">//执行任务成功，</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//根据allowCoreThreadTimeOut这个状态来获取值（allowCoreThreadTimeOut 默认是false,就是即使线程池空闲核心线程池也要保持活动状态，如果是true就用keepAliveTime 超时等待工作）</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">//如果是tue,min=0，并且队列里有任务</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//计算线程工作的数量，如果大于min直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加一个空的任务，来保证core的数量</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####shutdown 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里检查权限</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//设置线程池运行状态，设置成SHUTDOWN，成功后返回ture</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">//中断线程，如果是runing状态的等运行完成</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试终止</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>####shutdownnow 方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//立即结束</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查权限</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//设置状态为stop</span></span><br><span class="line">            advanceRunState(STOP);</span><br><span class="line">            <span class="comment">//不管线程是不是运行，直接中断</span></span><br><span class="line">            interruptWorkers();</span><br><span class="line">            <span class="comment">//把任务循环放进list中</span></span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                  <span class="comment">//直接中断</span></span><br><span class="line">                w.interruptIfStarted();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="checkShutdownAccess"><a href="#checkShutdownAccess" class="headerlink" title="checkShutdownAccess"></a>checkShutdownAccess</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检查有没有终止权限</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkShutdownAccess</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">            <span class="comment">//获取权限认证</span></span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="comment">//如果不是null</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkPermission(shutdownPerm);</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                    <span class="comment">//检查访问权限</span></span><br><span class="line">                    security.checkAccess(w.thread);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>####tryTerminate<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尝试终止</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">//检查状态，是不是满足终止状态的条件，如果不满足就返回</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                runStateAtLeast(c, TIDYING) ||</span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//如果线程工作线程不是0，那么久中断正在等待任务的线程然后返回</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>)&#123;</span><br><span class="line">               interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//更新成终止状态</span></span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                        <span class="comment">//唤醒等待节点。</span></span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>##内部类Worker解析<br>首先先看一下类图<br><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/eu65e.png?x-oss-process=style/logomark" alt="image-20190719095655850"><br>     Worker extends AbstractQueuedSynchronizer implements Runnable，worker继承了aqs 实现了runnbale的接口</p><ol><li>###内部类重要参数<br> 1.serialVersionUID emmm，这个是为了防止javac的警告<br> 2.final Thread thread 工作线程，由ThreadFactory传入，如果创建失败就传入个null<br> 3.Runnable firstTask 运行的第一任务，可能为null<br> 4.volatile long completedTasks 执行任务的数量</li></ol><p>####构造方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//传进来了一个runnable</span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-1);</span><br><span class="line">            this.firstTask = firstTask;</span><br><span class="line">            this.thread </span><br><span class="line">            //用线程工厂来创建线程</span><br><span class="line">            =getThreadFactory().newThread(this);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>####重要方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行的方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断线程，状态大于0，线程不是null.不是中断状态</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadPool相关&quot;&gt;&lt;a href=&quot;#ThreadPool相关&quot; class=&quot;headerlink&quot; title=&quot;ThreadPool相关&quot;&gt;&lt;/a&gt;ThreadPool相关&lt;/h1&gt;&lt;p&gt;如类图&lt;br&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/tnu2q.png?x-oss-process=style/logomark&quot; alt=&quot;image-20190719095600612&quot;&gt;&lt;br&gt;ThreaPoolExecutor继承了AbstractExecutorService&lt;br&gt;AbstractExecutorService 实现了ExecutorService接口&lt;/p&gt;
    
    </summary>
    
      <category term="小胖出品" scheme="http://www.cmlanche.com/categories/%E5%B0%8F%E8%83%96%E5%87%BA%E5%93%81/"/>
    
    
      <category term="threadpool" scheme="http://www.cmlanche.com/tags/threadpool/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制整理</title>
    <link href="http://www.cmlanche.com/2019/07/19/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%95%B4%E7%90%86/"/>
    <id>http://www.cmlanche.com/2019/07/19/类加载机制整理/</id>
    <published>2019-07-19T01:54:15.000Z</published>
    <updated>2019-07-19T02:27:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载相关"><a href="#类加载相关" class="headerlink" title="类加载相关"></a>类加载相关</h1><p>classLoader相关类的初始化 </p><a id="more"></a><p>##加载流程</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><pre><code>待完善</code></pre><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><pre><code>待完善</code></pre><p>##类的初始化<br>主要详解类的初始化。</p><p>###可以初初始化的几种情况</p><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><pre><code>1.当使用new这个关键字实例化对象、读取或者设置一个类的静态字段，以及调用一个类的静态方法时会触发类的初始化(final 修饰的静态字段除外)。2.使用java.lang.reflect包的方法对类进行反射调用时，如果这个类还没有进行过初始化，则会触发该类的初始化。3.当初始化一个类的时候，如果其父类还没有进行过初始化，那么久先初始化其父类4.指定一个要执行的主类的时候(包含main()函数)5.jdk1.7开始提供了动态语言相关（invokedynamic 指令）</code></pre><h4 id="被动使用-不会初始化"><a href="#被动使用-不会初始化" class="headerlink" title="被动使用 不会初始化"></a>被动使用 不会初始化</h4><pre><code>1.通过数组定义应用类。2.子类引用父类的静态字段，是子类的被动使用不会初始化子类。3.static final修饰的常量(Random 这种运行时间才确定的值除外)。</code></pre><h4 id="主动使用几种情况"><a href="#主动使用几种情况" class="headerlink" title="主动使用几种情况"></a>主动使用几种情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">场景<span class="number">1</span>.new 关键字主动使用</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里new 了一个 TestOneParent</span></span><br><span class="line">        TestOneParent testOneParent = <span class="keyword">new</span> TestOneParent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestOneParent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s = <span class="string">"Hello word"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"this  static  block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">会发现在控制台输出<span class="string">"this  static  block"</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">场景<span class="number">2</span>. 使用反射的时候会主动初始化</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader classLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        Class clazz = classLoader.     loadClass(<span class="string">"com.jvm.classloader.relyclass.FiveTestClass"</span>);</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">        System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">        clazz = Class.forName(<span class="string">"com.jvm.classloader.relyclass.FiveTestClass"</span>);</span><br><span class="line">        System.out.println(clazz.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FiveTestClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello word"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">jvm</span>.<span class="title">classloader</span>.<span class="title">relyclass</span>.<span class="title">FiveTestClass</span></span></span><br><span class="line"><span class="class">-------</span></span><br><span class="line"><span class="class"><span class="title">hello</span> <span class="title">word</span></span></span><br><span class="line"><span class="class"><span class="title">com</span>.<span class="title">jvm</span>.<span class="title">classloader</span>.<span class="title">relyclass</span>.<span class="title">FiveTestClass</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">由此可见，<span class="title">ClassLoader</span>.<span class="title">loadClass</span> 不会使类进行初始化。<span class="title">loadClass</span>的方法只是把字节码对象加载到内存当中。</span></span><br><span class="line">而Class.forName("xxxx")会对类做初始化,我们来看下forName的方法</span><br><span class="line"> <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">    &#125;</span><br><span class="line">这个方法上的注释说 A call </span><br><span class="line">to &#123;<span class="meta">@code</span> forName(<span class="string">"X"</span>)&#125; causes the </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">named</span> </span>&#123;<span class="meta">@code</span> X&#125; to be initialized. 类名为x的类会被初始化,</span><br><span class="line">它调用的 <span class="keyword">native</span>方法。</span><br><span class="line">嗯，等我看看hotspot的时候再回来补充。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>.使用子类的时候会主动初始化其父类。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestChild testChild  = <span class="keyword">new</span> TestChild();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestOneParent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s = <span class="string">"Hello word"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"this  static  block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestChild</span> <span class="keyword">extends</span> <span class="title">TestOneParent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String skr = <span class="string">"skr"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"child  one static  block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">会发现 这样的输出</span><br><span class="line"><span class="keyword">this</span>  <span class="keyword">static</span>  block（这是父类的输出）</span><br><span class="line">child  one <span class="keyword">static</span>  block（这是子类的输出）</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span>.指定一个要执行的主类的时候(包含main()函数)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"staci block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello  test4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>5.非常遗憾，第五种情况我暂时还模拟不出来。</code></pre><h4 id="被动引用为什么不会初始化解析"><a href="#被动引用为什么不会初始化解析" class="headerlink" title="被动引用为什么不会初始化解析"></a>被动引用为什么不会初始化解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span>.通过数组定义应用类。我们来查看下代码</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        String[] strings = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">    System.out.println(strings.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    在<span class="number">1</span>.处定义了一个<span class="number">10</span>个长度的字符串数组,</span><br><span class="line">    然后在输出这个数组的class类型:class [Ljava.lang.String;</span><br><span class="line">    让我们来反编译一下这个类的字节码 执行以下Javap -v +xxx.class</span><br><span class="line">    ![-w1272](media/<span class="number">15601533760261</span>/<span class="number">15619025813654</span>.jpg)</span><br><span class="line">anewarray:是jvm中的指令,在运行时创建一个新的数组对象，创建一个引用类型的数组并将其压入栈顶。</span><br><span class="line">class  [L, [这个代表的是一维数组，L+java.lang.String.会发现其中的类型就是元素的类型</span><br><span class="line"></span><br><span class="line">咱们来看一下基本类型的数组是什么样结构的</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line">        System.out.println(ints.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    在<span class="number">1</span>处定义了一个<span class="number">10</span>长度的<span class="keyword">int</span>类型的数组</span><br><span class="line">    2还是输出，但是输出的内容变了。class [I</span><br><span class="line">    让我们来反编译一下这个类的字节码 执行以下Javap -v +xxx.class</span><br><span class="line">![-w1122](media/<span class="number">15601533760261</span>/<span class="number">15619033399256</span>.jpg)</span><br><span class="line">看这个指令换成了newarray，他的作用就是创建一个基本类型的数组并将其压入栈顶。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>.<span class="keyword">static</span> <span class="keyword">final</span>修饰的常量</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test6_1.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test6_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"test6_1 static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">可以发现不会发打印出来 test6_1 <span class="keyword">static</span> block</span><br><span class="line">让我们来编译一下这个类的<span class="class"><span class="keyword">class</span>文件</span></span><br><span class="line">![-w1231](media/15601533760261/15619046847976.jpg)</span><br><span class="line">可以看到这个iconst_1助记符，这个是给<span class="keyword">int</span> 类型赋值然后压到栈顶。这就说明如果调用<span class="keyword">static</span> <span class="keyword">final</span> 的常量 在编译期间就在调用的类的常量池中确定了。</span><br><span class="line"></span><br><span class="line">咱们再来写一下不能再编译期间确定值得。</span><br><span class="line">更改Test6_1的代码</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test6_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"test6_1 static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">然后执行会发现静态代码块被输出了。</span><br><span class="line">然后在编译一下<span class="class"><span class="keyword">class</span>文件</span></span><br><span class="line"><span class="class">发现</span></span><br><span class="line">![-w1190](media/15601533760261/15619049449977.jpg)</span><br><span class="line">变成了getstatic指令 代表<span class="keyword">int</span>的偏移量 也就是定位的地址。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>.子类引用父类的静态字段，是子类的被动使用不会初始化子类。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Test7_2.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test7_1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i =<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Test7_1 static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test7_2</span> <span class="keyword">extends</span> <span class="title">Test7_1</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Test7_2 static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出是</span><br><span class="line">Test7_1 <span class="keyword">static</span> block</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>##classLoader<br>    Java中有3种类加载器。<br>AppClassLoader,ExtClassLoader,BootstrapClassloader</p><p>##classLoader命名空间</p><p>##双亲委派模型</p><p>##类的卸载</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;类加载相关&quot;&gt;&lt;a href=&quot;#类加载相关&quot; class=&quot;headerlink&quot; title=&quot;类加载相关&quot;&gt;&lt;/a&gt;类加载相关&lt;/h1&gt;&lt;p&gt;classLoader相关类的初始化 &lt;/p&gt;
    
    </summary>
    
      <category term="小胖出品" scheme="http://www.cmlanche.com/categories/%E5%B0%8F%E8%83%96%E5%87%BA%E5%93%81/"/>
    
    
      <category term="classloader" scheme="http://www.cmlanche.com/tags/classloader/"/>
    
  </entry>
  
  <entry>
    <title>记录一次网络拥塞导致线程池处于等待状态</title>
    <link href="http://www.cmlanche.com/2019/07/12/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%84%E4%BA%8E%E7%AD%89%E5%BE%85%E7%8A%B6%E6%80%81/"/>
    <id>http://www.cmlanche.com/2019/07/12/记录一次网络拥塞导致线程池处于等待状态/</id>
    <published>2019-07-12T09:37:44.000Z</published>
    <updated>2019-07-12T09:45:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>一次批量执行任务（12个），最后任务执行成功会批量上传图片，导致线程池都处于等待状态。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/hdkut.jpg?x-oss-process=style/logomark" alt="19481562921545_.pic_hd"></p><p>首先这个线程池是通过<code>newSingleThreadExecutor</code>来创建的，并且在执行过程中，不会有新的任务进来，当时的情况是在线程执行过程中卡主，实际发生在上传图片，类似的线程池多大12个，每个线程上传的图片可能多大上百张。</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>分析上面jstack打印的日志（打印方法是<code>jstack pid</code>），有个<code>waiting on condition</code>，它的含义，我搜了下，是这样的</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/oh7zg.jpg?x-oss-process=style/logomark" alt="19541562924017_.pic_hd"></p><p>由此可以猜测，可能是大并发上传图片导致网络拥塞</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>做一个固定线程大小的线程池，比如3个，专门用于并发上传图片，避免网络拥塞。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h3&gt;&lt;p&gt;一次批量执行任务（12个），最后任务执行成功会批量上传图片，导致线程池都处于等待状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/hdkut.jpg?x-oss-process=style/logomark&quot; alt=&quot;19481562921545_.pic_hd&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先这个线程池是通过&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;来创建的，并且在执行过程中，不会有新的任务进来，当时的情况是在线程执行过程中卡主，实际发生在上传图片，类似的线程池多大12个，每个线程上传的图片可能多大上百张。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java性能优化" scheme="http://www.cmlanche.com/tags/java%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>问答四部曲</title>
    <link href="http://www.cmlanche.com/2019/06/20/%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98%E5%9B%9B%E9%83%A8%E6%9B%B2/"/>
    <id>http://www.cmlanche.com/2019/06/20/回答问题四部曲/</id>
    <published>2019-06-20T02:11:05.000Z</published>
    <updated>2019-07-09T03:11:29.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>它是什么</li><li>影响和意义</li><li>怎么解决的</li><li>有什么心得</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;它是什么&lt;/li&gt;
&lt;li&gt;影响和意义&lt;/li&gt;
&lt;li&gt;怎么解决的&lt;/li&gt;
&lt;li&gt;有什么心得&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>部分手机adb install快速返回成功导致appium测试失败的解决办法</title>
    <link href="http://www.cmlanche.com/2019/06/19/%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BAadb-install%E5%BF%AB%E9%80%9F%E8%BF%94%E5%9B%9E%E6%88%90%E5%8A%9F%E5%AF%BC%E8%87%B4appium%E6%B5%8B%E8%AF%95%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://www.cmlanche.com/2019/06/19/部分手机adb-install快速返回成功导致appium测试失败的解决办法/</id>
    <published>2019-06-19T03:20:06.000Z</published>
    <updated>2019-06-19T03:25:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们可以在命令行中执行adb install安装某个应用，会发现快速返回Success了，而实际应用正在安装中，这种情况下，appium会误以为被测应用已经安装上了，然后去启动这个app，结果发现app不存在（appium重重试一次，仍然失败），这种情况下，appium测试100%会失败。</p><p>事故手机：OPPO R9sk</p><p>测试的Appium版本：1.12.1</p><a id="more"></a><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>找到安装app的地方，安装完后，检测app是否真正安装成功了，如果没成功，则等待，直到超时或者成功安装。</p><h2 id="实施办法"><a href="#实施办法" class="headerlink" title="实施办法"></a>实施办法</h2><p>针对UIAutomator1，我们需要更改appium-android-driver，我们找到lib/driver.js的initAUT方法，在代码await helpers.installApk(this.adb, this.opts);后加上这个检测过程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> helpers.installApk(<span class="keyword">this</span>.adb, <span class="keyword">this</span>.opts);</span><br><span class="line">log.info(<span class="string">'安装应用后，检查被测应用是否存在'</span>);</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">this</span>.waitPackagePresent(<span class="number">60000</span>);</span><br></pre></td></tr></table></figure><p>waitPackagePresent就是这个检测过程的方法，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 一定时间内等待某包出现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">async</span> waitPackagePresent (timeout) &#123;</span><br><span class="line">   log.info(<span class="string">`waitPackagePresent: <span class="subst">$&#123;timeout&#125;</span>`</span>);</span><br><span class="line">   <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">   <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - start &lt; timeout) &#123;</span><br><span class="line">     <span class="keyword">const</span> appState = <span class="keyword">await</span> <span class="keyword">this</span>.adb.getApplicationInstallState(<span class="keyword">this</span>.opts.app, <span class="keyword">this</span>.opts.appPackage);</span><br><span class="line">     log.info(<span class="string">`app state is <span class="subst">$&#123;appState&#125;</span> 1`</span>);</span><br><span class="line">     <span class="keyword">switch</span> (appState) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="string">'notInstalled'</span>:</span><br><span class="line">         log.info(<span class="string">`检测到<span class="subst">$&#123;<span class="keyword">this</span>.opts.appPackage&#125;</span>尚未安装上，等待1s，继续检测`</span>);</span><br><span class="line">         <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">         log.info(<span class="string">'被测应用已安装上'</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   log.errorAndThrow(<span class="string">`Could not find package <span class="subst">$&#123;<span class="keyword">this</span>.opts.appPackage&#125;</span> on the device in <span class="subst">$&#123;timeout&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>而针对UIAutomator2的话，同样我们找到UIAutomator2的nodejs驱动工程：appium-uiautomator2-driver，然后找到lib/driver.js，同样也是在initAUT方法中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.opts.app) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.opts.noSign &amp;&amp; !<span class="keyword">await</span> <span class="keyword">this</span>.adb.checkApkCert(<span class="keyword">this</span>.opts.app, <span class="keyword">this</span>.opts.appPackage)) &#123;</span><br><span class="line">    <span class="keyword">await</span> helpers.signApp(<span class="keyword">this</span>.adb, <span class="keyword">this</span>.opts.app);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> helpers.installApk(<span class="keyword">this</span>.adb, <span class="keyword">this</span>.opts);</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">this</span>.waitPackagePresent(<span class="number">60000</span>); <span class="comment">// 这是新增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitPackagePresent方法同上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们可以在命令行中执行adb install安装某个应用，会发现快速返回Success了，而实际应用正在安装中，这种情况下，appium会误以为被测应用已经安装上了，然后去启动这个app，结果发现app不存在（appium重重试一次，仍然失败），这种情况下，appium测试100%会失败。&lt;/p&gt;
&lt;p&gt;事故手机：OPPO R9sk&lt;/p&gt;
&lt;p&gt;测试的Appium版本：1.12.1&lt;/p&gt;
    
    </summary>
    
      <category term="Appium" scheme="http://www.cmlanche.com/categories/Appium/"/>
    
    
      <category term="appium" scheme="http://www.cmlanche.com/tags/appium/"/>
    
      <category term="adb-install" scheme="http://www.cmlanche.com/tags/adb-install/"/>
    
  </entry>
  
  <entry>
    <title>陪伴阿里云走过的5年之路</title>
    <link href="http://www.cmlanche.com/2019/06/16/%E9%99%AA%E4%BC%B4%E9%98%BF%E9%87%8C%E4%BA%91%E8%B5%B0%E8%BF%87%E7%9A%845%E5%B9%B4%E4%B9%8B%E8%B7%AF/"/>
    <id>http://www.cmlanche.com/2019/06/16/陪伴阿里云走过的5年之路/</id>
    <published>2019-06-16T14:53:07.000Z</published>
    <updated>2019-06-17T06:39:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一次使用阿里云"><a href="#第一次使用阿里云" class="headerlink" title="第一次使用阿里云"></a>第一次使用阿里云</h3><p>那个时候是2014年，我刚刚从大学毕业出来进入社会工作，这一年也是我萌生想额外做点产品的想法的时候，于是我找到了阿里云。</p><p>翻开阿里云的支付记录，可以清晰的看到第一笔支付发生在2014年3月9日：</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-16-150130.png?x-oss-process=style/logomark" alt="image-20190616230120771"></p><h3 id="126个交易记录"><a href="#126个交易记录" class="headerlink" title="126个交易记录"></a>126个交易记录</h3><p>时至今日2019年中旬618的时候，我已经从一个阿里云新手成长为了阿里云大使，总共发生了126个交易记录，这5年时间里，阿里云陪我走过了成长最快的工作生活。</p><p>开始我还只是会windows server，因为它有图形界面，那个时候对linux恐惧颇深，感觉深不可测，无法控制。而到现在，我已经精通linux，centos，Ubuntu等系统了。这也是在阿里云服务器中慢慢学习过来的。</p><a id="more"></a><h3 id="夭折了几个产品"><a href="#夭折了几个产品" class="headerlink" title="夭折了几个产品"></a>夭折了几个产品</h3><p>之前看<a href="https://www.sitebuilderreport.com/" target="_blank" rel="noopener">sitebuilderreport.com</a>的采访，链接：<a href="http://sideidea.com/article/3" target="_blank" rel="noopener">http://sideidea.com/article/3</a>，知道它月赚29万人民币，这还是2年前的事情了，我就想着模仿它做类似的网站，于是用阿里云做了第一个站，叫virturlhostreport.com，意思就是虚拟主机报告，想做这一块的主机深度评测网站，但是夭折了，一部分也是因为虚拟主机已经日落西山了，另一部分是seo始终没做上去，关键还是我不够坚持吧。</p><p>后来又做了主机排行网，这次就不限定是虚拟主机了，包括云主机和vps，这个网站是采用ghost博客来做的，自己用纯html+css+js来做的，网站速度极快，有网友评论说，”快到让人窒息”。这个网站大概给我挣了2k吧，发布更新了十几个版本，但就是因为更新迭代内容太慢，每次更新基本都需要我重新升级主题，而且我在对主机评测上又有了新的见解。</p><h3 id="现在的产品"><a href="#现在的产品" class="headerlink" title="现在的产品"></a>现在的产品</h3><p>我认为大的客户厂家的服务器基本没有什么性能啊优劣之分，最大的区别在于优惠、价格，如何能帮助客户省钱省时间省力气才是重点，省钱是第一要务。而且不同的客户的省钱方式不太一样，新手和老手不一样，个人和企业又不一样，需求有多种多样。因此我开发了现在的全面的主机优惠站<a href="https://zhaozhuji.info/" target="_blank" rel="noopener">找主机网</a>，简单截个图：</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-16-153317.jpg?x-oss-process=style/logomark" alt="WX20190616-233157@2x_meitu_2"></p><p>这个网站是我花了大概2个月的业余时间完成的，很是艰辛，基本每天都有提交记录。</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-16-153617.jpg?x-oss-process=style/logomark" alt="dd_meitu_3"></p><p>中间ui写了又换，bootstrap尝试过，放弃了，因为ui实在难看，也在themesforest上买过付费主题，但太笨重，js一大推，弄的我整个工程加载都很忙，界面也不大好，最后采用了bulma的纯css框架做的前端，整个站也按标准的css设计规则来做了，都知道程序员的ui感觉不大好，其实到现在我都觉得我的网站的ui不好看，哪天我还会再整。</p><p>我也设计了后台管理，方面我快速增加内容，修改需求，这也是从上面的失败案例主机排行网而来的，我得能够轻松快速的紧跟市场啊。我甚至自己设计SEO还有站点地图，稍微截个图吧：</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-16-154219.jpg?x-oss-process=style/logomark" alt="ad_meitu_4"></p><p><strong>为什么要自己写，而不是用WordPress？</strong></p><p>因为WordPress我不太会那些优化，而且关键是不符合我的需求，我是要能够定制不同的客户需求的，WordPress就是无脑的堆砌文章，现在市面上很多主机推荐网站，基本都采用WordPress，但是说真的，里面的内容眼花缭乱的，我认为根本给不到用户实质的价值，这些乱七八糟的内容其实是给搜索引擎看的，至于用户体验，拉倒吧，随你咋看。你去看<a href="https://www.sitebuilderreport.com/" target="_blank" rel="noopener">sitebuilderreport.com</a>，它的内容就井然有序，用户看着非常舒服，它也是作者完全自己写的。</p><h3 id="云大使的收入"><a href="#云大使的收入" class="headerlink" title="云大使的收入"></a>云大使的收入</h3><p>相比很多大佬来说很少，目前总共1427.97元，其中还有80000云气还没兑现。</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-16-155010.png?x-oss-process=style/logomark" alt="image-20190616235009159"></p><p>总共推广了大概150人，累积8人购买。</p><h3 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h3><p>坚持把<a href="https://zhaozhuji.info/" target="_blank" rel="noopener">找主机网zhaozhuji.info</a>做下去，坚持每天更新一篇文章，把seo做上去，能够形成不错的自然流量，到那时，也不至于跟现在这样推广的如此艰辛。</p><p>可以的话，帮我点个赞，地址：<a href="https://www.aliyun.com/acts/hi618/delivery?storyId=874749&amp;userCode=mm1tv2if" target="_blank" rel="noopener">https://www.aliyun.com/acts/hi618/delivery?storyId=874749&amp;userCode=mm1tv2if</a>，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一次使用阿里云&quot;&gt;&lt;a href=&quot;#第一次使用阿里云&quot; class=&quot;headerlink&quot; title=&quot;第一次使用阿里云&quot;&gt;&lt;/a&gt;第一次使用阿里云&lt;/h3&gt;&lt;p&gt;那个时候是2014年，我刚刚从大学毕业出来进入社会工作，这一年也是我萌生想额外做点产品的想法的时候，于是我找到了阿里云。&lt;/p&gt;
&lt;p&gt;翻开阿里云的支付记录，可以清晰的看到第一笔支付发生在2014年3月9日：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-16-150130.png?x-oss-process=style/logomark&quot; alt=&quot;image-20190616230120771&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;126个交易记录&quot;&gt;&lt;a href=&quot;#126个交易记录&quot; class=&quot;headerlink&quot; title=&quot;126个交易记录&quot;&gt;&lt;/a&gt;126个交易记录&lt;/h3&gt;&lt;p&gt;时至今日2019年中旬618的时候，我已经从一个阿里云新手成长为了阿里云大使，总共发生了126个交易记录，这5年时间里，阿里云陪我走过了成长最快的工作生活。&lt;/p&gt;
&lt;p&gt;开始我还只是会windows server，因为它有图形界面，那个时候对linux恐惧颇深，感觉深不可测，无法控制。而到现在，我已经精通linux，centos，Ubuntu等系统了。这也是在阿里云服务器中慢慢学习过来的。&lt;/p&gt;
    
    </summary>
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/categories/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
      <category term="找主机网" scheme="http://www.cmlanche.com/tags/%E6%89%BE%E4%B8%BB%E6%9C%BA%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>奔三分水岭杂想</title>
    <link href="http://www.cmlanche.com/2019/06/16/%E5%A5%94%E4%B8%89%E5%88%86%E6%B0%B4%E5%B2%AD%E6%9D%82%E6%83%B3/"/>
    <id>http://www.cmlanche.com/2019/06/16/奔三分水岭杂想/</id>
    <published>2019-06-16T11:00:38.000Z</published>
    <updated>2019-06-16T11:01:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/34v42.jpg?x-oss-process=style/logomark" alt="bensan_meitu_2"></p><p>昨天周六，在家折腾一天新创意，比如做dota2的赛况的小程序，结果审核不让通过，说需要提供4种”让人生畏”的材料，如下图：</p><a id="more"></a><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/ln7s7.png?x-oss-process=style/logomark" alt="image-20190616174938250"></p><p>基本上你想做类似于游戏沾边，热门关键词的话，个人和部分企业是无法申请的，直接把你们拒之门外。</p><p>想到，在中国做点东西真tm难，做出来难，能不能做更是难上加难，尤其对独立开发者来说。国内对创业的环境月来越差，对独立开发者来说也更加艰难，那些能在夹缝中生存的独立开发者，内心真心的佩服。</p><p>我接触了大概600位独立开发者和对独立开发者有兴趣的人，能够真正全职独立的少指又少，阿里一位个人开发者跟我说，”我看大佬们一通操作之后，发现还是上班最靠谱！”，确实啊，真正能做到独立开发大笔盈利的很少。</p><p>我以前对自己说，只要我能够自己稳定一个月赚5k，我就要全职，然后把三倍的时间把5k换成15k。想法很理想，能不能实现倒不说，就算能实现，那也是要经历极其残忍和痛苦的过程，可能这期间你的婚姻、家庭、父母等都承受更多压力，并且以后每天都在担心受怕中，也没有社保公积金等一些社会福利，你是独自一个人在战斗，风险过于庞大，如果你没有靠谱的资金后盾，那这几乎是送死的行为！</p><p>可能是我太着急，也可能是我压力太大，我个人家庭情况不允许我做这样的行为，我之前过的很理想，现在想明白了，我应该找一座能让我干一辈子的一个城，把自己最擅长的专业做到好，这是基本，可以填补我内心的焦躁不安。</p><p>可是我内心的理想却无法填补，一直对自己说，人生不干出名堂，枉来人世了，我的大学的座右铭还是”会当凌绝顶”，我的个人博客标题还是”金鳞岂是池中物”的豪言壮语，可是如今已奔三的我，感受到了什么是婚姻压力，什么是父母健康，什么是未来，我站在人生的分水岭，彷徨而不安，可又没有办法，在奔三的时候，我感觉我看到了我的未来。</p><p>我内心已有答案，人生什么最重要？<strong>我觉得是快乐，是父母的快乐，是兄弟姐妹的快乐，是妻子儿女的快乐，也是我的快乐</strong>，人生确实要有追求，但是不能急于给自己太大的压力去速成，犹记得三国杀某个英雄的一句话”静待良机，一鸣惊人”，慢慢来。</p><p>答案是什么？我的答案就是<strong>莫把客为本</strong>，过快乐生活，我想当个”真正自由人”，想财务解放，奈何实力不允许，那就静待良机吧。</p><p>每个人的答案都可能不一样，莫抄！</p><p>说完，我拿起手机，打开沉睡半年的王者荣耀(滑稽 ~ 玩笑话)</p><p>— 补充</p><p>今天父亲节，深知老爸不容易，祝老爸身体健康，万事如意。也祝各位围观的同学的父亲健健康康，一切都好！</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/8hduv.jpg?x-oss-process=style/logomark" alt="fqj_meitu_1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/34v42.jpg?x-oss-process=style/logomark&quot; alt=&quot;bensan_meitu_2&quot;&gt;&lt;/p&gt;
&lt;p&gt;昨天周六，在家折腾一天新创意，比如做dota2的赛况的小程序，结果审核不让通过，说需要提供4种”让人生畏”的材料，如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/categories/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>推广渠道系列 - 豆瓣帖子</title>
    <link href="http://www.cmlanche.com/2019/06/12/%E6%8E%A8%E5%B9%BF%E6%B8%A0%E9%81%93%E7%B3%BB%E5%88%97---%E8%B1%86%E7%93%A3/"/>
    <id>http://www.cmlanche.com/2019/06/12/推广渠道系列---豆瓣/</id>
    <published>2019-06-12T13:46:10.000Z</published>
    <updated>2019-06-17T01:55:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>独立开发者往往都不擅长推广，我也一样，但也得学会做推广，推广是慢慢的事情，无法一气呵成，因为穷。</p><p>在做完zhaozhuji.info这个站点后，发现最终还是得落实到推广上，因此我推出”推广渠道系列”文章，把我遇到的好的推广工具、方式分享出来，供大家参考。</p></blockquote><p>今天分享的是，<strong>豆瓣帖子</strong>。</p><a id="more"></a><p>经常搜索，发现很多内容豆瓣帖子都排在前面。</p><p>举例子：搜索”小众it技术社区”</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/resources/uwxup.png" alt="WX20190612-213514@2x"></p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/resources/fhfn2.png" alt="WX20190612-213533@2x"></p><p>其实内容不多，一个标题还有内容，没有seo的关键字和描述，但是这个页面被百度收录了，通过标题可以搜得到。</p><p>我们不妨效仿一下，在豆瓣上发布你的推广，注重标题和内容，期待它哪一天能够爆发！</p><p>比如我推广我的找主机网</p><p>标题：”2019年阿里云2.4折优惠购买指南”</p><p>内容：”阿里云对中国用户来说是最好的云计算服务厂商了，而它提供的优惠也多种多样，不管对玩主机的新手还是老手，面对各种各样的活动都会陷入眼花缭乱的困境，因此，我专门写一篇文章来给大家抽丝剥茧，详细描绘一下对不同的用户怎么购买主机才是最优惠的。”</p><p>外加一张截图和原文链接，猛戳看效果：<a href="https://www.douban.com/group/topic/143072327/" target="_blank" rel="noopener">https://www.douban.com/group/topic/143072327/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;独立开发者往往都不擅长推广，我也一样，但也得学会做推广，推广是慢慢的事情，无法一气呵成，因为穷。&lt;/p&gt;
&lt;p&gt;在做完zhaozhuji.info这个站点后，发现最终还是得落实到推广上，因此我推出”推广渠道系列”文章，把我遇到的好的推广工具、方式分享出来，供大家参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天分享的是，&lt;strong&gt;豆瓣帖子&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="推广渠道系列" scheme="http://www.cmlanche.com/categories/%E6%8E%A8%E5%B9%BF%E6%B8%A0%E9%81%93%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="推广" scheme="http://www.cmlanche.com/tags/%E6%8E%A8%E5%B9%BF/"/>
    
      <category term="推广渠道" scheme="http://www.cmlanche.com/tags/%E6%8E%A8%E5%B9%BF%E6%B8%A0%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>2019年阿里云主机优惠购买指南</title>
    <link href="http://www.cmlanche.com/2019/06/09/2019%E5%B9%B4%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%BC%98%E6%83%A0%E8%B4%AD%E4%B9%B0%E6%8C%87%E5%8D%97/"/>
    <id>http://www.cmlanche.com/2019/06/09/2019年阿里云主机优惠购买指南/</id>
    <published>2019-06-09T04:03:27.000Z</published>
    <updated>2019-06-09T04:05:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>阿里云对中国用户来说是最好的云计算服务厂商了，而它提供的优惠也多种多样，不管对玩主机的新手还是老手，面对各种各样的活动都会陷入眼花缭乱的困境，因此，我专门写一篇文章来给大家抽丝剥茧，详细描绘一下对不同的用户怎么购买主机才是最优惠的。</p></blockquote><h3 id="优惠活动图"><a href="#优惠活动图" class="headerlink" title="优惠活动图"></a>优惠活动图</h3><p>本人是拥有十年程序猿开发经验，大学本科四年，工作6年，软件工程出身，所以我用我们程序猿特有的软件来绘制一个优惠活动图。</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-08-095844.jpg?x-oss-process=style/logomark" alt="主机购买指南"></p><p>大概花了半个多小时绘制玩这张活动图 /(ㄒoㄒ)/~~</p><a id="more"></a><h3 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h3><ol><li>新用户：没注册过阿里云的用户或者注册且实名了但从未购买任何产品的用户</li><li>首购用户：表示已注册并实名认证后但从未购买该产品的用户</li><li>老用户：已实名并购买过该产品的用户</li></ol><h3 id="活动列表："><a href="#活动列表：" class="headerlink" title="活动列表："></a>活动列表：</h3><ol><li><a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=mm1tv2if" target="_blank" rel="noopener">阿里云新用户2000元新手红包</a></li></ol><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/resources/9kvj2.png" alt="image-20190608181007100"></p><ol start="2"><li><a href="https://www.aliyun.com/acts/hi-group-buying?source=5176.11533457&amp;userCode=mm1tv2if&amp;type=copy" target="_blank" rel="noopener">阿里云Hi拼团活动</a></li></ol><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/resources/sfxdi.png" alt="image-20190608181153225"></p><ol start="3"><li><a href="https://promotion.aliyun.com/ntms/act/qwbk.html?source=5176.11533457&amp;userCode=mm1tv2if&amp;type=copy" target="_blank" rel="noopener">阿里云首购3折活动</a></li></ol><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/resources/ivsc9.png" alt="image-20190608181258721"></p><h3 id="优惠路线"><a href="#优惠路线" class="headerlink" title="优惠路线"></a>优惠路线</h3><ol><li><strong>新用户路线</strong></li></ol><p><a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=mm1tv2if" target="_blank" rel="noopener">领取2000元红包</a> —&gt; 找老用户<a href="https://www.aliyun.com/acts/hi-group-buying?source=5176.11533457&amp;userCode=mm1tv2if&amp;type=copy" target="_blank" rel="noopener">开hi拼团活动</a>  —&gt; 2.4折优惠</p><p><a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=mm1tv2if" target="_blank" rel="noopener">领取2000元红包</a> —&gt; 参加首购活动 —&gt; 3折优惠</p><ol start="2"><li><strong>首购用户路线</strong></li></ol><p>找新用户<a href="https://www.aliyun.com/acts/hi-group-buying?source=5176.11533457&amp;userCode=mm1tv2if&amp;type=copy" target="_blank" rel="noopener">开hi拼团活动</a> —&gt; 可以找到 —&gt; 2.4折优惠</p><p>找新用户<a href="https://www.aliyun.com/acts/hi-group-buying?source=5176.11533457&amp;userCode=mm1tv2if&amp;type=copy" target="_blank" rel="noopener">开hi拼团活动</a> —&gt; 没找到 —&gt; 3折优惠</p><p>参加<a href="https://promotion.aliyun.com/ntms/act/qwbk.html?source=5176.11533457&amp;userCode=mm1tv2if&amp;type=copy" target="_blank" rel="noopener">首购活动</a> —&gt; 3折优惠</p><ol start="3"><li><strong>老用户且非首购路线</strong></li></ol><p>找新用户<a href="https://www.aliyun.com/acts/hi-group-buying?source=5176.11533457&amp;userCode=mm1tv2if&amp;type=copy" target="_blank" rel="noopener">开hi拼团活动</a> —&gt; 可以找到 —&gt; 2.4折优惠</p><p>找新用户<a href="https://www.aliyun.com/acts/hi-group-buying?source=5176.11533457&amp;userCode=mm1tv2if&amp;type=copy" target="_blank" rel="noopener">开hi拼团活动</a> —&gt; 没找到 —&gt; 直接购买 —&gt; 3折优惠</p><p>花了大概一个多小时认真写了这篇，也是想给自己刚上线的网站【<a href="https://zhaozhuji.info" target="_blank" rel="noopener">zhaozhuji.info</a>】做做推广，谢谢拜访！</p><p>其实做这个图也是得益于我的一个微信群”独立开发者”的，感谢小程序【魅力拍】作者徐玉丰，算也是给他做做推广，感谢他的启发！</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-08-102802.png?x-oss-process=style/logomark" alt="image-20190608182801166"></p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-08-102828.png?x-oss-process=style/logomark" alt="image-20190608182826446"></p><p>原文地址：<a href="https://zhaozhuji.info/post/2019-aliyun-youhui-tips" target="_blank" rel="noopener">https://zhaozhuji.info/post/2019-aliyun-youhui-tips</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;阿里云对中国用户来说是最好的云计算服务厂商了，而它提供的优惠也多种多样，不管对玩主机的新手还是老手，面对各种各样的活动都会陷入眼花缭乱的困境，因此，我专门写一篇文章来给大家抽丝剥茧，详细描绘一下对不同的用户怎么购买主机才是最优惠的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;优惠活动图&quot;&gt;&lt;a href=&quot;#优惠活动图&quot; class=&quot;headerlink&quot; title=&quot;优惠活动图&quot;&gt;&lt;/a&gt;优惠活动图&lt;/h3&gt;&lt;p&gt;本人是拥有十年程序猿开发经验，大学本科四年，工作6年，软件工程出身，所以我用我们程序猿特有的软件来绘制一个优惠活动图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-06-08-095844.jpg?x-oss-process=style/logomark&quot; alt=&quot;主机购买指南&quot;&gt;&lt;/p&gt;
&lt;p&gt;大概花了半个多小时绘制玩这张活动图 /(ㄒoㄒ)/~~&lt;/p&gt;
    
    </summary>
    
      <category term="主机优惠" scheme="http://www.cmlanche.com/categories/%E4%B8%BB%E6%9C%BA%E4%BC%98%E6%83%A0/"/>
    
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
      <category term="找主机网" scheme="http://www.cmlanche.com/tags/%E6%89%BE%E4%B8%BB%E6%9C%BA%E7%BD%91/"/>
    
      <category term="阿里云主机优惠" scheme="http://www.cmlanche.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%BC%98%E6%83%A0/"/>
    
  </entry>
  
  <entry>
    <title>免费logo创建器launchaco</title>
    <link href="http://www.cmlanche.com/2019/05/27/%E5%85%8D%E8%B4%B9logo%E5%88%9B%E5%BB%BA%E5%99%A8launchaco.com/"/>
    <id>http://www.cmlanche.com/2019/05/27/免费logo创建器launchaco.com/</id>
    <published>2019-05-27T04:36:00.000Z</published>
    <updated>2019-05-27T08:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现一个超级好用，并且免费的logo创建器，<a href="https://www.launchaco.com/" target="_blank" rel="noopener">launchaco.com</a>，之前用过<a href="https://shapefactory.co/" target="_blank" rel="noopener">shapefactory.co</a>，也很好用，但是贵的令人发指，一个做好的logo，需要44美金。而今天发现了<code>launchaco.com</code>，感觉发现了一块宝藏，忍不住想分享。好了，现在来复盘一下整个使用流程。</p><a id="more"></a><p>以我最近正在开发的产品：<strong>找主机 zhaozhuji.info为例</strong></p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>打开<a href="https://www.launchaco.com" target="_blank" rel="noopener">launchaco.com</a>官网，选择<code>logo</code>菜单，点击<code>Create Your Logo for Free</code></p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-082526.png?x-oss-process=style/logomark" alt="image-20190527125730237"></p><h3 id="产品取名字"><a href="#产品取名字" class="headerlink" title="产品取名字"></a>产品取名字</h3><p>注意只支持英文字母，不支持中文，这是唯一的瑕疵。而本身这个产品是建立在人工智能上的，中文不仅字体不支持，也不支持含义联想。</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-045829.png?x-oss-process=style/logomark" alt="image-20190527125828249"></p><h3 id="选字体"><a href="#选字体" class="headerlink" title="选字体"></a>选字体</h3><p>没三种选一种字体，会让你选择四五次，它是期望发现你的字体爱好！</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-045902.png?x-oss-process=style/logomark" alt="image-20190527125859614"></p><h3 id="选择主题色"><a href="#选择主题色" class="headerlink" title="选择主题色"></a>选择主题色</h3><p>下图中列出了6中不同的主题色，每一种都代表不同的含义，并且明确标出了，请注意看图的下面。</p><p>这里我选择第一种，<code>Friendly, Loyal, &amp; Strong</code>，代表着友好、尊贵、强大。</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-050143.png?x-oss-process=style/logomark" alt="image-20190527130141993"></p><p>每种主题色都给你配置好了3种色调，并且标明了适用的含义，是不是很方便啦！</p><p>这里我们选择第三种：<code>Peaceful, Limitless, Tranquil, &amp; Friendly</code></p><h3 id="选择logo"><a href="#选择logo" class="headerlink" title="选择logo"></a>选择logo</h3><p>选择3个你喜欢的logo！</p><p>说真的，这个网站的logo真的超级棒，每个我都很喜欢！</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-050610.gif?x-oss-process=style/logomark" alt="kkkk"></p><h3 id="选择搭配"><a href="#选择搭配" class="headerlink" title="选择搭配"></a>选择搭配</h3><p>最后，系统会根据你的选择，给出一系列智能搭配。</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-050927.png?x-oss-process=style/logomark" alt="image-20190527130926493"></p><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>搭配中，随便选一个，然后编辑，然后点击右上角保存！</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-051701.png?x-oss-process=style/logomark" alt="image-20190527131700176"></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-051732.png?x-oss-process=style/logomark" alt="image-20190527131731317"></p><p>右上角箭头下载后，你会得到png和svg很多资源，想要的都有了，如下图：</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-052442.png?x-oss-process=style/logomark" alt="image-20190527131839225"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有没有感觉很方便？关键是免费啊，基本类似的logo maker都收费，难得发现个免费的。后续我会继续发布有助于独立开发者产品开发的工具，关注我公众号及时提醒。</p><p><img src="https://zhaozhuji1.oss-cn-beijing.aliyuncs.com/zhaozhuji/2019-05-27-081921.jpg?x-oss-process=style/logomark" alt="扫码_搜索联合传播样式-微信标准绿版"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天发现一个超级好用，并且免费的logo创建器，&lt;a href=&quot;https://www.launchaco.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;launchaco.com&lt;/a&gt;，之前用过&lt;a href=&quot;https://shapefactory.co/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shapefactory.co&lt;/a&gt;，也很好用，但是贵的令人发指，一个做好的logo，需要44美金。而今天发现了&lt;code&gt;launchaco.com&lt;/code&gt;，感觉发现了一块宝藏，忍不住想分享。好了，现在来复盘一下整个使用流程。&lt;/p&gt;
    
    </summary>
    
      <category term="独立开发者必备产品帮助工具" scheme="http://www.cmlanche.com/categories/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87%E4%BA%A7%E5%93%81%E5%B8%AE%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
      <category term="logo创建器" scheme="http://www.cmlanche.com/tags/logo%E5%88%9B%E5%BB%BA%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>独立开发者的觉悟</title>
    <link href="http://www.cmlanche.com/2019/05/20/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E4%BB%98%E5%87%BA%E6%88%90%E5%80%8D%E5%8A%AA%E5%8A%9B%E6%89%8D%E8%83%BD%E6%88%90%E5%8A%9F%E7%9A%84%E8%A7%89%E6%82%9F/"/>
    <id>http://www.cmlanche.com/2019/05/20/独立开发者必须要有付出成倍努力才能成功的觉悟/</id>
    <published>2019-05-20T04:44:55.000Z</published>
    <updated>2019-05-20T05:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/gko5e.png" alt="image-20190520130055901"></p><p>经常会做梦，我能躺着挣钱吗？</p><p>作为一穷二白的白丁来讲，这只能做梦了。</p><p>做任何一个产品，都需要花心血去维护运营的。</p><p>不管这个产品是需要怎样的劳动，是轻工具型，还是重内容型，都需要长时间的专注努力，才可能达到你想要的成功。</p><a id="more"></a><p>如果你发现你的产品更新迭代速度很慢，每次更新都要耗费很大的精力，那么请改进迭代流程，用技术手段提高更新效率。</p><p>如果你发现你的产品的访客如流水般，来也快去也快，那就请把产品做得更好，增强用户粘性，让用户一看到你的产品，就欢喜的不得了。小水管一般的流量，用竹篮子如何能装得下？请记住，这样的产品再好的推广也无济于事！</p><p>当然这是目前我出现的问题，所以我才得以轻松说出口，我也会努力做到这两条。</p><p>独立开发者应该要有觉悟，不管产品简单还是复杂，它就像你的孩子，必须得用心呵护和照料，必须的付出成倍的努力才能茁壮成长！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/gko5e.png&quot; alt=&quot;image-20190520130055901&quot;&gt;&lt;/p&gt;
&lt;p&gt;经常会做梦，我能躺着挣钱吗？&lt;/p&gt;
&lt;p&gt;作为一穷二白的白丁来讲，这只能做梦了。&lt;/p&gt;
&lt;p&gt;做任何一个产品，都需要花心血去维护运营的。&lt;/p&gt;
&lt;p&gt;不管这个产品是需要怎样的劳动，是轻工具型，还是重内容型，都需要长时间的专注努力，才可能达到你想要的成功。&lt;/p&gt;
    
    </summary>
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/categories/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
      <category term="觉悟" scheme="http://www.cmlanche.com/tags/%E8%A7%89%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>购买阿里云遇到Permission denied的问题</title>
    <link href="http://www.cmlanche.com/2019/05/15/%E8%B4%AD%E4%B9%B0%E9%98%BF%E9%87%8C%E4%BA%91%E9%81%87%E5%88%B0Permission-denied%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://www.cmlanche.com/2019/05/15/购买阿里云遇到Permission-denied的问题/</id>
    <published>2019-05-15T13:24:11.000Z</published>
    <updated>2019-05-15T13:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近我的新项目友链联盟<a href="https://youlianplus.com" target="_blank" rel="noopener">youlianplus.com</a>项目即将完成，准备拿到阿里云试试，在阿里云华北3购买了一台迷你服务器，1核1g40g硬盘，打算测试一下。</p><p>买了之后，准备用ssh登录进去，结果出现了个<code>permission denied</code>权限被拒绝的问题，详情如下：</p><a id="more"></a><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chengmingdeMacBook-Pro:blog cmlanche$ ssh root@47.92.24.241</span><br><span class="line">The authenticity of host '47.92.24.241 (47.92.24.241)' can't be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:PYBgUIuFIYcBUCzUGG0qLJDGH2At/dQ+zk+Q9tyX7+E.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added '47.92.24.241' (ECDSA) to the list of known hosts.</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">chengmingdeMacBook-Pro:blog cmlanche$ ssh root@47.92.24.241</span><br><span class="line">Permission denied (publickey).</span><br><span class="line">chengmingdeMacBook-Pro:blog cmlanche$ ssh root@47.92.24.241</span><br><span class="line">Permission denied (publickey).</span><br></pre></td></tr></table></figure><p>意思是说，无法用publickey来登录服务器，那问题肯定出在服务器那边的配置上了，百度找了个解决办法，有效！<a href="https://blog.csdn.net/wtopps/article/details/79449920" target="_blank" rel="noopener">https://blog.csdn.net/wtopps/article/details/79449920</a></p><p>幸好阿里云控制台界面有一个远程连接的控制，通过这个入口进去，可以直接登录。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/1n9wu.png" alt="image-20190515213018736"></p><p>进去后，注意要保存好连接码，这个码只会出现一次！就保存在你电脑中就好了。</p><p>关键步骤：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>修改PasswordAuthentication的值为yes，注意把签名的#去掉</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure><p>上文连接说要重启httpd服务，其实没啥作用，咱们来硬的，直接重启服务器就好了！</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/pbyme.png" alt="image-20190515213333642"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我的新项目友链联盟&lt;a href=&quot;https://youlianplus.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;youlianplus.com&lt;/a&gt;项目即将完成，准备拿到阿里云试试，在阿里云华北3购买了一台迷你服务器，1核1g40g硬盘，打算测试一下。&lt;/p&gt;
&lt;p&gt;买了之后，准备用ssh登录进去，结果出现了个&lt;code&gt;permission denied&lt;/code&gt;权限被拒绝的问题，详情如下：&lt;/p&gt;
    
    </summary>
    
      <category term="阿里云" scheme="http://www.cmlanche.com/categories/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
    
      <category term="阿里云" scheme="http://www.cmlanche.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>springboot项目部署到ubuntu18.04的过程，http跳转https，使用acme.sh安装证书</title>
    <link href="http://www.cmlanche.com/2019/05/14/springboot-ubuntu-https/"/>
    <id>http://www.cmlanche.com/2019/05/14/springboot-ubuntu-https/</id>
    <published>2019-05-14T10:33:53.000Z</published>
    <updated>2019-05-14T11:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发的友链联盟项目即将”竣工”，准备拿到公有云Ubuntu是测试下，想要达到的理想状态有如下几点：</p><ol><li>端口保持9090，发布spring boot的jar包，后台运行</li><li>nginx部署，强制https访问应用</li><li>使用<a href="https://github.com/Neilpang/acme.sh" target="_blank" rel="noopener">acme.sh</a>来生成、安装ssl证书</li><li>开启防火墙，打开80、443端口，关闭9090端口(避免直接访问9090打开应用)</li></ol><a id="more"></a><p>目前已经完成上面的要求，可以尝试访问<a href="http://sitefriendlinks.com" target="_blank" rel="noopener">http://sitefriendlinks.com</a>、<a href="http://sitefriendlinks.com:9090" target="_blank" rel="noopener">http://sitefriendlinks.com:9090</a>，前者会强制跳转到<a href="https://sitefriendlinks.com" target="_blank" rel="noopener">https://sitefriendlinks.com</a>，后者无法打开。</p><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol><li><p>nginx</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install nginx</span><br></pre></td></tr></table></figure><p>安装后自动就启动了，你可以用如下命令进行开启和关闭：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx stop</span><br><span class="line">service nginx start</span><br><span class="line">service nginx restart # 重启</span><br></pre></td></tr></table></figure></li><li><p>mysql</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install mysql-server</span><br></pre></td></tr></table></figure><p>详情请看：<a href="https://www.jianshu.com/p/3821c2603b92" target="_blank" rel="noopener">https://www.jianshu.com/p/3821c2603b92</a></p><p>需要注意修改root密码：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show databases；</span><br><span class="line"> </span><br><span class="line">use mysql;</span><br><span class="line">  </span><br><span class="line">update user set authentication_string=PASSWORD("yourpassword") where user='root';</span><br><span class="line">  </span><br><span class="line">update user set plugin="mysql_native_password";</span><br><span class="line">  </span><br><span class="line">flush privileges;</span><br><span class="line">  </span><br><span class="line">quit;</span><br></pre></td></tr></table></figure></li><li><p>java 8</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install openjdk-8-jre-headless</span><br></pre></td></tr></table></figure><p><a href="[https://www.centos.bz/2018/06/%E5%9C%A8ubuntu-18-04%E4%B8%8A%E4%BD%BF%E7%94%A8apt%E5%AE%89%E8%A3%85java/](https://www.centos.bz/2018/06/在ubuntu-18-04上使用apt安装java/">参考链接</a>)</p></li></ol><h3 id="部署nginx"><a href="#部署nginx" class="headerlink" title="部署nginx"></a>部署nginx</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  sitefriendlinks.com;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">443</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  sitefriendlinks.com;</span><br><span class="line">        <span class="attribute">ssl</span>          <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/nginx/ssl/fullchain.cer;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/nginx/ssl/sitefriendlinks.com.key;</span><br><span class="line">        <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span>   <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span>              http://localhost:9090/;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>        Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>        X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>        X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>        X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>        X-Forwarded-Port <span class="variable">$server_port</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用acem-sh安装证书"><a href="#使用acem-sh安装证书" class="headerlink" title="使用acem.sh安装证书"></a>使用acem.sh安装证书</h3><p>参考文档：<a href="https://github.com/Neilpang/acme.sh/wiki/说明" target="_blank" rel="noopener">https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E</a></p><p>关键步骤：</p><ol><li>创建别名</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias acme.sh=~/.acme.sh/acme.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>生成证书</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh --issue  -d mydomain.com   --nginx</span><br></pre></td></tr></table></figure><ol start="3"><li>安装证书</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh  --installcert  -d  &lt;domain&gt;.com   \</span><br><span class="line">        --key-file   /etc/nginx/ssl/&lt;domain&gt;.key \</span><br><span class="line">        --fullchain-file /etc/nginx/ssl/fullchain.cer \</span><br><span class="line">        --reloadcmd  "service nginx force-reload"</span><br></pre></td></tr></table></figure><p><strong>注意，你需要手动创建/etc/nginx/ssl目录，不如上面的安装命令会报路径错误</strong></p><p>此时，你已经能正常用https打开你的网站了</p><h3 id="打开防火墙"><a href="#打开防火墙" class="headerlink" title="打开防火墙"></a>打开防火墙</h3><p>Ubuntu的防火墙命令是ufw，参考：<a href="https://www.cnblogs.com/yuanlipu/p/7103740.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanlipu/p/7103740.html</a></p><p>先查询下防火墙是否打开：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure><p>如果没打开，则开启防火墙</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw enable</span><br></pre></td></tr></table></figure><p>默认情况下，防火墙是会把所有端口都关闭的，不允许外界访问，但是我们要做三件事：开启80、443端口，关闭9090端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 80</span><br><span class="line">sudo ufw allow 443</span><br><span class="line">sudo ufw deny 9090</span><br></pre></td></tr></table></figure><p>此时，咱们的服务器会变的非常安全，注意哦，因为没打开3306端口，所以你的数据库是无法远程访问的，如需要则打开3306端口即可。</p><h3 id="后台运行spring-boot工程"><a href="#后台运行spring-boot工程" class="headerlink" title="后台运行spring boot工程"></a>后台运行spring boot工程</h3><p>把打包好的jar包发到服务器（通常用scp命令即可），然后执行如下命令即可后台启动：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar sitefriendlinks.jar &gt;&gt; ./output.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><hr><p>ok，部署完成！</p><p>by <a href="https://cmlanche.com" target="_blank" rel="noopener">cmlanche.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开发的友链联盟项目即将”竣工”，准备拿到公有云Ubuntu是测试下，想要达到的理想状态有如下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;端口保持9090，发布spring boot的jar包，后台运行&lt;/li&gt;
&lt;li&gt;nginx部署，强制https访问应用&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&quot;https://github.com/Neilpang/acme.sh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;acme.sh&lt;/a&gt;来生成、安装ssl证书&lt;/li&gt;
&lt;li&gt;开启防火墙，打开80、443端口，关闭9090端口(避免直接访问9090打开应用)&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="部署" scheme="http://www.cmlanche.com/categories/%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="springboot" scheme="http://www.cmlanche.com/tags/springboot/"/>
    
      <category term="https" scheme="http://www.cmlanche.com/tags/https/"/>
    
      <category term="ssl" scheme="http://www.cmlanche.com/tags/ssl/"/>
    
      <category term="ubuntu" scheme="http://www.cmlanche.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>图文详解如何修改git已提交记录的邮箱？</title>
    <link href="http://www.cmlanche.com/2019/05/13/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9git%E5%B7%B2%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E7%9A%84%E9%82%AE%E7%AE%B1%EF%BC%9F/"/>
    <id>http://www.cmlanche.com/2019/05/13/如何修改git已提交记录的邮箱？/</id>
    <published>2019-05-13T03:26:12.000Z</published>
    <updated>2019-05-13T04:51:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，公司提交的代码必须使用公司邮箱，而你误操作，直接把自己个人邮箱提交上去了，此时你就会遇到这样的需求：如何修改git已提交的邮箱？</p><p>而这个需求对于新手来说，往往要花费半天的时间才能理解修改过程，简直太傻比了，所以我这里做一个详细的文档来帮助自己和你搞清楚这个流程。尤其要理解变基，它不是一个命令执行就完成了，而是一连串命令的组合。</p><a id="more"></a><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i</span><br></pre></td></tr></table></figure><p>执行后，会打开最近一条的提交记录，当然上面的命令可以指定某一条记录，命令是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i &quot;your commit id&quot;</span><br></pre></td></tr></table></figure><p>对于sourcetree用户来说，commit id是SHA-1，可以右键某条提交记录，选择菜单”复制SHA-1到剪贴板”，如下图：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/mfl1f.png" alt="image-20190513113342522"></p><p>变基rebase命令执行完成后，会打印<strong>类似</strong>如下内容：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick bd81df5 更新API</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Rebase abcb9d0..bd81df5 onto abcb9d0 (1 command)</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Commands:</span><br><span class="line"><span class="meta">#</span> p, pick = use commit</span><br><span class="line"><span class="meta">#</span> r, reword = use commit, but edit the commit message</span><br><span class="line"><span class="meta">#</span> e, edit = use commit, but stop for amending</span><br><span class="line"><span class="meta">#</span> s, squash = use commit, but meld into previous commit</span><br><span class="line"><span class="meta">#</span> f, fixup = like "squash", but discard this commit's log message</span><br><span class="line"><span class="meta">#</span> x, exec = run command (the rest of the line) using shell</span><br><span class="line"><span class="meta">#</span> d, drop = remove commit</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> However, if you remove everything, the rebase will be aborted.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Note that empty commits are commented out</span><br></pre></td></tr></table></figure><p>新手往往会一脸懵逼，不止所错，此时是在rebase的过程中，你需要把pick改为edit，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">edit bd81df5 更新API</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Rebase abcb9d0..bd81df5 onto abcb9d0 (1 command)</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Commands:</span><br><span class="line"><span class="meta">#</span> p, pick = use commit</span><br><span class="line"><span class="meta">#</span> r, reword = use commit, but edit the commit message</span><br><span class="line"><span class="meta">#</span> e, edit = use commit, but stop for amending</span><br><span class="line"><span class="meta">#</span> s, squash = use commit, but meld into previous commit</span><br><span class="line"><span class="meta">#</span> f, fixup = like "squash", but discard this commit's log message</span><br><span class="line"><span class="meta">#</span> x, exec = run command (the rest of the line) using shell</span><br><span class="line"><span class="meta">#</span> d, drop = remove commit</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> However, if you remove everything, the rebase will be aborted.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Note that empty commits are commented out</span><br></pre></td></tr></table></figure><p>更改完成后，保存并退出vi编辑器：<code>:wq</code></p><p>然后会打印这样的消息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chengmingdeMacBook-Pro:server cmlanche$ git rebase -i "abcb9d0d1e99cdad25d8d08119e494436b000e59"</span><br><span class="line">Stopped at bd81df5...  更新API</span><br><span class="line">You can amend the commit now, with</span><br><span class="line"></span><br><span class="line">  git commit --amend </span><br><span class="line"></span><br><span class="line">Once you are satisfied with your changes, run</span><br><span class="line"></span><br><span class="line">  git rebase --continue</span><br><span class="line">chengmingdeMacBook-Pro:server cmlanche$</span><br></pre></td></tr></table></figure><p>给大家先科普一下这个<code>amend</code>英文单词，是修改的意思，对我来说好陌生，为啥不用change或者fix之类的。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/qgjur.png" alt="image-20190513114137949"></p><p>上面的信息说了，如果你要amend，也就是要修改这个提交的话，那么用</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>如果你对这次修改满意的话，就用如下命令结束此次变基</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><h3 id="重置账户邮箱信息"><a href="#重置账户邮箱信息" class="headerlink" title="重置账户邮箱信息"></a>重置账户邮箱信息</h3><p>我们当然要修改啦，那么执行如下命令，重置提交的账户信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend --author="cmlanche &lt;1204833748@qq.com&gt;" --no-edit</span><br></pre></td></tr></table></figure><p>同事，要注意你的sourcetree，出现了新情况！</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/8w5dw.png" alt="image-20190513114851415"></p><p>我们可以看到一个新的提交，并且，邮箱账号都经过了修改，如果你去掉<code>--no-edit</code>还可以修改commit message，也就是图中的”更新API”，举栗子吧，我可以继续用amend修改此次变基</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend --author="cmlanche &lt;1204833748@qq.com&gt;"</span><br></pre></td></tr></table></figure><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/5500p.png" alt="image-20190513115132114"></p><p>保存退出vi编辑器，看sourcetree咋样了：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/e0x3u.png" alt="image-20190513115216969"></p><p>真的很完美，接下来就是合并了，退出变基。</p><h3 id="退出变基"><a href="#退出变基" class="headerlink" title="退出变基"></a>退出变基</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure><p>在控制台中打印如上命令退出变基，我们看到退出变基也就是使用最新的修改了，就一条分支了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chengmingdeMacBook-Pro:server cmlanche$ git rebase --continue</span><br><span class="line">Successfully rebased and updated refs/heads/bulma.</span><br></pre></td></tr></table></figure><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/4e46r.png" alt="image-20190513115442779"></p><h3 id="最后总结一下"><a href="#最后总结一下" class="headerlink" title="最后总结一下"></a>最后总结一下</h3><p>变基真的很有用，他不是一条命令搞定的，是一个过程，就像变成中打开了一个输入流，最后用完你得关闭输入流一样。</p><p>通过变基你可以轻松实现提交信息的任意重新修改！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候，公司提交的代码必须使用公司邮箱，而你误操作，直接把自己个人邮箱提交上去了，此时你就会遇到这样的需求：如何修改git已提交的邮箱？&lt;/p&gt;
&lt;p&gt;而这个需求对于新手来说，往往要花费半天的时间才能理解修改过程，简直太傻比了，所以我这里做一个详细的文档来帮助自己和你搞清楚这个流程。尤其要理解变基，它不是一个命令执行就完成了，而是一连串命令的组合。&lt;/p&gt;
    
    </summary>
    
      <category term="日常技术" scheme="http://www.cmlanche.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://www.cmlanche.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>改造思寒的AppCrawler，使其支持Appium最新版本</title>
    <link href="http://www.cmlanche.com/2019/05/08/%E6%94%B9%E9%80%A0%E6%80%9D%E5%AF%92%E7%9A%84AppiumCrawler%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%94%AF%E6%8C%81Appium%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    <id>http://www.cmlanche.com/2019/05/08/改造思寒的AppiumCrawler，使其支持Appium最新版本/</id>
    <published>2019-05-08T03:19:06.000Z</published>
    <updated>2019-05-08T05:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="思绪"><a href="#思绪" class="headerlink" title="思绪"></a>思绪</h3><p>最近完成了自定义Appium的需求，让Appium内置了自动识别权限框并点击的能力，参考我的知乎专栏：<a href="https://zhuanlan.zhihu.com/custom-appium" target="_blank" rel="noopener">自定义Appium之路</a></p><p>但遇到另外一个问题，就是testerhome思寒开发的AppiumCrawler并不支持Appium最新版，也就是当前的1.12版本，只支持到1.8版本，让人很是捉急。</p><p>本来是想基于1.8重新自定义一个appium，但是发现这个appium实在太老了，下载下来编译都有各种问题，况且后续还要自定义appium-android-driver，appium-uiautomator2-driver和appium-uiaumator2-server，工作量至少得3天，太费时间。</p><p>索性，我来替思寒把AppCrawler来升级一下，让它支持最新appium。</p><p>刚开始觉得挺难的，毕竟我对scala只略知一二，编译打包方面还要学，但事后发现，这个工程做的确实不错，升级改造过程比预计的要简单很多，这里要给思寒大佬一个赞👍！</p><a id="more"></a><h3 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h3><h4 id="先看看出了什么问题？"><a href="#先看看出了什么问题？" class="headerlink" title="先看看出了什么问题？"></a>先看看出了什么问题？</h4><p>我开启最新的appium：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appium</span><br></pre></td></tr></table></figure><p>执行appcrawler测试：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar appcrawler-2.1.3.jar -a ApiDemos-debug.apk</span><br></pre></td></tr></table></figure><p>执行过程中在appium和appcrawler两端都报错：</p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">[HTTP] &lt;-- GET /wd/hub/session/efdf97d8-cf46-<span class="number">4</span>ffb-b2d4-<span class="number">7</span>d8feb931cee/window/rect <span class="number">200</span> <span class="number">7</span> ms - <span class="number">50</span></span><br><span class="line">[HTTP] </span><br><span class="line">[HTTP] --&gt; POST /wd/hub/session/efdf97d8-cf46-<span class="number">4</span>ffb-b2d4-<span class="number">7</span>d8feb931cee/execute/sync</span><br><span class="line">[HTTP] &#123;<span class="string">"script"</span>:<span class="string">"var source = document.documentElement.outerHTML; \nif (!source) &#123; source = new XMLSerializer().serializeToString(document); &#125;\nreturn source;"</span>,<span class="string">"args"</span>:[]&#125;</span><br><span class="line">[debug] [W3C (efdf97d8)] Calling AppiumDriver<span class="variable">.execute</span>() <span class="keyword">with</span> args: [<span class="string">"var source = document.documentElement.outerHTML; \nif (!source) &#123; source = new XMLSerializer().serializeToString(document); &#125;\nreturn source;"</span>,[],<span class="string">"efdf97d8-cf46-4ffb-b2d4-7d8feb931cee"</span>]</span><br><span class="line">[debug] [W3C (efdf97d8)] Encountered internal error running command: NotImplementedError: Method is <span class="keyword">not</span> implemented</span><br><span class="line">[debug] [W3C (efdf97d8)]     at AndroidDriver<span class="variable">.extensions</span><span class="variable">.execute</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-android-driver/lib/commands/execute<span class="variable">.js</span>:<span class="number">12</span>:<span class="number">9</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at curCommandCancellable<span class="variable">._bluebird</span><span class="variable">.default</span><span class="variable">.resolve</span><span class="variable">.then</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/lib/basedriver/driver<span class="variable">.js</span>:<span class="number">291</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at tryCatcher (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/util<span class="variable">.js</span>:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseFromHandler</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">510</span>:<span class="number">31</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseAt</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">584</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseAtPostResolution</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">248</span>:<span class="number">10</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Async<span class="variable">._drainQueue</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">128</span>:<span class="number">12</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Async<span class="variable">._drainQueues</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Immediate<span class="variable">.Async</span><span class="variable">.drainQueues</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at runCallback (timers<span class="variable">.js</span>:<span class="number">705</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at tryOnImmediate (timers<span class="variable">.js</span>:<span class="number">676</span>:<span class="number">5</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at processImmediate (timers<span class="variable">.js</span>:<span class="number">658</span>:<span class="number">5</span>)</span><br><span class="line">[HTTP] &lt;-- POST /wd/hub/session/efdf97d8-cf46-<span class="number">4</span>ffb-b2d4-<span class="number">7</span>d8feb931cee/execute/sync <span class="number">405</span> <span class="number">11</span> ms - <span class="number">1600</span></span><br><span class="line">[HTTP] </span><br><span class="line">[HTTP] --&gt; POST /wd/hub/session/efdf97d8-cf46-<span class="number">4</span>ffb-b2d4-<span class="number">7</span>d8feb931cee/execute/sync</span><br><span class="line">[HTTP] &#123;<span class="string">"script"</span>:<span class="string">"var source = document.documentElement.outerHTML; \nif (!source) &#123; source = new XMLSerializer().serializeToString(document); &#125;\nreturn source;"</span>,<span class="string">"args"</span>:[]&#125;</span><br><span class="line">[debug] [W3C (efdf97d8)] Calling AppiumDriver<span class="variable">.execute</span>() <span class="keyword">with</span> args: [<span class="string">"var source = document.documentElement.outerHTML; \nif (!source) &#123; source = new XMLSerializer().serializeToString(document); &#125;\nreturn source;"</span>,[],<span class="string">"efdf97d8-cf46-4ffb-b2d4-7d8feb931cee"</span>]</span><br><span class="line">[debug] [W3C (efdf97d8)] Encountered internal error running command: NotImplementedError: Method is <span class="keyword">not</span> implemented</span><br><span class="line">[debug] [W3C (efdf97d8)]     at AndroidDriver<span class="variable">.extensions</span><span class="variable">.execute</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-android-driver/lib/commands/execute<span class="variable">.js</span>:<span class="number">12</span>:<span class="number">9</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at curCommandCancellable<span class="variable">._bluebird</span><span class="variable">.default</span><span class="variable">.resolve</span><span class="variable">.then</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/lib/basedriver/driver<span class="variable">.js</span>:<span class="number">291</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at tryCatcher (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/util<span class="variable">.js</span>:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseFromHandler</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">510</span>:<span class="number">31</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseAt</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">584</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseAtPostResolution</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">248</span>:<span class="number">10</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Async<span class="variable">._drainQueue</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">128</span>:<span class="number">12</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Async<span class="variable">._drainQueues</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Immediate<span class="variable">.Async</span><span class="variable">.drainQueues</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at runCallback (timers<span class="variable">.js</span>:<span class="number">705</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at tryOnImmediate (timers<span class="variable">.js</span>:<span class="number">676</span>:<span class="number">5</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at processImmediate (timers<span class="variable">.js</span>:<span class="number">658</span>:<span class="number">5</span>)</span><br><span class="line">[HTTP] &lt;-- POST /wd/hub/session/efdf97d8-cf46-<span class="number">4</span>ffb-b2d4-<span class="number">7</span>d8feb931cee/execute/sync <span class="number">405</span> <span class="number">4</span> ms - <span class="number">1600</span></span><br><span class="line">[HTTP] </span><br><span class="line">[HTTP] --&gt; POST /wd/hub/session/efdf97d8-cf46-<span class="number">4</span>ffb-b2d4-<span class="number">7</span>d8feb931cee/execute/sync</span><br><span class="line">[HTTP] &#123;<span class="string">"script"</span>:<span class="string">"var source = document.documentElement.outerHTML; \nif (!source) &#123; source = new XMLSerializer().serializeToString(document); &#125;\nreturn source;"</span>,<span class="string">"args"</span>:[]&#125;</span><br><span class="line">[debug] [W3C (efdf97d8)] Calling AppiumDriver<span class="variable">.execute</span>() <span class="keyword">with</span> args: [<span class="string">"var source = document.documentElement.outerHTML; \nif (!source) &#123; source = new XMLSerializer().serializeToString(document); &#125;\nreturn source;"</span>,[],<span class="string">"efdf97d8-cf46-4ffb-b2d4-7d8feb931cee"</span>]</span><br><span class="line">[debug] [W3C (efdf97d8)] Encountered internal error running command: NotImplementedError: Method is <span class="keyword">not</span> implemented</span><br><span class="line">[debug] [W3C (efdf97d8)]     at AndroidDriver<span class="variable">.extensions</span><span class="variable">.execute</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-android-driver/lib/commands/execute<span class="variable">.js</span>:<span class="number">12</span>:<span class="number">9</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at curCommandCancellable<span class="variable">._bluebird</span><span class="variable">.default</span><span class="variable">.resolve</span><span class="variable">.then</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/lib/basedriver/driver<span class="variable">.js</span>:<span class="number">291</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at tryCatcher (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/util<span class="variable">.js</span>:<span class="number">26</span>:<span class="number">23</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseFromHandler</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">510</span>:<span class="number">31</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseAt</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">584</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Promise<span class="variable">._settlePromiseAtPostResolution</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/promise<span class="variable">.js</span>:<span class="number">248</span>:<span class="number">10</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Async<span class="variable">._drainQueue</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">128</span>:<span class="number">12</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Async<span class="variable">._drainQueues</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">133</span>:<span class="number">10</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at Immediate<span class="variable">.Async</span><span class="variable">.drainQueues</span> (/usr/<span class="keyword">local</span>/lib/node_modules/appium/node_modules/appium-base-driver/node_modules/bluebird/js/main/async<span class="variable">.js</span>:<span class="number">15</span>:<span class="number">14</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at runCallback (timers<span class="variable">.js</span>:<span class="number">705</span>:<span class="number">18</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at tryOnImmediate (timers<span class="variable">.js</span>:<span class="number">676</span>:<span class="number">5</span>)</span><br><span class="line">[debug] [W3C (efdf97d8)]     at processImmediate (timers<span class="variable">.js</span>:<span class="number">658</span>:<span class="number">5</span>)</span><br><span class="line">[HTTP] &lt;-- POST /wd/hub/session/efdf97d8-cf46-<span class="number">4</span>ffb-b2d4-<span class="number">7</span>d8feb931cee/execute/sync <span class="number">405</span> <span class="number">9</span> ms - <span class="number">1600</span></span><br><span class="line">[HTTP]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> WARN [AppiumClient.$anonfun$getPageSource$<span class="number">1.340</span>] get page source error</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> WARN [Crawler.refreshPage.562] page source get fail, go back</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.setElementAction.660] set action to back</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.runStartupScript.236] first refresh</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.doElementAction.976] current element = _startupActions-Start-<span class="number">0</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.doElementAction.977] current index = <span class="number">0</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.doElementAction.978] current action = </span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.doElementAction.979] current url = </span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.doElementAction.980] current xpath = startupActions-Start-<span class="number">0</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.doElementAction.981] current tag path = _startupActions-Start-<span class="number">0</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.doElementAction.982] current file name = _</span><br><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">34</span>:<span class="number">01</span> INFO [Crawler.doElementAction.983] current uri = startupActions-Start-<span class="number">0</span>startupActions</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.util.NoSuchElementException: last of empty ListBuffer</span><br><span class="line">at scala.collection.mutable.ListBuffer.last(ListBuffer.scala:<span class="number">401</span>)</span><br><span class="line">at com.testerhome.appcrawler.DataRecord.last(DataRecord.scala:<span class="number">40</span>)</span><br><span class="line">at com.testerhome.appcrawler.Crawler.doElementAction(Crawler.scala:<span class="number">985</span>)</span><br><span class="line">at com.testerhome.appcrawler.Crawler.runStartupScript(Crawler.scala:<span class="number">238</span>)</span><br><span class="line">at com.testerhome.appcrawler.Crawler.start(Crawler.scala:<span class="number">152</span>)</span><br><span class="line">at com.testerhome.appcrawler.AppCrawler$.startCrawl(AppCrawler.scala:<span class="number">344</span>)</span><br><span class="line">at com.testerhome.appcrawler.AppCrawler$.parseParams(AppCrawler.scala:<span class="number">312</span>)</span><br><span class="line">at com.testerhome.appcrawler.AppCrawler$.main(AppCrawler.scala:<span class="number">92</span>)</span><br><span class="line">at com.testerhome.appcrawler.AppCrawler.main(AppCrawler.scala)</span><br></pre></td></tr></table></figure><h4 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h4><p>我们看到Appcrawler中报了个<code>get page source error</code>，我们追查appcrawler的代码发现是在这里报错的：</p><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPageSource</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    currentPageSource=<span class="literal">null</span></span><br><span class="line">    currentPageDom=<span class="literal">null</span></span><br><span class="line">    log.info(<span class="string">"start to get page source from appium"</span>)</span><br><span class="line">    <span class="comment">//获取页面结构, 最多重试3次</span></span><br><span class="line">    <span class="number">1</span> to <span class="number">3</span> foreach (i =&gt; &#123;</span><br><span class="line">      asyncTask(<span class="number">20</span>)(driver.getPageSource) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(v) =&gt; &#123;</span><br><span class="line">          log.trace(<span class="string">"get page source success"</span>)</span><br><span class="line">          <span class="comment">//todo: wda返回的不是标准的xml</span></span><br><span class="line">          <span class="keyword">val</span> xmlStr=v <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> json <span class="keyword">if</span> json.trim.charAt(<span class="number">0</span>)=='&#123;' =&gt; &#123;</span><br><span class="line">              log.info(<span class="string">"json format maybe from wda"</span>)</span><br><span class="line">              <span class="type">DataObject</span>.fromJson[<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>]](v).getOrElse(<span class="string">"value"</span>, <span class="string">""</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> xml <span class="keyword">if</span> xml.trim.charAt(<span class="number">0</span>)=='&lt;' =&gt;&#123;</span><br><span class="line">              log.info(<span class="string">"xml format "</span>)</span><br><span class="line">              xml</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="type">Try</span>(<span class="type">XPathUtil</span>.toDocument(xmlStr)) <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Success</span>(v) =&gt; &#123;</span><br><span class="line">              currentPageDom = v</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; &#123;</span><br><span class="line">              log.warn(<span class="string">"convert to xml fail"</span>)</span><br><span class="line">              log.warn(xmlStr)</span><br><span class="line">              currentPageDom=<span class="literal">null</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          currentPageSource = <span class="type">XPathUtil</span>.toPrettyXML(xmlStr)</span><br><span class="line">          <span class="keyword">return</span> currentPageSource</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; &#123;</span><br><span class="line">          log.warn(<span class="string">"get page source error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    currentPageSource</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们看appium的源码，发现在appcrawler给我们的appium传递了一段js代码来获取控件树</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"script"</span>:<span class="string">"var source = document.documentElement.outerHTML; \nif (!source) &#123; source = new XMLSerializer().serializeToString(document); &#125;\nreturn source;"</span>,<span class="attr">"args"</span>:[]&#125;</span><br></pre></td></tr></table></figure><p>然而，我们的appium代码对get page source这个功能接口做了限制，源码在<code>appium-android-driver</code>中的lib/execute.js中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">extensions.execute = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span> (<span class="params">script, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (script.match(<span class="regexp">/^mobile:/</span>)) &#123;</span><br><span class="line">    script = script.replace(<span class="regexp">/^mobile:/</span>, <span class="string">''</span>).trim();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">this</span>.executeMobile(script, _.isArray(args) ? args[<span class="number">0</span>] : args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> errors.NotImplementedError();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里抛出异常了，说明可能是接口变动了，那么我这里有个大胆猜想，appcrawler所使用的java-client过老。</p><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p>ok，立马开始行动，替换上最新的java-client，也就是7.0，同时我们使用最新的appcrawler2.4.0</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.appium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>v7.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时添加对应的仓库：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jitpack.io<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://jitpack.io<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn assembly:assembly</span><br></pre></td></tr></table></figure><p>打包完成，会再target目录下生成一个完整依赖的jar包：<code>appcrawler-2.4.0-jar-with-dependencies.jar</code></p><p>重新执行，你会发现美妙的事情发生，最新appium完美支持！</p><h4 id="提出质疑"><a href="#提出质疑" class="headerlink" title="提出质疑"></a>提出质疑</h4><p>上面的完美支持，是不是因为我更新了最新版本2.4.0，而不是使用的最开始的2.1.3版本呢？</p><p>有可能！！！</p><p>撤销修改，直接打包2.4.0，执行测试看是否正常。</p><p>结果就是：最开始的get page source问题没了，但出现另外一个问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">05</span>-<span class="number">08</span> <span class="number">11</span>:<span class="number">55</span>:<span class="number">46</span> INFO [AppiumClient.30.initLog] already exist</span><br><span class="line">Exception in thread <span class="string">"main"</span> scala.MatchError: [app, appium, deviceName, dontStopAppOnReset, fullReset, noReset] (of <span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">Collections</span>$<span class="title">UnmodifiableSet</span>)</span></span><br><span class="line">        at com.testerhome.appcrawler.driver.AppiumClient.appium(AppiumClient.scala:94)</span><br><span class="line">        at com.testerhome.appcrawler.driver.AppiumClient.&lt;init&gt;(AppiumClient.scala:<span class="number">40</span>)</span><br><span class="line">        at com.testerhome.appcrawler.Crawler.setupAppium(Crawler.scala:<span class="number">277</span>)</span><br><span class="line">        at com.testerhome.appcrawler.Crawler.restart(Crawler.scala:<span class="number">221</span>)</span><br><span class="line">        at com.testerhome.appcrawler.Crawler.crawl(Crawler.scala:<span class="number">201</span>)</span><br><span class="line">        at com.testerhome.appcrawler.Crawler.start(Crawler.scala:<span class="number">170</span>)</span><br><span class="line">        at com.testerhome.appcrawler.AppCrawler$.startCrawl(AppCrawler.scala:<span class="number">323</span>)</span><br><span class="line">        at com.testerhome.appcrawler.AppCrawler$.parseParams(AppCrawler.scala:<span class="number">291</span>)</span><br><span class="line">        at com.testerhome.appcrawler.AppCrawler$.main(AppCrawler.scala:<span class="number">91</span>)</span><br><span class="line">        at com.testerhome.appcrawler.AppCrawler.main(AppCrawler.scala)</span><br><span class="line">chengmingdeMacBook-Pro:AppCrawler cmlanche$</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[debug] [W3C (dd159942)] Encountered internal error running command: NoSuchDriverError: A session is either terminated or not started</span><br><span class="line">[debug] [W3C (dd159942)]     at asyncHandler (/usr/local/lib/node_modules/appium/node_modules/appium-base-driver/lib/protocol/protocol.js:298:15)</span><br><span class="line">[debug] [W3C (dd159942)]     at asyncHandler (/usr/local/lib/node_modules/appium/node_modules/appium-base-driver/lib/protocol/protocol.js:489:15)</span><br><span class="line">[debug] [W3C (dd159942)]     at Layer.handle [as handle_request] (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/layer.js:95:5)</span><br><span class="line">[debug] [W3C (dd159942)]     at next (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/route.js:137:13)</span><br><span class="line">[debug] [W3C (dd159942)]     at Route.dispatch (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/route.js:112:3)</span><br><span class="line">[debug] [W3C (dd159942)]     at Layer.handle [as handle_request] (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/layer.js:95:5)</span><br><span class="line">[debug] [W3C (dd159942)]     at /usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:281:22</span><br><span class="line">[debug] [W3C (dd159942)]     at param (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:354:14)</span><br><span class="line">[debug] [W3C (dd159942)]     at param (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:365:14)</span><br><span class="line">[debug] [W3C (dd159942)]     at Function.process_params (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:410:3)</span><br><span class="line">[debug] [W3C (dd159942)]     at next (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:275:10)</span><br><span class="line">[debug] [W3C (dd159942)]     at logger (/usr/local/lib/node_modules/appium/node_modules/morgan/index.js:144:5)</span><br><span class="line">[debug] [W3C (dd159942)]     at Layer.handle [as handle_request] (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/layer.js:95:5)</span><br><span class="line">[debug] [W3C (dd159942)]     at trim_prefix (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:317:13)</span><br><span class="line">[debug] [W3C (dd159942)]     at /usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:284:7</span><br><span class="line">[debug] [W3C (dd159942)]     at Function.process_params (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:335:12)</span><br><span class="line">[debug] [W3C (dd159942)]     at next (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:275:10)</span><br><span class="line">[debug] [W3C (dd159942)]     at jsonParser (/usr/local/lib/node_modules/appium/node_modules/body-parser/lib/types/json.js:110:7)</span><br><span class="line">[debug] [W3C (dd159942)]     at Layer.handle [as handle_request] (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/layer.js:95:5)</span><br><span class="line">[debug] [W3C (dd159942)]     at trim_prefix (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:317:13)</span><br><span class="line">[debug] [W3C (dd159942)]     at /usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:284:7</span><br><span class="line">[debug] [W3C (dd159942)]     at Function.process_params (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:335:12)</span><br><span class="line">[debug] [W3C (dd159942)]     at next (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:275:10)</span><br><span class="line">[debug] [W3C (dd159942)]     at Layer.handle [as handle_request] (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/layer.js:91:12)</span><br><span class="line">[debug] [W3C (dd159942)]     at trim_prefix (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:317:13)</span><br><span class="line">[debug] [W3C (dd159942)]     at /usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:284:7</span><br><span class="line">[debug] [W3C (dd159942)]     at Function.process_params (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:335:12)</span><br><span class="line">[debug] [W3C (dd159942)]     at next (/usr/local/lib/node_modules/appium/node_modules/express/lib/router/index.js:275:10)</span><br><span class="line">[HTTP] &lt;-- GET /wd/hub/session/dd159942-ed6d-411c-8dcc-b43d7fc26284/source 404 5 ms - 3173</span><br></pre></td></tr></table></figure><p>还是错的！</p><p>那就用我的最新java-client 7.0吧，重新执行一次完整的测试，发现没有任何问题！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;思绪&quot;&gt;&lt;a href=&quot;#思绪&quot; class=&quot;headerlink&quot; title=&quot;思绪&quot;&gt;&lt;/a&gt;思绪&lt;/h3&gt;&lt;p&gt;最近完成了自定义Appium的需求，让Appium内置了自动识别权限框并点击的能力，参考我的知乎专栏：&lt;a href=&quot;https://zhuanlan.zhihu.com/custom-appium&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自定义Appium之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但遇到另外一个问题，就是testerhome思寒开发的AppiumCrawler并不支持Appium最新版，也就是当前的1.12版本，只支持到1.8版本，让人很是捉急。&lt;/p&gt;
&lt;p&gt;本来是想基于1.8重新自定义一个appium，但是发现这个appium实在太老了，下载下来编译都有各种问题，况且后续还要自定义appium-android-driver，appium-uiautomator2-driver和appium-uiaumator2-server，工作量至少得3天，太费时间。&lt;/p&gt;
&lt;p&gt;索性，我来替思寒把AppCrawler来升级一下，让它支持最新appium。&lt;/p&gt;
&lt;p&gt;刚开始觉得挺难的，毕竟我对scala只略知一二，编译打包方面还要学，但事后发现，这个工程做的确实不错，升级改造过程比预计的要简单很多，这里要给思寒大佬一个赞👍！&lt;/p&gt;
    
    </summary>
    
      <category term="Appium" scheme="http://www.cmlanche.com/categories/Appium/"/>
    
    
      <category term="appium" scheme="http://www.cmlanche.com/tags/appium/"/>
    
      <category term="appiumcrawler" scheme="http://www.cmlanche.com/tags/appiumcrawler/"/>
    
  </entry>
  
  <entry>
    <title>开源项目filepond的独立自由之路：城市套路深</title>
    <link href="http://www.cmlanche.com/2019/04/20/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AEfilepond%E7%9A%84%E7%8B%AC%E7%AB%8B%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF%EF%BC%9A%E5%9F%8E%E5%B8%82%E5%A5%97%E8%B7%AF%E6%B7%B1/"/>
    <id>http://www.cmlanche.com/2019/04/20/开源项目filepond的独立自由之路：城市套路深/</id>
    <published>2019-04-20T01:19:41.000Z</published>
    <updated>2019-05-08T05:01:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信原文更清晰：<a href="https://mp.weixin.qq.com/s/dv39XvvDNlDqvSgrhN2f7A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/dv39XvvDNlDqvSgrhN2f7A</a></p><p>最近一直在做一个有关独立开发者友链联盟的插件项目，在做到上传头像时，满网络找最好的头像上传、剪裁插件，最后终于找到了<a href="https://github.com/pqina/filepond" target="_blank" rel="noopener">filepond</a>，满心欢喜的认为，这么好的东西居然是开源项目，简直牛的不要不要的。</p><a id="more"></a><p>这个filepond到底怎么好呢？给大家看俩图，或许能了解，她如此美丽简洁，真漂亮！</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/yeua9.gif" alt="filepond1"></p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/nuf1l.gif" alt="filepond2"></p><p>看到效果，是不是很激动？是不是特别想要？</p><p>想必肯定是了，我也是啊。</p><p>立马，我就开始准备继承她了。。。</p><p>集成中，才发现，filepond是一个设计也精美的插件，它由主filepond工程和几个不同功能的插件组成，你可以根据实际需求来添加插件，默认主工程可以直接使用，但只有基本的上传功能。插件如下：</p><ul><li><a href="https://github.com/pqina/filepond-plugin-file-encode" target="_blank" rel="noopener">File encode</a></li><li><a href="https://github.com/pqina/filepond-plugin-file-rename" target="_blank" rel="noopener">File rename</a></li><li><a href="https://github.com/pqina/filepond-plugin-file-validate-size" target="_blank" rel="noopener">File size validation</a></li><li><a href="https://github.com/pqina/filepond-plugin-file-validate-type" target="_blank" rel="noopener">File type validation</a></li><li><a href="https://github.com/pqina/filepond-plugin-file-metadata" target="_blank" rel="noopener">File metadata</a></li><li><a href="https://github.com/pqina/filepond-plugin-file-poster" target="_blank" rel="noopener">File poster</a></li><li><a href="https://github.com/pqina/filepond-plugin-image-edit" target="_blank" rel="noopener">Image editor</a></li><li><a href="https://github.com/pqina/filepond-plugin-image-validate-size" target="_blank" rel="noopener">Image size validation</a></li><li><a href="https://github.com/pqina/filepond-plugin-image-preview" target="_blank" rel="noopener">Image preview</a></li><li><a href="https://github.com/pqina/filepond-plugin-image-crop" target="_blank" rel="noopener">Image crop</a></li><li><a href="https://github.com/pqina/filepond-plugin-image-resize" target="_blank" rel="noopener">Image resize</a></li><li><a href="https://github.com/pqina/filepond-plugin-image-transform" target="_blank" rel="noopener">Image transform</a></li><li><a href="https://github.com/pqina/filepond-plugin-image-exif-orientation" target="_blank" rel="noopener">Image EXIF orientation</a></li></ul><p>并且作者pqina还适配了不同的前端框架：</p><ul><li><a href="https://github.com/pqina/react-filepond" target="_blank" rel="noopener">React</a></li><li><a href="https://github.com/pqina/vue-filepond" target="_blank" rel="noopener">Vue</a></li><li><a href="https://github.com/pqina/jquery-filepond" target="_blank" rel="noopener">jQuery</a></li><li><a href="https://github.com/pqina/ngx-filepond" target="_blank" rel="noopener">Angular</a></li><li><a href="https://github.com/johnnyasantoss/angularjs-filepond" target="_blank" rel="noopener">Angular 1</a></li><li><a href="https://github.com/alexdiliberto/ember-filepond" target="_blank" rel="noopener">Ember</a></li></ul><p>真的可以说是用心良苦啊！不得不佩服。</p><p>说这么多，只是说它有多牛逼，还没说到独立开发者上来，这个也是我集成filepond的图片编辑功能之后才了解到的，也就是上面中第二章图展示的功能。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/xcvfb.png" alt="image-20190420094415203"></p><p>我擦，我好不容易把7个插件的js、css引入进来，结果还有个一Doka的东西！！这是什么鬼啊？？？</p><p>刚开始还以为是另外一个项目没引入，赶紧去filepond的README中找。。。最后找到这样几句话：</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/dv973.png" alt="image-20190420094620708"></p><p>打开Doka一看，原来TM是个收费项目啊，最牛逼最亮点的东西居然收费，我TM。。。。。服了，后来一转想，人家东西做的这么好，独立开发如此不容易，收个费怎么了，想到这，我就特想买了。</p><p>不过，人家价格方案比较贵，最低一年要79美金，而且不适用于saas，所以它这个项目，一开始就把目标人群定位在了企业级的用户上，很明确。</p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/7knhz.png" alt="image-20190420095123231"></p><p>我是买不起你了，要是以后独立开发者友链联盟这个项目能做起来，做大了，我肯定买！</p><p>自此，我是深感套路深啊，但就算套路深，我却很喜欢这种感觉，毕竟人家很挣钱。</p><p>继续了解下背后的作者pqina吧，个人网站是：<a href="https://pqina.nl/" target="_blank" rel="noopener">pqina.nl</a>，个人网站上没有写任何有关自己的事情，基本都是自己的几个关键的独立产品，FilePond、Doka、Flip和Soon，但是公布的推特，当发现你很崇拜一个人的时候，你就特别想了解他的一切，那就fq去推特看看吧。</p><p>推特上显示他来自荷兰(Netherlands)，主要给WordPress、jQuery、React、Angular设计高质量的Web插件，并在推特上发布有趣的web相关的新闻。</p><p><strong>信息就这点，现在来复盘一下filepond的盈利模式。</strong></p><ol><li>创建开源项目filepond，开源绝大部分基础功能</li><li>在更高层次的图片编辑功能上做限制，开发出Doke.js的付费项目</li><li>filepond负责引流，filepond提供了很好的插件模式，虽然你也可能开发出类似的插件，但终究门槛太高，基本上如果你要图片编辑功能，那你是必须购买Doka.js的</li></ol><p>但，就是因为pgina把这块的功能做的足够好，并且市面上并没有比他更好的，所以才有这么大的自信做收费，还不便宜。</p><p><strong>对我们独立开发者的反思：</strong></p><ol><li>有时候我们并不需要做太多产品，做一款产品做到极致那抵得过”千军万马”</li><li>开源基础功能，高纬度功能收费，定价合理，这种盈利模式，独立开发者可以考虑一下</li><li>好的有价值的产品，能够做到自我传播，就像filepond一样，让我使劲夸它，要是一个烂东西，看都懒得看。所以独立开发者做的东西，一定要有很高的价值才行，一定不要敷衍你的用户！</li></ol><p>还有一点要分享就是关于谷歌搜索引擎，它的目标是让你找到对你最有价值的东西，只要你的东西做的够好，总会把这种价值带给用户，就像我找filepond，所以谷歌SEO不仅仅是字面的意思，还是背后一个价值的意思。</p><p><strong>关注我的订阅号：</strong></p><p><img src="https://cmlanche-1251406926.cos.ap-guangzhou.myqcloud.com/blog/op5uf.jpg" alt="qrcode_for_gh_2af76fcad768_258"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信原文更清晰：&lt;a href=&quot;https://mp.weixin.qq.com/s/dv39XvvDNlDqvSgrhN2f7A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/dv39XvvDNlDqvSgrhN2f7A&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最近一直在做一个有关独立开发者友链联盟的插件项目，在做到上传头像时，满网络找最好的头像上传、剪裁插件，最后终于找到了&lt;a href=&quot;https://github.com/pqina/filepond&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;filepond&lt;/a&gt;，满心欢喜的认为，这么好的东西居然是开源项目，简直牛的不要不要的。&lt;/p&gt;
    
    </summary>
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/categories/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
      <category term="filepond" scheme="http://www.cmlanche.com/tags/filepond/"/>
    
  </entry>
  
  <entry>
    <title>centos7开放端口命令</title>
    <link href="http://www.cmlanche.com/2019/04/19/centos7%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.cmlanche.com/2019/04/19/centos7开放端口命令/</id>
    <published>2019-04-19T09:22:36.000Z</published>
    <updated>2019-05-14T08:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>亲测有效！</p><h3 id="centos查询端口是不是开放的"><a href="#centos查询端口是不是开放的" class="headerlink" title="centos查询端口是不是开放的"></a>centos查询端口是不是开放的</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --query-port=8080/tcp</span><br></pre></td></tr></table></figure><h3 id="添加对外开放端口"><a href="#添加对外开放端口" class="headerlink" title="添加对外开放端口"></a>添加对外开放端口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=8080/tcp</span><br></pre></td></tr></table></figure><h3 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;亲测有效！&lt;/p&gt;
&lt;h3 id=&quot;centos查询端口是不是开放的&quot;&gt;&lt;a href=&quot;#centos查询端口是不是开放的&quot; class=&quot;headerlink&quot; title=&quot;centos查询端口是不是开放的&quot;&gt;&lt;/a&gt;centos查询端口是不是开放的&lt;/h3&gt;&lt;fig
      
    
    </summary>
    
      <category term="日常技术" scheme="http://www.cmlanche.com/categories/%E6%97%A5%E5%B8%B8%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="centos7" scheme="http://www.cmlanche.com/tags/centos7/"/>
    
  </entry>
  
  <entry>
    <title>健康才是福，工作和生活的心态要平衡</title>
    <link href="http://www.cmlanche.com/2019/04/14/%E5%81%A5%E5%BA%B7%E6%89%8D%E6%98%AF%E7%A6%8F%EF%BC%8C%E5%B7%A5%E4%BD%9C%E5%92%8C%E7%94%9F%E6%B4%BB%E7%9A%84%E5%BF%83%E6%80%81%E8%A6%81%E5%B9%B3%E8%A1%A1/"/>
    <id>http://www.cmlanche.com/2019/04/14/健康才是福，工作和生活的心态要平衡/</id>
    <published>2019-04-14T13:02:44.000Z</published>
    <updated>2019-04-15T06:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天一早8点，肾结石突发，疼死我了，急忙跑到医院打针吃药，下午终于有点好转，感谢生命！但是基本上一坐下来就疼，只能站着。</p><a id="more"></a><p>可能很多人都有结石，体验结石带来的痛苦也有不少吧，那种疼痛感，很容易让人产生悲观厌世的感觉，终于不那么疼了，才想到，原来此前的每一刻那坐下来的舒适，都是幸福！</p><p>但是幸福如此在你身边，你却不以为意，感觉有无数的欲望和野心在等着你完成，马云说，能够996是种幸福，我说健康才是福，现在的每一刻每一秒都是幸福，工作是工作，生活是生活，都要有，而且要有滋有味，不要总是忙忙碌碌，不知所终。有野心没问题，但是切忌急躁，慢慢来。</p><p>工作和生活的心态要平衡，其实现在就是幸福，可以想太多，但不可以着急，不要给自己太大的压力。</p><p>鉴于结石的情况，给自己立几个规矩：</p><ol><li>晚上11点之前睡觉</li><li>少吃豆制品，少吃鸡蛋，多吃蔬菜</li><li>多喝水，多运动</li></ol><p>此文，你我诸君共勉！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天一早8点，肾结石突发，疼死我了，急忙跑到医院打针吃药，下午终于有点好转，感谢生命！但是基本上一坐下来就疼，只能站着。&lt;/p&gt;
    
    </summary>
    
      <category term="独立开发者" scheme="http://www.cmlanche.com/categories/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85/"/>
    
    
      <category term="生活" scheme="http://www.cmlanche.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
