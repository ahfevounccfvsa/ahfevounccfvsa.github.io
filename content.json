{"meta":{"title":"cmlanche","subtitle":"金鳞岂是池中物","description":null,"author":"cmlanche","url":"http://www.cmlanche.com"},"pages":[{"title":"tags","date":"2017-09-24T10:38:27.000Z","updated":"2017-09-24T10:39:25.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.cmlanche.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2017-09-30T06:23:23.000Z","updated":"2019-02-28T03:06:13.000Z","comments":true,"path":"about/index.html","permalink":"http://www.cmlanche.com/about/index.html","excerpt":"","text":"hello，大家好，我是 cmlanche，网络上但凡是搜到cmlanche都是我，因为只有我才会取这个唯一的id。是采用我的名字拼音缩写cm+lanche（《三傻大闹宝莱坞》中的男主角的名字兰彻的拼音缩写）。 2013届软件工程毕业生，目前供职于北京云测信息技术有限公司，产品开发部，主要研发移动自动化测试技术以及JavaFx客户端界面开发。 工作语言主要是Java, 日常开发技术有Java、JavaScript、JavaFx客户端技术、Android开发以及移动自动化测试技术。业余爱好比较广泛，希望以后能成为一个技能全面，能力超强的全栈开发工程师，后端目前正在学习Spring Boot和Spring Cloud微服务系列，前端变化很大，目前前端js方面有学Vuejs、Angular2，另外我有Html、css、JavaScript的基本功，研读了《head First Html5 &amp; css》，同时曾经也沉浸在Bootstrap、foundation等一批优秀的前端css框架中。 另外我建立了一个JavaFx开发社群，社区活跃，欢迎各位对java客户端技术感兴趣的同学加入：518914410 2018年06月19日上线主机深度评测网hostreport.cn，为大家选择最靠谱的虚拟主机、云服务器、VPS、SSL数字证书，更多优惠互动提醒。 2019年02月20日上线主机排行网HostingRanking.cn，为大家选择最靠谱的虚拟主机、云服务器、VPS、SSL数字证书，更多优惠互动提醒。 2019年2月27日在v2ex上写了篇《程序员的微创业》获得了大量关注，网友请求创立了“独立开发者”微信群，我的微信号是cmlanche，有兴趣的可以加我好友，拉你进群。 做一个产品贵在坚持，不忘初心，方得始终！ 金陵岂是池中物，这是我的座右铭，人活一世，不做点有意义的事情，算是白活。尤其对我们普遍大众程序猿来说，都不想普通，因为大部分人来说都不会像王思聪那样含着金钥匙出生。奋斗这个词很虚幻，怎么有效合理的奋斗才可以不伤身体又能够实现目标才是我们程序猿要想明白的事情。"},{"title":"categories","date":"2017-09-30T06:56:49.000Z","updated":"2017-09-30T06:57:33.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.cmlanche.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"我也来碎碎念 - 主机排行网运营一个月小结","slug":"我也来碎碎念","date":"2019-03-29T03:00:19.000Z","updated":"2019-03-29T05:25:07.000Z","comments":true,"path":"2019/03/29/我也来碎碎念/","link":"","permalink":"http://www.cmlanche.com/2019/03/29/我也来碎碎念/","excerpt":"我也来碎碎念 - 主机排行网运营一个月小结 学习iPic作者Jason每周一的碎碎念，我也来碎碎念了，只有我有新的想法灵感，我就会立马记录下来，不管内容有多少。 今天要总结一下我的产品：主机排行网 HostingRanking.cn","text":"我也来碎碎念 - 主机排行网运营一个月小结 学习iPic作者Jason每周一的碎碎念，我也来碎碎念了，只有我有新的想法灵感，我就会立马记录下来，不管内容有多少。 今天要总结一下我的产品：主机排行网 HostingRanking.cn 盈利模式主机排行网的盈利模式很简单，就是推广返利，做affiliate链接推广，最终目标要把最好的主机带给大家，做好全面评测，不断优化迭代版本。带给大家价值了，我这个产品才有意义。 小结 目前不断更新迭代有17个版本，115个提交记录，7个分支了，主机排行网也在Vultr 日本VPS上稳定运行一个月了。 谁说Vultr VPS的IP总是被封，为啥我就从来没有，你被封肯定是用来搭梯子了吧。 到目前为止预计可营收大概有1100元 阿里云云大使：611元 Vultr VPS有两个推广，50美金 DigitalOcean有1个有效推广，25美金 关于推广目前网站的流量都是自己推一下才有人看，不推就没有，这不是良性的，也比较消耗自己的时间，最好是流量来自自然搜索，这样就比较省事了，关键是流量最大的百度SEO很不好做，百度SEO一向不是很公平，所以我想先做好谷歌和必应的搜索。百度慢慢做好了。 关于本文通常国内独立开发不会写自己产品的盈利模式和收入来源，我这里完全开放出来，不排斥有同行跟我做一样的网站，也欢迎你做，如果你做了，到时候告诉我，我们互加友链，中国市场这么大，不怕再多你一人。😊 独立开发者微信群目前我运营维护一个独立开发者群，里面有月入几万的大神，也有去学习的菜鸟，欢迎加入。加我微信cmlanche，我拉你进去。目前已有327人，快满了，手慢无啊。","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.cmlanche.com/tags/碎碎念/"},{"name":"主机排行网","slug":"主机排行网","permalink":"http://www.cmlanche.com/tags/主机排行网/"}]},{"title":"我的最佳写作方式","slug":"我的最佳写作方式","date":"2019-02-26T02:37:13.000Z","updated":"2019-03-01T00:02:35.000Z","comments":true,"path":"2019/02/26/我的最佳写作方式/","link":"","permalink":"http://www.cmlanche.com/2019/02/26/我的最佳写作方式/","excerpt":"最近喜欢上了写作，喜欢自己写的东西能被别人阅读，赞赏，也希望我写的东西能更有价值，体验也更好。 今天我分享的是我的最佳写作方式。 我的最佳写作方式工具汇总 markdown编辑器 截图工具 gif录制工具 图床工具 Typora QQ / wechat licecap iPic markdown编辑器 · Typora完全免费的markdown编辑器，无与伦比的写作体验，让人爱不释手，具体的特性请移步官网：https://typora.io/ 我最常用的快捷键是Command+/，可以切换源码模式和打字机模式。","text":"最近喜欢上了写作，喜欢自己写的东西能被别人阅读，赞赏，也希望我写的东西能更有价值，体验也更好。 今天我分享的是我的最佳写作方式。 我的最佳写作方式工具汇总 markdown编辑器 截图工具 gif录制工具 图床工具 Typora QQ / wechat licecap iPic markdown编辑器 · Typora完全免费的markdown编辑器，无与伦比的写作体验，让人爱不释手，具体的特性请移步官网：https://typora.io/ 我最常用的快捷键是Command+/，可以切换源码模式和打字机模式。 图传工具 · iPic仅仅有好的编辑器还不够，还需要图床工具将你的图片自动上传到云端，最好是能够结合你使用的markdown编辑器一起使用，最好是截图后直接粘贴，然后上传。 那么iPic是首选，因为Typora内置了iPic的功能，如下图： iPic支持很多种图传工具，我现在用的是腾讯COS，这个工具默认是免费的，但是默认只支持免费的新浪微博图传，如果你要使用其他图传就要收费了，年费50元。 iPic的作者是全职独立开发者Jason，已经写了很多类似的mac工具，都很优秀，官网：https://toolinbox.net/ 截图工具 · QQQQ和微信截图应该是大家都在用的，非常方便，截图后可以粘贴到任何地方，QQ还支持视频录制功能。 gif录制工具 · licecap这里我就要介绍强大的LICEcap了，用来做屏幕截图的，录制出来的gif很小，我的所有gif都是通过它来制作的。 详细请移步官网：https://www.cockos.com/licecap/","categories":[],"tags":[{"name":"写作方式","slug":"写作方式","permalink":"http://www.cmlanche.com/tags/写作方式/"}]},{"title":"CSDN、博客园等6大技术博客平台的写作体验测评","slug":"CSDN、博客园等6大技术博客平台的写作体验测评","date":"2019-02-25T07:38:38.000Z","updated":"2019-03-12T12:12:35.000Z","comments":true,"path":"2019/02/25/CSDN、博客园等6大技术博客平台的写作体验测评/","link":"","permalink":"http://www.cmlanche.com/2019/02/25/CSDN、博客园等6大技术博客平台的写作体验测评/","excerpt":"功能对比","text":"功能对比 markdown编辑器写作体验比较 markdown标准语法请参考：CommonMark, 学习指南https://commonmark.org/help/tutorial/，而本文要比较的各家markdown编辑器遵守的协议都不太一样，比如csdn在标准语法上做了更多事情，如图片支持大小和居中设定，这一点虽好，但其他平台不支持，那也导致你的文章不具备通用性。所以我们并不需要独特的支持，都遵守标准语法，文章的移植性就更强。 1. segmentfault.com 体验5星，极好 markdown语法说明：https://segmentfault.com/markdown segmentfault只支持markdonwn编辑器，是因为它是最新的平台，然后面向的用户都是程序员群体，而markdown已经是大家默认的使用的编辑器，这是共识，csdn前几年都不支持markdown，现在都支持了，会用markdown已经是程序员群体最基础的能力，所以它不需要支持富文本编辑器，有点多余。 特点： 界面简洁，没有多余的东西 聚焦当前写作行，实时预览 发布原创可注明版权，同时可以同步到新浪微博，支持定时发布 可以给文章设置预定的标签，创建一个系统不存在的标签要求你的声望值达到1500。这样其实很有好处，可以让segmentfault整个系统共用一套标签体系，可以把相同兴趣的人组织到一块，同时也避免了标签混乱。 2. CSDN 体验5星，极好 csdn的markdown编辑器很强大，支持很全面，图片也支持大小和居中设置。刚打开编辑器的时候，就告诉你所有csdn的增强版markdown语法知识。 markdown增强点有： 新增文章目录语法：@[TOC](文章目录) 图片支持大小和居中设定 全新的界面设计 ，将会带来全新的写作体验； 在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示； 增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示； 全新的 KaTeX数学公式 语法； 增加了支持甘特图的mermaid语法[^1] 功能； 增加了 多屏幕编辑 Markdown文章功能； 增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间； 增加了 检查列表 功能。 3. 开源中国 OSChina.net 体验3星，一般开源中国的markdown编辑器体验很差，做的比较敷衍，我随便找个开源的都能做成这样。 而且markdown也不是默认编辑器，说明也不注重这一块。 4. 博客园 cnblogs.com 体验1星，极差博客园的markdown编辑器就太差了，没有任何写作体验，就是一个输入框，让你把提前写好的markdown文本贴进去了事，也没有预览功能，写了啥也不知道。 可能有很多朋友还不知道怎么启用markdown编辑器呢，在后台页面【选项】-【默认编辑器】-【Markdown】 5. 知乎 无markdown编辑器，富文本编辑器体验5星，极好 知乎面向的客户是全社会各类的人，绝大多数并不是程序员群体，所有知乎是不会支持markdown编辑器的。 虽然这样，知乎还是提供给我们强大的定制的富文本编辑器，主要特性有： 界面简洁 图片支持一次性上传多张 支持文章封面 6. 简书 评价5星，很好简书面向的群体也不只是it技术人员，程序员群体仅仅是很小的一部分，但仍旧支持markdown编辑器，只是不是默认的编辑器而已，富文本的支持也很好，主要有如下特点： 文集形式，不仅仅包含编辑器，一次性打开所有文章，方便你随时切换其他文章进行修改 和知乎一样，一次性可上传多张图片 支持数学公式，并有友好的提示。 常用表达式 常用函数 希腊字母 常用符号 特殊符号 简书切换markdown的方式比较隐蔽，在左下角的设置切换：","categories":[],"tags":[{"name":"评测","slug":"评测","permalink":"http://www.cmlanche.com/tags/评测/"},{"name":"csdn","slug":"csdn","permalink":"http://www.cmlanche.com/tags/csdn/"},{"name":"博客园","slug":"博客园","permalink":"http://www.cmlanche.com/tags/博客园/"}]},{"title":"面试题·HashMap和Hashtable的区别(转载再整理)","slug":"HashMap和Hashtable的区别(转)","date":"2019-02-25T03:26:49.000Z","updated":"2019-02-26T06:41:11.000Z","comments":true,"path":"2019/02/25/HashMap和Hashtable的区别(转)/","link":"","permalink":"http://www.cmlanche.com/2019/02/25/HashMap和Hashtable的区别(转)/","excerpt":"原文链接： Javarevisited 翻译： ImportNew.com - 唐小娟译文链接： http://www.importnew.com/7010.html HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分。Hashtable和HashMap在Java面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何Java面试之前，都不要忘了准备这一题。 这篇文章中，我们不仅将会看到HashMap和Hashtable的区别，还将看到它们之间的相似之处。","text":"原文链接： Javarevisited 翻译： ImportNew.com - 唐小娟译文链接： http://www.importnew.com/7010.html HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分。Hashtable和HashMap在Java面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何Java面试之前，都不要忘了准备这一题。 这篇文章中，我们不仅将会看到HashMap和Hashtable的区别，还将看到它们之间的相似之处。 HashMap和Hashtable的区别HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。 HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 HashMap不能保证随着时间的推移Map中的元素次序是不变的。 要注意的一些重要术语： sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。 Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。 我们能否让HashMap同步？HashMap可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap); 结论Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，Hashtable是java 4时代的过时产物，ConcurrentHashMap是它的替代品。而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。","categories":[],"tags":[{"name":"hashmap","slug":"hashmap","permalink":"http://www.cmlanche.com/tags/hashmap/"},{"name":"hashtable","slug":"hashtable","permalink":"http://www.cmlanche.com/tags/hashtable/"},{"name":"面试题","slug":"面试题","permalink":"http://www.cmlanche.com/tags/面试题/"}]},{"title":"hostingranking.cn·基于ghost的轻量技术架构整理","slug":"hostingranking.cn技术架构","date":"2019-02-24T05:40:05.000Z","updated":"2019-03-13T03:02:53.000Z","comments":true,"path":"2019/02/24/hostingranking.cn技术架构/","link":"","permalink":"http://www.cmlanche.com/2019/02/24/hostingranking.cn技术架构/","excerpt":"本篇纯粹只讲hostingranking.cn网站的技术架构，也就是怎么做到的，达到什么效果。至于它是什么，为什么要做暂且不说，另篇会分享。 技术组成首先hostingranking.cn是基于ghost博客平台而构建的，ghost最强大的部分就是可以最大限度的让你DIY网站，能力特别强。如下是技术组成图： 技术讲解 运行环境 用途 Ghost Nodejs 博客平台，可供主题创作的环境，博客管理，SEO等一系列可插拔的功能 JQuery Javascript 前端js交互 handlebar - 网页模板 spring boot java 提供后端服务，连接第三方服务 typeform 第三方问卷调查服务 mailchimp 第三方邮件服务","text":"本篇纯粹只讲hostingranking.cn网站的技术架构，也就是怎么做到的，达到什么效果。至于它是什么，为什么要做暂且不说，另篇会分享。 技术组成首先hostingranking.cn是基于ghost博客平台而构建的，ghost最强大的部分就是可以最大限度的让你DIY网站，能力特别强。如下是技术组成图： 技术讲解 运行环境 用途 Ghost Nodejs 博客平台，可供主题创作的环境，博客管理，SEO等一系列可插拔的功能 JQuery Javascript 前端js交互 handlebar - 网页模板 spring boot java 提供后端服务，连接第三方服务 typeform 第三方问卷调查服务 mailchimp 第三方邮件服务 主要功能 ghost主题制作，呈现网站基本内容 个性化主机推荐 博客 ghost主题制作ghost主题制作非常简单，只要你会写js+html+css即可制作，另外最好要学会handlebar模板语言，会让你制作主题事半功倍，入门制作教程参考我另一篇文章：https://cmlanche.com/2018/08/26/%E5%88%B6%E4%BD%9Cghost%E4%B8%BB%E9%A2%98/ 个性化主机推荐#####基本流程如下 采用typeform来制作表单 开启typeform的webhook，意思就是当客户提交表单的时候，会往这个webhook url发送一个post请求，来告诉你有用户提交了，以及提交的数据。 spring boot是我们的后端服务，专门用来制作webhook接口的，不要把webhook想的很神圣，没什么难的，webhook接口其实就是一个普通接口，只是它被用来处理webhook发送来的数据罢了。 spring boot收到typeform提交的问卷信息后，去调用mailchimp的api，创建邮件，发送给客户。 活动图如下 我最终通过spring Boot接收webhook传递过来的不同数据，生成不同的推荐结果。 你可以在hostingranking.cn的实现效果，看自己是否能收到邮件，收到的是什么。 typeform强大的问卷调查产品，体验无与伦比，生成的文件简单简洁，完整的api支撑，对刚起步的新手产品免费支持，更重要的是，支持中文！在国内访问畅通无阻！下图是我hostingranking.cn产品涉及到的问卷设计： mailchimp世界上最常用的邮箱市场营销工具，好处如下： 完全的开放，完整的api支持，支持用zapper连接上百款常用产品 中国访问速度还可以，用api调用无碍 诚意满满的新手产品扶助计划，帮助新产品达到足够规模再收费！ 按照上面说的个性化功能，当你提交问卷之后，我的mailchimp后台会看到发送状态，以及打开和点击的状态，如下图： 一点吐槽：看到typeform和mailchimp，我想国外的东西做的真是开放，各种api都支持，反观国内，则各种保护，就比如知乎、博客园、segmentfault等都是不开放api的，这点让我觉得国内还不够开放。 博客博客功能是ghost内置的核心功能，刚刚开发好(2019-03-13)，访问：https://hostingranking.cn/blog 附hostingranking.cn网站托管在Vultr主机上，买的最低配的VPS，每个月5美金 如果你要买它的主机并且你的主要客户在大陆的话，你一定要买日本的主机，不要买美国和新加坡的，因为日本的平均ping值是最低的，大约一百多，新加坡的主机会绕过日本再到中国，慢一些，而美国的大概两三百。","categories":[],"tags":[{"name":"hostingranking.cn","slug":"hostingranking-cn","permalink":"http://www.cmlanche.com/tags/hostingranking-cn/"},{"name":"技术架构","slug":"技术架构","permalink":"http://www.cmlanche.com/tags/技术架构/"}]},{"title":"程序员的微创业","slug":"微创业","date":"2019-02-24T01:00:10.000Z","updated":"2019-03-13T03:08:55.000Z","comments":true,"path":"2019/02/24/微创业/","link":"","permalink":"http://www.cmlanche.com/2019/02/24/微创业/","excerpt":"不知道有没有觉得程序员是吃青春饭的； 有没有发现很多公司的招聘需求上写着35岁以上不要； 有没有发现一转眼都已奔三，却依旧一事无成，无房无车； 怎么办？我想过创业，我也创业过，15年的时候和同学一块做人脸识别，种种原因最后没成功，此前两年的积蓄也清零，创业？人家都说是九死一生，我说就是，在你没有足够人脉钱脉的时候你去创业，无异于以卵击石。 程序员是吃请青春饭的，因为这个行业加班最严重，年轻人不断涌上，没时间谈恋爱，谈了恋爱的不敢结婚，结婚的不敢生孩子，生孩子了也不能自己养，要爸妈带，中国现在社会就是这样，年轻人压力巨大，上有老下有小，奔三的我感觉鸭梨山大。 既然不能创业那就好好工作，把工作的事情做好，我也觉得，但是2018年底都知道大裁员，公司也未必是可靠的，如果你没有足够好的技能和其他的收入傍身，最后哭的怎么不会是你？","text":"不知道有没有觉得程序员是吃青春饭的； 有没有发现很多公司的招聘需求上写着35岁以上不要； 有没有发现一转眼都已奔三，却依旧一事无成，无房无车； 怎么办？我想过创业，我也创业过，15年的时候和同学一块做人脸识别，种种原因最后没成功，此前两年的积蓄也清零，创业？人家都说是九死一生，我说就是，在你没有足够人脉钱脉的时候你去创业，无异于以卵击石。 程序员是吃请青春饭的，因为这个行业加班最严重，年轻人不断涌上，没时间谈恋爱，谈了恋爱的不敢结婚，结婚的不敢生孩子，生孩子了也不能自己养，要爸妈带，中国现在社会就是这样，年轻人压力巨大，上有老下有小，奔三的我感觉鸭梨山大。 既然不能创业那就好好工作，把工作的事情做好，我也觉得，但是2018年底都知道大裁员，公司也未必是可靠的，如果你没有足够好的技能和其他的收入傍身，最后哭的怎么不会是你？ 地心引力这个社会是一张网紧紧的黏住你，让你无法动弹，无法很好的去世界各地自己想去的地方，无法任性而为还本真的自我，要想摆脱这种地心引力，你要实现的目标就是要实现财务自由，这样你将不再受到工作、家庭的制约。 财务自由近十几年，不同的人，实现财务自由的方式不尽然相同。 有些人天生就财务自由，爸妈给的，就像王思聪，可能你姓王，但是你爸不是王健林； 有些人搭上了不错的“班车”，比如滴滴，美团，小米，公司给予了丰厚股票奖励，也实现了财务自由，很可惜我并没有搭上。 有些人运气比较好，赶上14年股市普涨，又能及时悬崖勒马，狠狠赚了一匹，但我觉得这只是让你一下子突然获得了一箩筐的“鱼”，你没有鱼竿，等你的鱼都吃完的时候，你还是没法学会更好的生存。 同样的还有炒比特币的，赌场要是赚了，不要高兴太早，及早收心。 而绝大多数人，是没有这个福气和运气的，很多都同我一样，默默无闻。 我想实现财务自由，那怎么办呢？ 让我们微创业吧先让我们牢记第一条使命，就是把工作上老板交代的活干好 然后是有余力，就微创业吧 微创业，目标是在不影响工作的情况下，额外的创收。 都有哪些做法？第一就是接外包，这种方式来钱明显，但是很多外包都是想要最少的钱，让别人干最多的活，十分的累，还不如工作赚的多，而且十分影响你现在的工作，我极力反对用这个方式创收。 第二就是要在工作之外把自己变成独立的开发者，依靠我们自身的技术优势，来做点小而美的产品，例如iPic的作者Jason（产品经理出生，为了做独立开发者，自学ios相关的技术，https://toolinbox.net/），还有码力全开工作室http://maliquankai.com/的Larry，虽然我们中绝大多数人没办法像他们一样做全职的独立开发者，但是我们在工作中好好打磨一款产品，等它的收入达到一定时，你就可以全职来彻底搞它了。 关键：坚持选好点子，然后就是要长期坚持，如果你放弃了，这一切都完了！ 附 我一直在努力的网站：主机排行网 https://hostingranking.cn/ 后续我会慢慢分享独立开发者心得和干货 加我好友，拉你进独立开发者群","categories":[],"tags":[{"name":"程序员","slug":"程序员","permalink":"http://www.cmlanche.com/tags/程序员/"},{"name":"微创业","slug":"微创业","permalink":"http://www.cmlanche.com/tags/微创业/"}]},{"title":"安装指定版本的node的方法","slug":"安装指定版本的node","date":"2019-01-23T13:19:19.000Z","updated":"2019-02-24T00:51:09.000Z","comments":true,"path":"2019/01/23/安装指定版本的node/","link":"","permalink":"http://www.cmlanche.com/2019/01/23/安装指定版本的node/","excerpt":"","text":"安装指定版本的node的方法sudo npm cache clean -f # 清除缓存sudo npm install -g n # 安装node版本工具nsudo n 10.13.0 # 10.13.0 是版本号# sudo n stable # 安装当前最新的最稳定版本的node","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://www.cmlanche.com/tags/nodejs/"}]},{"title":"开闭原则","slug":"开闭原则","date":"2018-12-10T03:00:57.000Z","updated":"2019-02-26T06:40:05.000Z","comments":true,"path":"2018/12/10/开闭原则/","link":"","permalink":"http://www.cmlanche.com/2018/12/10/开闭原则/","excerpt":"再谈开闭原则最开始了解设计模式之开闭原则是在6年前，那个时候我还是在校大学生，我是读《设计模式之禅》了解到它的。开闭原则是说，对扩展开发，对修改关闭，当时我看书的时候还不太了解它的含义，只知道这是设计模式最重要的原则，其他5大原则（如最小接口原则、迪米特原则、里式替换原则等）都是为了更好的实现开闭原则而总结出来的一套方法论，而书中说的23大设计模式都是基于这些模式的实践。 今天我又一次感受到了开闭原则的牛逼，我感受到，它不仅仅可以用在实际的代码编写上，对整个系统的架构都有指导借鉴意义。","text":"再谈开闭原则最开始了解设计模式之开闭原则是在6年前，那个时候我还是在校大学生，我是读《设计模式之禅》了解到它的。开闭原则是说，对扩展开发，对修改关闭，当时我看书的时候还不太了解它的含义，只知道这是设计模式最重要的原则，其他5大原则（如最小接口原则、迪米特原则、里式替换原则等）都是为了更好的实现开闭原则而总结出来的一套方法论，而书中说的23大设计模式都是基于这些模式的实践。 今天我又一次感受到了开闭原则的牛逼，我感受到，它不仅仅可以用在实际的代码编写上，对整个系统的架构都有指导借鉴意义。 我目前负责的是我司自动化测试的执行流程，今天有个需求是要给各个手机agent server添加一个doctor的诊断命令。目前的架构是这样的，有3个手机agent server，分别是Robotium、UIAutomator和iOS的XCUTest，执行端这边负责建立socket短连接与这3个agent server进行通信，目前在我写的一个AgentManger来协调管理他们，这部分已经完美运行一年半了，改动很小，需求是现在要添加一个新命令doctor，然而我发现这三个agent server都通过socket连接，但他们的通信内容的协议居然完全不一样，Robotium agent server这边是以“OKEY%s”来格式化返回值，单不看整个的通信架构是否合理，就这个返回的字符串我就很想吐槽，哪有这样的？！通常都是用统一格式的JSON来表达返回结果的，不管是几个agent server，都可以用一套处理模式来处理，甚至分出一个独立的工程模块来做这件事情，而UIAutomator Agent server它的返回值的结构则是{‘success’: true, ‘msg’: ‘xxxxx’}的一个json结构，这个表示也很糟糕，虽然是json的，但是只有true和false两种状态，如果你说你把它改一下不就行了吗，但是你要知道，以往的工程已经积累了几十个接口了，如果去改它以前的通信结构，那么会改动特别大，整个程序要进行回归测试才可以重新上线，所以从一开始就设计出统一的通信协议是多么重要，而如果是在统一的模块中处理的话，那就更容易了，只要在这个模块中更改协议就好了，做少量测试就可以知道你的改动是否覆盖所有的接口，这样可以大大减少后面的工作量！ 再联系到我们的开闭原则，原则说，要对修改关闭，对扩展开放，上面的那个垃圾通信协议结构，你要对它进行修改是无比的困难，而添加新的接口，又会让这样的垃圾结构继续存在，当某一天你发现这样的通信结构无法满足要求时，你会发现你必须得修改，也就是要重构了。所以从一开始设计出一套能够更容易扩展，无需修改的结构是多么重要！","categories":[],"tags":[{"name":"开闭原则","slug":"开闭原则","permalink":"http://www.cmlanche.com/tags/开闭原则/"},{"name":"设计模式","slug":"设计模式","permalink":"http://www.cmlanche.com/tags/设计模式/"}]},{"title":"面基","slug":"面基青春无罪","date":"2018-08-26T10:41:07.000Z","updated":"2019-02-24T00:56:59.000Z","comments":true,"path":"2018/08/26/面基青春无罪/","link":"","permalink":"http://www.cmlanche.com/2018/08/26/面基青春无罪/","excerpt":"","text":"“青春无罪”是我QQ群（518914410）的一个网友，是我第一个线下交流的网友，是北工大仪器测量专业方向的博士生，为人非常爽朗，乐于助人。今天跟他见面非常开心，跟他学习了很多，主要有两点要说的： 第一就是不要着急，做好当下需要做的事情，一步一个脚印，一个大的目标的达成不是一下子就能达成的，需要慢慢积累； 第二个就是对怎么做好一个产品刷新了我的认识，以前我太过于盲目，自己的需求并不是大众的需求，做好一个产品是要找准大众的一个需求才行，更不能没想清楚就开始写代码实现，一个产品的实际需求可能需要结合产品的实际情况来分析，马斯洛金字塔需求最底下是生理需求，比如吃喝拉撒睡，中间是安全需求，最顶层是自我价值的实现与超越，你的产品需要根据实际场景来具体分析，不能你想是什么就是什么。","categories":[],"tags":[{"name":"面基","slug":"面基","permalink":"http://www.cmlanche.com/tags/面基/"}]},{"title":"制作ghost主题","slug":"制作ghost主题","date":"2018-08-26T05:16:04.000Z","updated":"2019-02-26T06:40:56.000Z","comments":true,"path":"2018/08/26/制作ghost主题/","link":"","permalink":"http://www.cmlanche.com/2018/08/26/制作ghost主题/","excerpt":"以开发模式启动ghostcd yourghostpathghost start --development# 如果你已经启动了ghost，但不是开发模式，你可以用ghost stop来结束ghost 建立主题目录首先主题的开发环境是nodejs，所以要我们要先用nodejs构建一个项目，比如我们的项目是example: cd yourghostpath/content/themesmkdir examplecd examplenpm init 按照提示建立好基本的package.json，ghost主题最少的要求是有2个文件：index.hbs和post.hbs，这里hbs文件是handlerbars文件，它是一个模板引擎，而ghost只支持用handlerbars，所以掌握handlerbars很重要，其实也不难，关键是要了解怎么传递值的。目录和文件建立好了，主题就算完成了，虽然一句代码都没有，但他确实能够正常运转！","text":"以开发模式启动ghostcd yourghostpathghost start --development# 如果你已经启动了ghost，但不是开发模式，你可以用ghost stop来结束ghost 建立主题目录首先主题的开发环境是nodejs，所以要我们要先用nodejs构建一个项目，比如我们的项目是example: cd yourghostpath/content/themesmkdir examplecd examplenpm init 按照提示建立好基本的package.json，ghost主题最少的要求是有2个文件：index.hbs和post.hbs，这里hbs文件是handlerbars文件，它是一个模板引擎，而ghost只支持用handlerbars，所以掌握handlerbars很重要，其实也不难，关键是要了解怎么传递值的。目录和文件建立好了，主题就算完成了，虽然一句代码都没有，但他确实能够正常运转！ 激活主题打开你的网站后台http://localhost:2368/ghost，在Design-Themes中可以看到你的主题example，然后点击active激活，此时会弹出一个警告框，不管它，主题已经可以正常使用了，只是它是个空的，打开http://localhost:2368验证一下 ###热加载 它的目的是可以实时加载刷新页面，你需要安装nodemon # 需要先停止ghostghost stop# 安装nodemonnpm install -g nodemon@latest# 切换到你的主题目录下cd yourthemedevpath# 热加载nodemon index.js --watch ./ --ext hbs,js,css 这是制作主题的基本套路，完成这些后就需要编写主题的代码了","categories":[],"tags":[{"name":"ghost","slug":"ghost","permalink":"http://www.cmlanche.com/tags/ghost/"},{"name":"ghost主题","slug":"ghost主题","permalink":"http://www.cmlanche.com/tags/ghost主题/"}]},{"title":"工作无非是温水煮青蛙","slug":"温水煮青蛙","date":"2018-08-24T08:50:25.000Z","updated":"2018-08-24T08:57:50.000Z","comments":true,"path":"2018/08/24/温水煮青蛙/","link":"","permalink":"http://www.cmlanche.com/2018/08/24/温水煮青蛙/","excerpt":"","text":"在别人公司上班工作是下策，看似光鲜亮丽的生活，其实是温水煮青蛙，当某一天公司倒闭，或个人技术跟不上、在公司各种不服等等因素，不知道你有没有感受到面临淘汰的危机感。我时常有这样的感觉，不是非得自己给自己打工，而是你需要有不受制于人的技术、财富。你就必须要勤奋努力，抓紧时间做出一个有价值的优秀赚钱来源。加油！ ————————————————————————————————————————————致己书","categories":[],"tags":[]},{"title":"令人绝望的UIAutomator WebView自动化测试","slug":"令人绝望的UIAutomator-WebView自动化测试","date":"2018-08-17T11:02:00.000Z","updated":"2018-08-19T13:11:23.000Z","comments":true,"path":"2018/08/17/令人绝望的UIAutomator-WebView自动化测试/","link":"","permalink":"http://www.cmlanche.com/2018/08/17/令人绝望的UIAutomator-WebView自动化测试/","excerpt":"","text":"特别特别想吐槽Android UIAutomator对WebView的控件树渲染，谷歌简直就写了一坨屎，又乱又臭 为什么要吐槽？需求是这样的，我们期望通过UIAutomator对WebView来dump结构一致的控件树结构，以便在使用XPath定位的时候能够精准查询每个控件。然而实际情况是： 1. 可以与不可以的问题UIAutomator在某些Android版本（好像是4.4.4以下不支持）上无法dump，只有一个android.webkit.WebView节点。 2. 就算可以dump，结构和内容也极度不统一UIAutomator就算能很好的dump应用中WebView的元素，但是结构也非常不统一，结构混乱。 目前我碰到的情况有： 1. 识别能力不一致android 8.0会正确识别应用中的图片，把它标记为android.widget.Image，而在7.1等上却不能，只能识别成android.view.View 2.识别出的结构不一致有些可能会多增加一些android.view.View的包装视图，可能不仅仅是一层包装 3. 识别出的内容也不一样通常在高版本手机，比如8.0+上能把一些图片识别出带文本的View，低版本却不能 吐槽就算你内容识别出文本了，View能正确识别为Image了，我都不怪你，我都可以做转化，比如我忽略问题，Image我都统一转化为View，但是结构不一致那就问题太大了，XPAth查找完全失效！在WebView中你无法利用其它条件来定位一个控件，能定位控件的文本、ID、class在WebView中都是不稳定因素。 寻找思路解决这个问题1. 将WebView设置为可调试模式，远程调试它本方案的目的就是要能够向WebView注入JavaScript代码，然后输出我们自己的一个查询结果，因为我们面对的是一个固定的网页html，所以它是兼容性很好的方式。 实现方式就是调用WebView的静态方法WebView.setWebContentsDebuggingEnabled(true)，然后打开chrome://inspect调试当前WebView页面，但是很明显无效，设置调试模式仅仅对当前应用有效，对其他应用不产生任何效果，不然WebView就没啥安全性可言了。 网上说（https://blog.csdn.net/zhulin2609/article/details/51437821）可以用root权限强制开启，但是我们的场景是面对成千上万的没root权限手机，去root显然不现实，本方案放弃 2. 利用VisualXposed来架设一个类似虚拟机的东西，用这个虚拟机来启动被测应用开源地址：https://github.com/android-hacker/VirtualXposed 这个方案你需要掌握VisualApp和epic项目，它可以实现对被测应用的完全掌控，也不需要root权限，但是它过于复杂，不稳定性因素太多，兼容性有待验证，本方案可行，但对暂时Testin云测是不适用，留作待定研究吧。 3. 利用UIAutomator渲染的不稳定坑逼的WebView的AccessbilityNodeInfo来重新构造我们自己的控件树结构这种方案来源于我对界面控件元素区域的思考，虽然UIAutomator给的控件树不靠谱，但是界面上的信息它都有（如果能dump的话），如果我们按照控件的区域重新组织这个WebView的结构的话，是否可行？ 比如A区域在B区域的里面，那么我们认定A是B的子节点，如果A和B没有父子关系，他们处于同一Y坐标，那么他们可以认为是兄弟节点，如果他们的区域是一致的，那么他们其中之一是可以被忽略的，至于忽略谁，就要看谁附带的信息更有价值，比如A的带有文本或class是Image，显然A就更有价值，忽略B。 按照上面的大致逻辑，我们可以构造一个自己的控件树，这样是否可以提高兼容性？ 实际上我做了测试，用云测Testin的700+个手机做了验证，在未使用本方案之前，通过了98台设备，使用本方案我测试了两次，第一次通过223，第二次是194次，提高了一倍 使用本方案之前 使用本方案之后 有一些效果，但是还不够o(╥﹏╥)o 最后我想问 谷歌的UIAutomator2.0测试框架在WebView上测试是很坑爹的，也是特别难解的，为什么不能让我们自定义渲染逻辑呢？ 有哪位同学有更好的方式？能够兼容上千款不同的设备不同的版本？","categories":[],"tags":[{"name":"UIAutomator吐槽","slug":"UIAutomator吐槽","permalink":"http://www.cmlanche.com/tags/UIAutomator吐槽/"}]},{"title":"Android自动化·细数UIAutomator的坑·UIAutomator渲染WebView控件树在不同手机上的差异","slug":"Android自动化·细数UIAutomator的坑·控件树在不同手机上的差异","date":"2018-08-13T10:50:31.000Z","updated":"2018-08-13T11:09:34.000Z","comments":true,"path":"2018/08/13/Android自动化·细数UIAutomator的坑·控件树在不同手机上的差异/","link":"","permalink":"http://www.cmlanche.com/2018/08/13/Android自动化·细数UIAutomator的坑·控件树在不同手机上的差异/","excerpt":"我想只有Testin云测才会遇到这样的问题，云测的自动化技术是要抹掉手机的差异性的，就是说一套脚本可以在不同的手机产商不同的手机版本上成功运行，而云测会遇到很多很多各种各样因为手机产商与版本的差异导致脚本不兼容的问题，而今天我讲的是最近发现的UIAutomator在WebView控件树渲染在不同手机上的差异。 Testin云测已跨越自动化测试的万水千山，欢迎来测！","text":"我想只有Testin云测才会遇到这样的问题，云测的自动化技术是要抹掉手机的差异性的，就是说一套脚本可以在不同的手机产商不同的手机版本上成功运行，而云测会遇到很多很多各种各样因为手机产商与版本的差异导致脚本不兼容的问题，而今天我讲的是最近发现的UIAutomator在WebView控件树渲染在不同手机上的差异。 Testin云测已跨越自动化测试的万水千山，欢迎来测！ 额外话对WebView来说，UIAutomator的能力是很有限的，更别提小程序使用的腾讯X5内核的Webview，以及国外流行的Crosswalk，他们俩UIAutomator是根本无法识别的，但是云测对小程序有独特的支持。下回我会分析UIAutomator为啥无法很好识别WebView。 正题中国手机产商太多了，而且Android版本分布也特别凌乱，从4.3到8.0都有，而它对WebView的渲染能力也各有不同，经过我分析云测700个手机在同一WebView页面的执行结果，我发现有的控件树可能是这样的: &lt;node class=\"android.webkit.WebView\" bounds=\"[0,0,100,100]\"&gt; &lt;node class=\"android.view.View\" bounds=\"[0,0,20,20]\"&gt; &lt;node class=\"android.view.TextView\" bounds=\"[0,0,20,20]\"&gt; &lt;/node&gt; &lt;/node&gt;&lt;/node&gt; 而有的是这样的 &lt;node class=\"android.webkit.WebView\" bounds=\"[0,0,100,100]\"&gt; &lt;node class=\"android.view.TextView\" bounds=\"[0,0,20,20]\"&gt; &lt;/node&gt;&lt;/node&gt; 我们发现TextView外层居然有一层皮，而有的居然没有，这是不一致的，这样会导致后续依赖控件树结构的xpath查询会失败，怎么抹掉这种差异性呢？问题我已道出，怎么解我也有办法，但是涉及到公司机密，我也只能点到为止。","categories":[],"tags":[{"name":"Android自动化","slug":"Android自动化","permalink":"http://www.cmlanche.com/tags/Android自动化/"},{"name":"细数UIAutomator的坑","slug":"细数UIAutomator的坑","permalink":"http://www.cmlanche.com/tags/细数UIAutomator的坑/"}]},{"title":"android自动化研发日志 - 细数UIAutomator缺点 - 1.0和2.0的区别","slug":"android自动化研发日志---细数UIAutomator缺点---关于版本的吐槽","date":"2018-08-13T09:18:06.000Z","updated":"2018-08-13T10:49:03.000Z","comments":true,"path":"2018/08/13/android自动化研发日志---细数UIAutomator缺点---关于版本的吐槽/","link":"","permalink":"http://www.cmlanche.com/2018/08/13/android自动化研发日志---细数UIAutomator缺点---关于版本的吐槽/","excerpt":"","text":"Hi，我是云测自动化研发工程师，关于我可以看这个链接：一只误入歧途的资深自动化研发（待写） 系列文章：细数UIAutomator缺点(待写) 专题：android自动化测试（待写） 关于云测的自动化测试技术：我不说你肯定不知道原来Testin云测自动化技术在某种程度上讲已经超越了谷歌（待写） 综述本文讨论的是关于UIAutomator版本的吐槽，我们都知道UIAutomator分为两个版本，1.0和2.0 如下是两者的对比 1.0 2.0 最低Android版本分界线 大于或等于16 大于或等于18 运行包形式 jar apk 权限 shell级别 自身apk权限赋予 UIAutomator1.0官网已经没有1.0的链接了，只有2.0的，我在其他地方找到老学习链接：https://stuff.mit.edu/afs/sipb/project/android/docs/tools/help/uiautomator/index.html UIAutomator的运行包是一个jar包，运行命令大致如 # yourtest.jar是你的jar在android系统的具体文件路径，通常放在/data/local/tmp/目录下# yourjarclass是你要执行的测试方法，例如com.test.YourTestClass#functionnameadb shell uiautomator runtest yourtest.jar -c yourjarclass#function 运行起来后，我们用命令查看UIAutomator1.0的进程是shell的 chengmingdembp:Downloads cmlanche$ adb shell ps | grep uiashell 4101 4098 2048608 61680 futex_wait 7f81656170 S uiautomatorchengmingdembp:Downloads cmlanche$ 所以它的权限是比较高的，启动之后便可以执行，也不需要安装，虽然它在这方面很便利，但它的获取控件信息的能力很鸡肋，只能获取到一个AccessibilityNodeInfo的root节点，而实际上，多root的情况是普遍存在的，尤其是5.0以后的android版本。 虽然它很鸡肋，但是它可以用来做安装UIAutomator2.0之前的操作，UIAutomator2.0需要自动安装，那么1.0的话就必须安装了，用它来自动点击UIAutomator2.0的安装对话框，在2.0启动之前的所有安装与权限框处理过程，都可以用1.0来做。 UIAutomator2.02.0是一个安装包的形式来做测试的，它拥有什么权限需要你自己去设定，谷歌现在官方只支持2.0，就说明谷歌对它有足够的重视。 官网：https://developer.android.com/training/testing/ui-automator 更好上网请用：expressvpn 2.0加入了Instrument支持，它的执行命令类似这样的： # 详情请到官网学习adb shell am instrument -w -r -e debug false -e class ....","categories":[],"tags":[{"name":"android自动化测试","slug":"android自动化测试","permalink":"http://www.cmlanche.com/tags/android自动化测试/"},{"name":"细数UIAutomator缺点","slug":"细数UIAutomator缺点","permalink":"http://www.cmlanche.com/tags/细数UIAutomator缺点/"}]},{"title":"你真的了解java的lambda吗？- java lambda用法与源码分析","slug":"lambda用法与源码分析","date":"2018-07-22T01:44:12.000Z","updated":"2018-07-23T08:21:46.000Z","comments":true,"path":"2018/07/22/lambda用法与源码分析/","link":"","permalink":"http://www.cmlanche.com/2018/07/22/lambda用法与源码分析/","excerpt":"用法示例：最普遍的一个例子，执行一个线程new Thread(() -&gt; System.out.print(\"hello world\")).start(); -&gt;我们发现它指向的是Runnable接口 @FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 分析 -&gt;这个箭头是lambda表达式的关键操作符 -&gt;把表达式分成两截，前面是函数参数，后面是函数体。 Thread的构造函数接收的是一个Runnable接口对象，而我们这里的用法相当于是把一个函数当做接口对象传递进去了，这点理解很关键，这正是函数式编程的含义所在。 我们注意到Runnable有个注解@FunctionalInterface，它是jdk8才引入，它的含义是函数接口。它是lambda表达式的协议注解，这个注解非常重要，后面做源码分析会专门分析它的官方注释，到时候一目了然。 /* @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125;","text":"用法示例：最普遍的一个例子，执行一个线程new Thread(() -&gt; System.out.print(\"hello world\")).start(); -&gt;我们发现它指向的是Runnable接口 @FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 分析 -&gt;这个箭头是lambda表达式的关键操作符 -&gt;把表达式分成两截，前面是函数参数，后面是函数体。 Thread的构造函数接收的是一个Runnable接口对象，而我们这里的用法相当于是把一个函数当做接口对象传递进去了，这点理解很关键，这正是函数式编程的含义所在。 我们注意到Runnable有个注解@FunctionalInterface，它是jdk8才引入，它的含义是函数接口。它是lambda表达式的协议注解，这个注解非常重要，后面做源码分析会专门分析它的官方注释，到时候一目了然。 /* @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; 由此引发的一些案例有参数有返回值的实例：集合排序List&lt;String&gt; list = new ArrayList&lt;&gt;();Collections.sort(list, (o1, o2) -&gt; &#123; if(o1.equals(o2)) &#123; return 1; &#125; return -1;&#125;) 我们知道Collections.sort方法的第二个参数接受的是一个Comparator&lt;T&gt;的对象，它的部分关键源码是这样的： @FunctionalInterfacepublic interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; 如上已经去掉注释和部分其他方法。 我们可以看到sort的第二个参数是Comparator的compare方法，参数类型是T，分别是o1和o2，返回值是一个int。 疑问 上面的示例我们看到接口都有个@FunctionalInterface的注解，但是我们在实际编程中并没有加这个注解也可以实现lambda表达式，例如： public class Main &#123; interface ITest &#123; int test(String string); &#125; static void Print(ITest test) &#123; test.test(\"hello world\"); &#125; public static void main(String[] args) &#123; Print(string -&gt; &#123; System.out.println(string); return 0; &#125;); &#125;&#125; 如上所示，确实不需要增加@FunctionInterface注解就可以实现 如果在1中的示例的ITest接口中增加另外一个接口方法，我们会发现不能再用lambda表达式。 我们带着这两个疑问来进入源码解析。 源码解析必须了解注解 @FunctionInterface上源码： package java.lang;import java.lang.annotation.*;/** * An informative annotation type used to indicate that an interface * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as * defined by the Java Language Specification. * * Conceptually, a functional interface has exactly one abstract * method. Since &#123;@linkplain java.lang.reflect.Method#isDefault() * default methods&#125; have an implementation, they are not abstract. If * an interface declares an abstract method overriding one of the * public methods of &#123;@code java.lang.Object&#125;, that also does * &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count * since any implementation of the interface will have an * implementation from &#123;@code java.lang.Object&#125; or elsewhere. * * &lt;p&gt;Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * &lt;p&gt;If a type is annotated with this annotation type, compilers are * required to generate an error message unless: * * &lt;ul&gt; * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class. * &lt;li&gt; The annotated type satisfies the requirements of a functional interface. * &lt;/ul&gt; * * &lt;p&gt;However, the compiler will treat any interface meeting the * definition of a functional interface as a functional interface * regardless of whether or not a &#123;@code FunctionalInterface&#125; * annotation is present on the interface declaration. * * @jls 4.3.2. The Class Object * @jls 9.8 Functional Interfaces * @jls 9.4.3 Interface Method Body * @since 1.8 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; 我们说过这个注解用来规范lambda表达式的使用协议的，那么注释中都说了哪些呢？ 一种给interface做注解的注解类型，被定义成java语言规范 * An informative annotation type used to indicate that an interface* type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as* defined by the Java Language Specification. 一个被它注解的接口只能有一个抽象方法，有两种例外。 第一是接口允许有实现的方法，这种实现的方法是用default关键字来标记的（java反射中java.lang.reflect.Method#isDefault()方法用来判断是否是default方法），例如： ​ 当然这是jdk8才引入的特性，到此我们才知道，知识是一直在变化的，我们在学校中学到interface接口不允许有实现的方法是错误的，随着时间推移，一切规范都有可能发生变化。 如果声明的方法和java.lang.Object中的某个方法一样，它可以不当做未实现的方法，不违背这个原则：一个被它注解的接口只能有一个抽象方法 例如同样是Compartor接口中，它重新声明了equals方法： 这些是对如下注释的翻译和解释 * Conceptually, a functional interface has exactly one abstract* method. Since &#123;@linkplain java.lang.reflect.Method#isDefault()* default methods&#125; have an implementation, they are not abstract. If* an interface declares an abstract method overriding one of the* public methods of &#123;@code java.lang.Object&#125;, that also does* &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count* since any implementation of the interface will have an* implementation from &#123;@code java.lang.Object&#125; or elsewhere. 如果一个类型被这个注解修饰，那么编译器会要求这个类型必须满足如下条件 这个类型必须是一个interface，而不是其他的注解类型、枚举enum或者类class 这个类型必须满足function interface的所有要求，如你个包含两个抽象方法的接口增加这个注解，会有编译错误。 * &lt;p&gt;If a type is annotated with this annotation type, compilers are* required to generate an error message unless:** &lt;ul&gt;* &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.* &lt;li&gt; The annotated type satisfies the requirements of a functional interface.* &lt;/ul&gt; 编译器会自动把满足function interface要求的接口自动识别为function interface，所以你才不需要对上面示例中的ITest接口增加@FunctionInterface注解。 * &lt;p&gt;However, the compiler will treat any interface meeting the* definition of a functional interface as a functional interface* regardless of whether or not a &#123;@code FunctionalInterface&#125;* annotation is present on the interface declaration. 通过了解function interface我们能够知道怎么才能正确的创建一个function interface来做lambda表达式了。接下来的是了解java是怎么把一个函数当做一个对象作为参数使用的。 穿越：对象变身函数让我们重新复盘一下上面最开始的实例： new Thread(() -&gt; System.out.print(\"hello world\")).start(); 我们知道在jdk8以前我们都是这样来执行的： Runnable r = new Runnable()&#123; System.out.print(\"hello world\");&#125;;new Thread(r).start(); 我们知道两者是等价的，也就是说r 等价于()-&gt;System.out.print(&quot;hello world&quot;)，一个接口对象等于一个lambda表达式？那么lambda表达式肯定做了这些事情（未看任何资料，纯粹推理，有误再改正）： 创建接口对象 实现接口对象 返回接口对象 关于UnaryOperator上篇文章（聊一聊JavaFx中的TextFormatter以及一元操作符UnaryOperator）关于UnaryOperator草草收尾，在这里给大家重新梳理一下，关于它的使用场景以及它与lambda表达式的关系 使用场景要先理解它的作用，它是接受一个参数并返回与该类型同的值，来看一个List怎么用它的，java.util.List中的replaceAll就用它了： default void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final ListIterator&lt;E&gt; li = this.listIterator(); while (li.hasNext()) &#123; li.set(operator.apply(li.next())); &#125;&#125; 我们可以看到这个方法的目的是把list中的值经过operator操作后重新返回一个新值，例如具体调用 List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"abc\");list.replaceAll(s -&gt; s + \"efg\");System.out.println(list); 其中lambda表达式s-&gt;s+&quot;efg&quot;就是这个operator对象，那么最终list中的值就变成了[“abcefg”]，由此我们可以知道它的作用就是对输入的值再加工，并返回同类型的值，怎么用就需要你自己扩展发挥了。 与lambda表达式的关系？在我看来，它跟lambda表达式的关系并不大，只是它是jdk内置的一种标准操作，类似的二元操作符BinaryOperator它可以接受两个同类型参数，并返回同类型参数的值。 关于UnaryOperator，我们百尺竿头更进一步，深入到核心先贴出它的源码： @FunctionalInterfacepublic interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; &#123; /** * Returns a unary operator that always returns its input argument. * * @param &lt;T&gt; the type of the input and output of the operator * @return a unary operator that always returns its input argument */ static &lt;T&gt; UnaryOperator&lt;T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 我们看到这个function interface居然没有抽象方法，不，不是没有，我们继续看Function接口 @FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t); /** * Returns a composed function that first applies the &#123;@code before&#125; * function to its input, and then applies this function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of input to the &#123;@code before&#125; function, and to the * composed function * @param before the function to apply before this function is applied * @return a composed function that first applies the &#123;@code before&#125; * function and then applies this function * @throws NullPointerException if before is null * * @see #andThen(Function) */ default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); &#125; /** * Returns a composed function that first applies this function to * its input, and then applies the &#123;@code after&#125; function to the result. * If evaluation of either function throws an exception, it is relayed to * the caller of the composed function. * * @param &lt;V&gt; the type of output of the &#123;@code after&#125; function, and of the * composed function * @param after the function to apply after this function is applied * @return a composed function that first applies this function and then * applies the &#123;@code after&#125; function * @throws NullPointerException if after is null * * @see #compose(Function) */ default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); &#125; /** * Returns a function that always returns its input argument. * * @param &lt;T&gt; the type of the input and output objects to the function * @return a function that always returns its input argument */ static &lt;T&gt; Function&lt;T, T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 既然他们都被注解为@FunctionInterface了，那么他们肯定有一个唯一的抽象方法，那就是apply 我们知道-&gt;lambda表达式它是不需要关心函数名字的，所以不管它叫什么，apply也好，apply1也好都可以，但jdk肯定要叫一个更加合理的名字，那么我们知道s -&gt; s + &quot;efg&quot;中-&gt;调用的就是apply方法 而且我们注意到这里有一个identity()的静态方法，它返回一个Function对象，它其实跟lambda表达式关系也不大，它的作用是返回当前function所要表达的lambda含义。相当于创建了一个自身对象。 Function算是lambda的一种扩展应用，这个Function的的作用是Represents a function that accepts one argument and produces a result.意思是接受一个参数，并产生（返回）一个结果（类型可不同）。 类似的还有很多Function，都在包java.util.Function中 你也可以创建自己的Function，它是用来表达操作是怎样的。如传入的参数是什么，返回的是什么。 其实你只要明白它抽象的是操作就可以了。 到此就知道，原来UnaryOperator没啥神秘的，jdk把这些操作放在java.util.function中也正说明了它是一个工具类，是为了提取重复代码，让它可以重用，毕竟需要用到这样的操作的地方太多了，提取是有必要的。 转载请注明来源：cmlanche.com","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.cmlanche.com/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"http://www.cmlanche.com/tags/lambda/"},{"name":"UnaryOperator","slug":"UnaryOperator","permalink":"http://www.cmlanche.com/tags/UnaryOperator/"}]},{"title":"聊一聊JavaFx中的TextFormatter以及一元操作符UnaryOperator","slug":"聊一聊JavaFx中的TextFormater","date":"2018-07-21T07:49:27.000Z","updated":"2018-07-22T01:15:18.000Z","comments":true,"path":"2018/07/21/聊一聊JavaFx中的TextFormater/","link":"","permalink":"http://www.cmlanche.com/2018/07/21/聊一聊JavaFx中的TextFormater/","excerpt":"直击主题：它在JavaFx中可以实现什么效果它可以格式化输入文本的内容，可以允许输入哪种值，可以规定光标的位置，例如可以实现一个输入框只允许输入数字， 例如textfield表示输入框对象，那么设置格式化内容的话就应该像这样子：textfield.setTextformatter(new TextFormatter&lt;String&gt;(IntegerFilter)), 而其中IntegerFilter就是只允许输入数字的过滤器，它的代码是怎样的呢？ /** * Created by cmlanche on 2017/7/10. * 整数过滤器 * 应用：比如使一个输入框只能输入数字 */public class IntegerFilter implements UnaryOperator&lt;TextFormatter.Change&gt; &#123; private final static Pattern DIGIT_PATTERN = Pattern.compile(\"\\\\d*\"); @Override public TextFormatter.Change apply(TextFormatter.Change change) &#123; return DIGIT_PATTERN.matcher(change.getText()).matches() ? change : null; &#125;&#125; DIGIT_PATTERN大家都能看出来它是正则表达式，是匹配文本是否是整数的表达式。 apply方法中的实现的意思是，只要符合整数就返回change，否则返回null","text":"直击主题：它在JavaFx中可以实现什么效果它可以格式化输入文本的内容，可以允许输入哪种值，可以规定光标的位置，例如可以实现一个输入框只允许输入数字， 例如textfield表示输入框对象，那么设置格式化内容的话就应该像这样子：textfield.setTextformatter(new TextFormatter&lt;String&gt;(IntegerFilter)), 而其中IntegerFilter就是只允许输入数字的过滤器，它的代码是怎样的呢？ /** * Created by cmlanche on 2017/7/10. * 整数过滤器 * 应用：比如使一个输入框只能输入数字 */public class IntegerFilter implements UnaryOperator&lt;TextFormatter.Change&gt; &#123; private final static Pattern DIGIT_PATTERN = Pattern.compile(\"\\\\d*\"); @Override public TextFormatter.Change apply(TextFormatter.Change change) &#123; return DIGIT_PATTERN.matcher(change.getText()).matches() ? change : null; &#125;&#125; DIGIT_PATTERN大家都能看出来它是正则表达式，是匹配文本是否是整数的表达式。 apply方法中的实现的意思是，只要符合整数就返回change，否则返回null 经过测试发现，当返回change的时候，可以允许输入，如输入0~9中的任意数字都可以输入，但输入非数字的话，会返回null，此时发现输入框光标不会移动，而且内容也不会变化，说明null是禁用的意思。 还有个细节就是当按下delete键时，change对象中有个方法叫isDeleted返回true，而文本是空，当按下其他字符，如1时，change中的getText为1，change还有个getControl和getControlText可以返回控件和控件的文本。说明change是包含了当前变化的内容和不变的内容。 那么这个TextFormatter就厉害了，利用change中的信息，可以实现对输入框的各种格式需求，上面例子中让输入框只能输入数字只是TextFormatter的冰山一角，还可以实现各种各样的其他需求，例如让输入框中的值只能是浮点数，只能是字母，字符数只能是6位。有了它，都可以不用对它的值再进行额外的校验，而且可以通用起来，只需要编写不同的过滤器就可以了。 源码解析：TextFormatter是如何发挥作用的？从上面的分析我们可以清楚的看到是TextFormatter中的filter发挥了过滤作用，而TextFormatter是给TextField使用的，那么TextFormatter必定有函数给TextField来调用，所以我们找到了getFilter，我们在TextField中找这个函数可以看到： /** * Replaces a range of characters with the given text. * * @param start The starting index in the range, inclusive. This must be &amp;gt;= 0 and &amp;lt; the end. * @param end The ending index in the range, exclusive. This is one-past the last character to * delete (consistent with the String manipulation methods). This must be &amp;gt; the start, * and &amp;lt;= the length of the text. * @param text The text that is to replace the range. This must not be null. */public void replaceText(final int start, final int end, final String text) &#123; if (start &gt; end) &#123; throw new IllegalArgumentException(); &#125; if (text == null) &#123; throw new NullPointerException(); &#125; if (start &lt; 0 || end &gt; getLength()) &#123; throw new IndexOutOfBoundsException(); &#125; if (!this.text.isBound()) &#123; final int oldLength = getLength(); TextFormatter&lt;?&gt; formatter = getTextFormatter(); TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), start, end, text); if (formatter != null &amp;&amp; formatter.getFilter() != null) &#123; change = formatter.getFilter().apply(change); if (change == null) &#123; return; &#125; &#125; // Update the content updateContent(change, oldLength == 0); &#125;&#125; /** * Positions the anchor and caretPosition explicitly. */public void selectRange(int anchor, int caretPosition) &#123; caretPosition = Utils.clamp(0, caretPosition, getLength()); anchor = Utils.clamp(0, anchor, getLength()); TextFormatter.Change change = new TextFormatter.Change(this, getFormatterAccessor(), anchor, caretPosition); TextFormatter&lt;?&gt; formatter = getTextFormatter(); if (formatter != null &amp;&amp; formatter.getFilter() != null) &#123; change = formatter.getFilter().apply(change); if (change == null) &#123; return; &#125; &#125; updateContent(change, false);&#125; private boolean filterAndSet(String value) &#123; // Send the new value through the textFormatter, if one exists. TextFormatter&lt;?&gt; formatter = getTextFormatter(); int length = content.length(); if (formatter != null &amp;&amp; formatter.getFilter() != null &amp;&amp; !text.isBound()) &#123; TextFormatter.Change change = new TextFormatter.Change( TextInputControl.this, getFormatterAccessor(), 0, length, value, 0, 0); change = formatter.getFilter().apply(change); if (change == null) &#123; return false; &#125; replaceText(change.start, change.end, change.text, change.getAnchor(), change.getCaretPosition()); &#125; else &#123; replaceText(0, length, value, 0, 0); &#125; return true;&#125; 如上，从TextField源码中我们找到了三个与TextFormatter的filter有关的方法，他们的大致意思就是当有变化产生时（例如按下字符1），就会触发一个change产生，然后就会调用filter来产生一个新的change对象，这个对象会改变最终输入框中的内容。 陌生知识：UnaryOperator和大家一样，平时很少看到这个类，我百度查了一下，这个类叫一元运算符，它继承自java.util.function.Function，是jdk中的内容，不是javafx的（包括UnaryOperator也是jdk的内容），源码是这样的： /** * Represents an operation on a single operand that produces a result of the * same type as its operand. This is a specialization of &#123;@code Function&#125; for * the case where the operand and result are of the same type. * * &lt;p&gt;This is a &lt;a href=\"package-summary.html\"&gt;functional interface&lt;/a&gt; * whose functional method is &#123;@link #apply(Object)&#125;. * * @param &lt;T&gt; the type of the operand and result of the operator * * @see Function * @since 1.8 */@FunctionalInterfacepublic interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; &#123; /** * Returns a unary operator that always returns its input argument. * * @param &lt;T&gt; the type of the input and output of the operator * @return a unary operator that always returns its input argument */ static &lt;T&gt; UnaryOperator&lt;T&gt; identity() &#123; return t -&gt; t; &#125;&#125; 它的意思是输入和输出是同一个值，函数identity的意思是总是返回输入的参数，而且只有一个参数，这个一元操作符UnaryOperator被注解@FuntionalInterface了，它是java.lang.包中的内容，代码如下： @Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; 已经涉及到很深的内容了，而identity我猜测应该是与jdk内部实现有关的，会被自动调用的，所有关于他们就到此为止，不再深入分析。 而我注意到一点，一元操作符UnaryOperator有更优雅的用法。文章开头我们注意到IntegerFilter，我们的写法是让它实现UnaryOperator，但其实可以这么做： textfield.setTextFormatter(new TextFormatter&lt;String&gt;((change)-&gt;&#123; Pattern DIGIT_PATTERN = Pattern.compile(\"\\\\d*\"); return DIGIT_PATTERN.matcher(change.getText()).matches() ? change : null;&#125;)) 为啥变化这么大？ 慢慢分析发现对lambda知识的了解的欠缺，接下来的内容涉及到java函数式编程lambda表达式的核心内容，敬请下篇文章更新(^▽^) 转载请注明出处：https://www.cmlanche.com/","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://www.cmlanche.com/tags/javafx/"},{"name":"textformatter","slug":"textformatter","permalink":"http://www.cmlanche.com/tags/textformatter/"},{"name":"unaryoperator","slug":"unaryoperator","permalink":"http://www.cmlanche.com/tags/unaryoperator/"},{"name":"lambda表达式","slug":"lambda表达式","permalink":"http://www.cmlanche.com/tags/lambda表达式/"}]},{"title":"Unable to start monitor 4454, An other instance is problaly using the same port","slug":"Unable-to-start-monitor-4454,-An-other-instance-is-problaly-using-the-same-port","date":"2018-07-18T07:00:26.000Z","updated":"2018-07-18T07:12:58.000Z","comments":true,"path":"2018/07/18/Unable-to-start-monitor-4454,-An-other-instance-is-problaly-using-the-same-port/","link":"","permalink":"http://www.cmlanche.com/2018/07/18/Unable-to-start-monitor-4454,-An-other-instance-is-problaly-using-the-same-port/","excerpt":"最近两个月启动IDEA一直这个错误，终于今天忍不住了，找了下解决这个问题的方法 造成IDEA启动失败。","text":"最近两个月启动IDEA一直这个错误，终于今天忍不住了，找了下解决这个问题的方法 造成IDEA启动失败。 解决办法禁用或者卸载Log4JPlugin插件，这个插件没什么卵用，14年之后就不再更新了。 卸载方法菜单Preferences-&gt;Plugins，然后搜索log4JPlugin就出来了，然后Uninstall卸载","categories":[],"tags":[{"name":"idea","slug":"idea","permalink":"http://www.cmlanche.com/tags/idea/"}]},{"title":"解决Android Robotium(Instrumentation)初始化时getActivity阻塞的问题","slug":"解决Android-Robotium初始化时getActivity不返回的问题","date":"2018-07-17T03:52:23.000Z","updated":"2018-07-18T05:56:09.000Z","comments":true,"path":"2018/07/17/解决Android-Robotium初始化时getActivity不返回的问题/","link":"","permalink":"http://www.cmlanche.com/2018/07/17/解决Android-Robotium初始化时getActivity不返回的问题/","excerpt":"如果应用没有启动，阻塞了这种情况getActivity肯定会阻塞的，你需要调用startActivity启动起来： getInstrumentation().getTargetContext().startActivity(intent); 如果在Robotium中还是没启动，你就需要借助外力来启动它了，比如命令： am start .... // 代码未写完整，意思就是你需要借助am的命令来启动应用","text":"如果应用没有启动，阻塞了这种情况getActivity肯定会阻塞的，你需要调用startActivity启动起来： getInstrumentation().getTargetContext().startActivity(intent); 如果在Robotium中还是没启动，你就需要借助外力来启动它了，比如命令： am start .... // 代码未写完整，意思就是你需要借助am的命令来启动应用 如果应用启动了，但还是阻塞了有两种方式可以尝试，第一种： ActivityMonitor monitor = getInstrumentation().addMonitor(activity.getName(), null, false);Activity activity = getInstrumentation().waitForMonitorWithTimeout(monitor, 10000); 这种方式的意思是，对测试的Activity追加一个Monitor来追踪它的状态，并等待返回一个Activity对象，超时时间为10s。但是这种方式未必总是有效，在极端情况下，还是会阻塞。此时你就需要用第二种方式尝试获取Activity了 第二种方式：Java反射 通过观察第一种方式的实现源码，我们发现被测Activity都是存放在Instrumentation =&gt; ActivityThread(mThread) =&gt; ArrayMap&lt;IBinder, ActivityClientRecord&gt;(mActivities) =&gt; Activity的一个map中的，那么我们通过反射的方式剥离3层，可以拿到这个对象。 Object mThread = ReflectHelper.getField(getInstrumentation(), Instrumentation.class.getName(), \"mThread\");Log.e(\"tag\", \"inst mthread = \" + mThread);if (mThread != null) &#123; Object mActivities = ReflectHelper.getField(mThread, null, \"mActivities\"); Log.e(\"tag\", \"inst mActivities = \" + mActivities); if (mActivities != null &amp;&amp; mActivities instanceof Map) &#123; Map actMap = (Map) mActivities; Set&lt;Map.Entry&gt; sets = actMap.entrySet(); Iterator&lt;Map.Entry&gt; iterable = sets.iterator(); while (iterable.hasNext()) &#123; Map.Entry entry = iterable.next(); Object actRecObj = entry.getValue(); Log.e(\"tag\", \"ActivityClientRecord: \" + actRecObj); Object actObj = ReflectHelper.getField(actRecObj, null, \"activity\"); Log.e(\"tag\", \"Activity: \" + actObj); if (actObj != null) &#123; return (Activity) actObj; &#125; &#125; &#125;&#125; 上述的种种方式可以完全解决getActivity阻塞的问题！","categories":[],"tags":[{"name":"Robotium","slug":"Robotium","permalink":"http://www.cmlanche.com/tags/Robotium/"},{"name":"自动化研发","slug":"自动化研发","permalink":"http://www.cmlanche.com/tags/自动化研发/"}]},{"title":"Bloogle开发日记 | 制作一个滚动大纲的前端网页","slug":"从零制作一个滚动markdown大纲的前端网页","date":"2018-07-11T00:19:58.000Z","updated":"2018-07-17T05:20:09.000Z","comments":true,"path":"2018/07/11/从零制作一个滚动markdown大纲的前端网页/","link":"","permalink":"http://www.cmlanche.com/2018/07/11/从零制作一个滚动markdown大纲的前端网页/","excerpt":"从零教学怎么制作一个滚动大纲","text":"从零教学怎么制作一个滚动大纲 前端页面大纲区域是一个列表，列表中的每项的超链接&lt;a&gt;都有一个#id的超链接指向gif中左侧的内容区域的heading标题 JS代码 当滚动时，我们要求大纲区域停靠在顶部 // 获取大纲侧边栏的元素对象var aside = document.getElementsByClassName(\"outline\")[0];// 获取大纲侧边栏的元素对象距离浏览器顶部的距离var aside_sticky_offset_top = aside.offsetTop;// 当窗口滚动会触发window.onscroll方法window.onscroll = function() &#123; // window.pageYOffset是滚动条在垂直方向上的滚动距离 // 当滚动距离大于aside_sticky_offset_top时，表示大纲侧边栏滚动到了顶部，要求大纲停靠在顶部不动 // 则可以给css增加一个class，aside-sticky if(window.pageYOffset &gt; aside_sticky_offset_top) &#123; aside.classList.add(\"aside-sticky\"); &#125; else &#123; aside.classList.remove(\"aside-sticky\"); &#125;&#125;; .aside-sticky &#123; position: sticky; top: 0; width: 100%;&#125; 继续滚动，当浏览器窗口越过某个heading标题的时候，要求将对应的大纲侧边栏的列表项设置为active活动状态。 function scrollDetactHeading() &#123; // 获取所有的heading标题对象 var headings = document.getElementsByClassName(\"heading\"); var nearestHeading = null, nearestHeadingPageYOffset = null; console.clear(); // 循环遍历所有标题对象，找出当前选择的是哪个标题 for (var i = 0; i &lt; headings.length; i++) &#123; var h = headings[i]; // 计算标题距离浏览器视窗顶部的距离 var result = h.offsetTop - window.pageYOffset; console.log(result); // 只有为0或者为负数才表示浏览器窗口顶部穿过了标题栏下的内容区域 // 并且result的负数值越大，越表示当前最近标题是谁 if (0 === result) &#123; nearestHeading = h; break &#125; else if (result &lt; 0) &#123; if (nearestHeadingPageYOffset == null || nearestHeadingPageYOffset &lt;= result) &#123; nearestHeadingPageYOffset = result; nearestHeading = h; &#125; &#125; &#125; // 如果nearestHeading不为空，表示找到了当前所选择的标题 if (null != nearestHeading) &#123; // 找到侧边栏对象，清空侧边栏对象列表项的所有活动状态 var menulist = document.querySelector(\".outline .menu-list\"); for (var i = 0; i &lt; menulist.children.length; i++) &#123; var a = menulist.children[i].getElementsByTagName(\"a\")[0]; a.classList.remove(\"is-active\"); &#125; // 找出最终活动的列表项，设置为active的状态 var activeA = document.querySelector(\"a[href='#\" + nearestHeading.id + \"']\"); activeA.classList.add(\"is-active\"); &#125;&#125; window.onscroll = function() &#123; if(window.pageYOffset &gt; aside_sticky_offset_top) &#123; aside.classList.add(\"aside-sticky\"); &#125; else &#123; aside.classList.remove(\"aside-sticky\"); &#125; // 当滚动时触发大纲滚动检测 scrollDetactHeading();&#125;; 开源地址：https://github.com/letsblogio/website-pure-html","categories":[],"tags":[{"name":"bloogle","slug":"bloogle","permalink":"http://www.cmlanche.com/tags/bloogle/"},{"name":"网页前端","slug":"网页前端","permalink":"http://www.cmlanche.com/tags/网页前端/"}]},{"title":"腾讯云建站主机的一次奇妙之旅","slug":"腾讯云建站主机的一次奇妙之旅","date":"2018-06-21T14:07:07.000Z","updated":"2018-07-17T05:19:01.000Z","comments":true,"path":"2018/06/21/腾讯云建站主机的一次奇妙之旅/","link":"","permalink":"http://www.cmlanche.com/2018/06/21/腾讯云建站主机的一次奇妙之旅/","excerpt":"","text":"十星主机 - 腾讯云建站主机 体验过无数个主机产商的虚拟主机服务，今天我把最佳虚拟主机产商颁给腾讯云，因为它给我太多惊喜。 惊喜1：配置极高腾讯云建站主机只配置了三款，基础版、专业版、旗舰版，而且网页空间最低都是40G起步，CPU独享，内存独享，不限流量，比阿里云独享的配置都高。 惊喜2：自动开启SSL数字证书，并且是免费的，浏览器https绿色标识在购买建站主机后，会有一个默认的临时域名，你会发现证书就已经签发好了，例如我购买签发的临时域名是247915467.mylightsite.com,打开后会发现自动变成https，非常棒。当你绑定域名（注意必须是在腾讯购买的域名，如果不是可以把域名转移到腾讯云来）后会自动给这个域名签发证书，自动开启https访问，例如我绑定的域名是elementor.net.cn。 惊喜3：Wordpress建站主机自动安装Wordpress当你购买wordpress建站主机，wordpress你会发现已经安装好了，已经可以访问了。 惊喜4：香港主机免备案这个其实也不算什么惊喜，因为所有的相关主机都是免备案的，但是我原先以为腾讯的主机如果是在中国大陆开展业务都是要备案的，香港主机是不需要的。 惊喜5：价格低基础班单年售价5折，只要294元，买两年4折，只要470元。而且初次购买建站主机可以领取一个购买域名送30元代金券礼包，相当于再优惠30元，这太优惠了。相比已经很便宜的阿里云独享香港主机经济版（单年售价298元，两年538元），还要优惠，并且配置更好（主要是数据空间要更好很多，腾讯云是40G，阿里云是5G）。Elementor中文网就买了两年的，这样优惠更多。 腾讯主机Review：Hostreport.cn 腾讯云年终钜惠：cloud.tencent.com 关于我 一个不想命运低头的黑衣剑士 个人博客：cmlanche.com 我的产品：主机深度评测网 CSDN个人主页：cmlanche SegmentFault个人主页：cmlanche 博客园个人主页：cmlanche","categories":[],"tags":[{"name":"腾讯云","slug":"腾讯云","permalink":"http://www.cmlanche.com/tags/腾讯云/"},{"name":"建站主机","slug":"建站主机","permalink":"http://www.cmlanche.com/tags/建站主机/"}]},{"title":"hexo自动部署到git、ftp（虚拟主机等）、云服务器的方式","slug":"hexo-deployers","date":"2018-06-20T00:19:12.000Z","updated":"2018-07-17T05:18:52.000Z","comments":true,"path":"2018/06/20/hexo-deployers/","link":"","permalink":"http://www.cmlanche.com/2018/06/20/hexo-deployers/","excerpt":"","text":"自动部署很有用，当你写完文章后，直接使用hexo d就可以自动更新你的网站了 部署到git首先你需要在你的blog下安装git deployer插件：npm install hexo-deployer-git --save，然后再把如下代码添加到你的_config.yml文件中 ### git deploydeploy: type: git repo: https://github.com/cmlanche/cmlanche.github.io.git # 你的远程仓库 branch: master # 你的远程残酷分支 message: \"hello guys\" # 每次提交的信息 需要注意的是，部署到git需要再本地安装你ssh key，也就是说允许本地进行读写远程git仓库，否则你会没权限的 部署到ftp服务器你可能会用一台虚拟主机来部署你的hexo个人站点，那么fip怎么部署? 首先你需要下载安装ftp deployer插件：npm install hexo-deployer-ftpsync --save，然后把你下面的代码贴到你的_config.yml中，注意修改ftp的相关参数。 #### ftp deploydeploy: type: ftpsync host: ftpserver # ftp服务器地址 user: ftpusername # ftp用户名 pass: xxxx # 你的ftp用户密码 remote: xxx # 你要上传到的地址，例如/wwwroot port: 21 # ftp端口，不同的ftp可能会不一样 delete: true # 上传本地文件是否删除ftp中的所有文件 verbose: true # 是否打印调试信息 ignore_errors: false # 是否忽略错误 部署到远程主机，通常如VPS或者云服务器同样要下载hexo deployer: npm install hexo-deployer-rsync --save，然后代码奉上： deploy: type: rsync host: &lt;host&gt; # 主机地址 user: &lt;user&gt; # 用户名 root: &lt;root&gt; # 要上传到的目录 port: [port] # Default is 22 delete: [true|false] # Default is true args: &lt;rsync args&gt; verbose: [true|false] # Default is true ignore_errors: [true|false] # Default is false 关于我 一个试图摆脱“地心引力”的黑衣剑士 一个主机深度评测站主：HostReport.cn 一个向往自由职业的自由人 个人博客：cmlanche.com","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.cmlanche.com/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://www.cmlanche.com/tags/git/"},{"name":"ftp","slug":"ftp","permalink":"http://www.cmlanche.com/tags/ftp/"},{"name":"云服务器","slug":"云服务器","permalink":"http://www.cmlanche.com/tags/云服务器/"}]},{"title":"静态模板方法的用法","slug":"静态模板方法的用法","date":"2018-06-20T00:04:38.000Z","updated":"2018-07-17T05:18:28.000Z","comments":true,"path":"2018/06/20/静态模板方法的用法/","link":"","permalink":"http://www.cmlanche.com/2018/06/20/静态模板方法的用法/","excerpt":"","text":"静态模板方法首先是一个静态的方法，然后有指定模板，例如 public class Utils &#123; public static void test()&#123;&#125; // 这是静态方法 public static void &lt;T&gt; test(int a)&#123;&#125; // 这是静态模板方法&#125; 我们使用静态方法是直接类名.方法名，例如Utils.test()，那静态模板方法呢？ // 假如我们的模板是StringUtils.&lt;String&gt;test(100) 这种写法我还是头一次见，感觉很新奇，所有会记录一下。 如果直接写Utils.test(100)会在java6编译不过，你需要指定模板类型，它相当于函数的一部分（通常来说函数包含函数名称、返回值、参数三个部分，而模板是第四个部分）","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.cmlanche.com/tags/java/"},{"name":"静态模板方法","slug":"静态模板方法","permalink":"http://www.cmlanche.com/tags/静态模板方法/"}]},{"title":"js判断某元素是否真的可见（以人的视角的可见）","slug":"js判断某元素是否真的可见（以人的视角的可见）","date":"2018-01-27T09:19:52.000Z","updated":"2018-01-27T13:53:00.000Z","comments":true,"path":"2018/01/27/js判断某元素是否真的可见（以人的视角的可见）/","link":"","permalink":"http://www.cmlanche.com/2018/01/27/js判断某元素是否真的可见（以人的视角的可见）/","excerpt":"","text":"代码如下： function isElementVisible(el) &#123; var rect = el.getBoundingClientRect(), vWidth = window.innerWidth || document.documentElement.clientWidth, vHeight = window.innerHeight || document.documentElement.clientHeight, efp = function (p, x, y) &#123; var els = document.elementsFromPoint(x, y); // 获取某点的所有元素, 最顶层的元素在最前面 for (var index = 0; index &lt; els.length; index++) &#123; var style = getComputedStyle(els[index]); // 如果此前的元素是半透明的，并且不是当前元素，则跳过当前元素 if (p != els[index] &amp;&amp; (style.opacity &lt; 1 || style.display == 'none' || ['collapse', 'hidden'].indexOf(el.style.visibility) == -1)) &#123; continue; &#125; else return els[index]; &#125; return els[0]; &#125;; // Return false if it's not in the viewport if (rect.right &lt; 0 || rect.bottom &lt; 0 || rect.left &gt; vWidth || rect.top &gt; vHeight) return false; return ( el.contains(efp(el, rect.left, rect.top)) || el.contains(efp(el, rect.right, rect.top)) || el.contains(efp(el, rect.right, rect.bottom)) || el.contains(efp(el, rect.left, rect.bottom))) || el.contains(efp(el, rect.left + (rect.right - rect.left) / 2, rect.top + (rect.bottom - rect.top) / 2)); &#125; 大致思路： 先判断元素是否在视窗区域内（视窗指浏览器窗口，webview的窗口） 在判断元素的四角和中心点是否在最顶层，如果有遮罩则去掉遮罩的影响（遮罩比如是透明或者半透明的元素）","categories":[],"tags":[]},{"title":"java内存泄漏分析","slug":"java内存泄漏分析","date":"2017-12-27T07:30:04.000Z","updated":"2017-12-29T10:36:05.000Z","comments":true,"path":"2017/12/27/java内存泄漏分析/","link":"","permalink":"http://www.cmlanche.com/2017/12/27/java内存泄漏分析/","excerpt":"什么是内存泄漏？内存泄漏就是一些已经不使用的对象还存在于内存之中且垃圾回收机制无法回收它们，导致它们常驻内存，会使内存消耗越来越大，最终导致程序性能变差。 java导出heap数据的方法jmap -heap pid 这个是获取某java进程的heap基本信息。 jmap -dump:format=b,file=heap.bin pid 这个是dump一份heap的内存分析状态文件，然后你用eclipse mat软件来导入这个文件，然后看看给出的分析报告。","text":"什么是内存泄漏？内存泄漏就是一些已经不使用的对象还存在于内存之中且垃圾回收机制无法回收它们，导致它们常驻内存，会使内存消耗越来越大，最终导致程序性能变差。 java导出heap数据的方法jmap -heap pid 这个是获取某java进程的heap基本信息。 jmap -dump:format=b,file=heap.bin pid 这个是dump一份heap的内存分析状态文件，然后你用eclipse mat软件来导入这个文件，然后看看给出的分析报告。 理解什么是heap（堆）先来看一幅图，java内存模型 如果你用过visualvm，就会看到heap size的一个图，如下所示： 图中的最大heapsize为2G，目前已申请的heap size为125M左右，在使用中的heapsize为67M左右，这个数据你得看懂，最大heapsize是你在启动java程序时指定的，如果没指定就jvm会有一个默认的指定，指定的方式是java -Xms1024M -Xmx2048M，其中-xms表示最小的堆大小，也就是默认启动会占用的堆大小，-xmx为最大的堆大小，也就是heap堆的容量，如果你的申请不到内存了，爆出oom错误，那就是说你的heap已经用光了，你就应该检讨为啥gc没有合理回收heap，造成内存泄漏了。 实际上，你在资源管理器中看到的内存大小它是总大小，heap只是其中的一部分，heap占用1G，资源管理器中可能是1.5G。 解决方案：优化内存使用！！！怎么优化内存使用？ 首先从外部着手，要么适当增加heap size，方法使给vm增加参数-Xmx2G（表示heap堆的最大大小为2G，其实-Xmx2048M也是2G，一个意思）；要么更换垃圾回收器，比如你可以换换g1垃圾回收器，方法是-XX:+UseG1GC，g1垃圾回收器是并发的回收期，回收效率很高。 然后从你的程序内不着手，分析你程序中占用内存大的，申请内存频繁的代码处是否有不必要的内存申请，我在我公司的itestin自动化录制工具中就发现了很多这样的案例。 关于使用g1gc垃圾回收器，上两幅图对比看下： 首先是默认的垃圾回收器（一般来说是串型） 然后是g1gc 注意String！学会StringBuilder和StringBuffer关于这三者的基础知识很多了，不赘述，给个链接自己学习：这里 我要说的就是，如果一个字符串很大，并且频繁的对它进行操作，比如replace，substring等，这样会造成很多同样大小的这样的字符串，非常消耗内存，使用StringBuilder之后，始终是对一个对象操作，不仅不需要生成额外的字符串变量而造成不必要的内存，而且可以提高执行速度！","categories":[],"tags":[]},{"title":"使用java-api在windows上打开本地html文件无法传递query参数","slug":"使用java-api在windows上打开本地html文件无法传递query参数","date":"2017-12-26T08:41:42.000Z","updated":"2018-07-17T05:19:31.000Z","comments":true,"path":"2017/12/26/使用java-api在windows上打开本地html文件无法传递query参数/","link":"","permalink":"http://www.cmlanche.com/2017/12/26/使用java-api在windows上打开本地html文件无法传递query参数/","excerpt":"","text":"使用java api，比如： awt api: Desktop.getDesktop().browse(URI.create(\"file:///c:\\\\test.html?q=abc\")); javafx api: getHostServices().showDocument(\"file:///c:\\\\test.html?q=abc\") 打开的浏览器会发现query参数q=abc无法传递到浏览器，只能单纯的打开test.html，但是mac上经过测试上述两种方式都是可以正常打开的并传递参数的。 值得一提的是，如果uri不是file:///的文件协议的话，是可以传递参数的，比如url变成http://www.baidu.com?q=abc，是能把q参数传递给浏览器。 怎么解决呢?你可以让你的本地html文件再关联一个js文件，然后打开的时候你把要传递的参数写到文件中，当第一次打开html文件时会从js读取参数，然后重新加载，这样就可以解决啦，只是会加载两次而已。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.cmlanche.com/tags/java/"}]},{"title":"JavaFx中gif图片显示内存泄漏","slug":"JavaFx中gif图片显示内存泄漏","date":"2017-12-09T10:44:40.000Z","updated":"2017-12-28T07:16:28.000Z","comments":true,"path":"2017/12/09/JavaFx中gif图片显示内存泄漏/","link":"","permalink":"http://www.cmlanche.com/2017/12/09/JavaFx中gif图片显示内存泄漏/","excerpt":"","text":"在javafx中显示gif是很方便的，直接把gif文件放到Image对象中即可，比如下代码： FileInputStream fis = new FileInputStream(new File(yourgiffile));imageview.setImage(new Image(fis))fis.close(); 显示方便，不表示能用啊！！！ 我加载一个369kb的gif文件，每次显示都会增加100M左右的内存！！！，加载一个2.8M的gif，每次都会增加300M以上的内存！！！ Oh my god!!! 简直无法忍受，各种谷歌发现以前有提过这个bug： https://bugs.openjdk.java.net/browse/JDK-8119730 https://bugs.openjdk.java.net/browse/JDK-8117172 Christian Schudt (Inactive) added a comment - 2013-08-29 05:36 I also tested with my sample code from RT-28782:With JavaFX 2.2: OutOfMemoryError after a few iterations.With JavaFX 8: No error. Memory stays low after 1000+ iterations. Permalink Alexander Kirov (Inactive) added a comment - 2013-08-29 05:58 ok, close as verified on b104 按照上面的说法，说是已经解决了，可是真解决了吗？ 不过有一点可疑的地方就是，我的gif文件尺寸都比较大，369kb的文件尺寸是1500 × 448，2.8M的文件的尺寸是2184 × 1300，查看内存占用发现堆大小涨的非常大，而使用的堆非常小，或许是因为尺寸过大，一次性申请了过大的内存导致的。","categories":[],"tags":[]},{"title":"图片压缩(tinypng)+七牛云存储客户端","slug":"图片压缩(tinypng)+七牛云存储客户端","date":"2017-12-03T03:28:41.000Z","updated":"2019-02-26T06:40:33.000Z","comments":true,"path":"2017/12/03/图片压缩(tinypng)+七牛云存储客户端/","link":"","permalink":"http://www.cmlanche.com/2017/12/03/图片压缩(tinypng)+七牛云存储客户端/","excerpt":"想法来源个人写博客，很多情况下需要图片，而图片的话需要压缩，否则占用空间太大，使得网站反应慢，而且占流量，同时减少云存储大小，减少损失，对静态网站比如hexo或者hugo直接写markdown这种形式的博客，需要上传文件取得一个文件url，那么现有就没有一个很好的方式来自动处理这种需求了。","text":"想法来源个人写博客，很多情况下需要图片，而图片的话需要压缩，否则占用空间太大，使得网站反应慢，而且占流量，同时减少云存储大小，减少损失，对静态网站比如hexo或者hugo直接写markdown这种形式的博客，需要上传文件取得一个文件url，那么现有就没有一个很好的方式来自动处理这种需求了。 ###目前想做的功能 压缩图片（支持png，gif，jpg） 图片上传（使用七牛云） 直接复制markdown文本到剪贴板（直接在客户端赋值粘贴到你用的编辑器即可） ###目前是否有这样方便的客户端呢？ 从上图来看，社区插件有很多，但大多数都是针对编辑器或者博客论坛系统的，但毕竟无法针对所有的编辑器都提供支持，像使用typora等编辑器直接编写markdown的人来说，就没办法使用七牛云了，况且需要对图片进行压缩处理，不然对你使用七牛云来说可能会涉及到付费了，对你的网站来说有负载，加载也慢。 所以开发一款集合图片上传和图片压缩的跨平台客户端是有多重要，而对这种需求没有比用Javafx更有快速有效的了。 图片压缩测试使用tinypng来测试对png图片的压缩看看就知道效果了 工欲善其事，必先利其器写博客，内容是关键，但是如果说复制图片粘贴图片都弄的那么麻烦，要手动打开各种网站去操作一系列才能完成一张图片的工作，那太繁琐了！工欲善其事，必先利其器，我的本职工作是做自动化测试的，见到这种情况必须自动化起来，所以我决定使用JavaFx来开发这样一款客户端。开源地址:https://github.com/cmlanche/javafx-qiniu-tinypng-client.git","categories":[],"tags":[{"name":"tinypng","slug":"tinypng","permalink":"http://www.cmlanche.com/tags/tinypng/"},{"name":"七牛云","slug":"七牛云","permalink":"http://www.cmlanche.com/tags/七牛云/"},{"name":"七牛云客户端","slug":"七牛云客户端","permalink":"http://www.cmlanche.com/tags/七牛云客户端/"},{"name":"个人博客客户端","slug":"个人博客客户端","permalink":"http://www.cmlanche.com/tags/个人博客客户端/"}]},{"title":"JavaFx新手教程-布局-StackPane","slug":"stackpane","date":"2017-12-02T14:10:37.000Z","updated":"2017-12-03T05:38:39.000Z","comments":true,"path":"2017/12/02/stackpane/","link":"","permalink":"http://www.cmlanche.com/2017/12/02/stackpane/","excerpt":"","text":"cmlanche: 您叫什么名字？ StackPane cmlanche: 您好，StackPane君，可以问下您在JavaFX家族中是什么地位？ stackpane君: 我可重要了，我是在JavaFx中所有布局中使用常用的，是大哥的角色，我经常罩这那帮小弟 cmlanche: 你说的小弟是指谁？ stackpane君:我小弟可多了，比如著名的vbox和hbox这对孪生兄弟，还有超级明星BorderPane，还有一些不怎么出名但是也经常使用的GridPane，TiledPane，AnchorPane等等 cmlanche: 您有什么特点吗？有那么重要吗？ stackpane君: 你知道多重宇宙吧？我就像那样， 在我的空间里，可以让我的孩子们共同拥有我的全部空间。对了， 默认情况下我让我的孩子们都是居中的，当然你可以调整它，在我的孩子上面增加一个属性StackPane.aligment，比如下面的代码使用了StackPane.alignment=&quot;TOP_LEFT&quot;，这样button1就在左上角的位置了！ &gt; &lt;StackPane xmlns=\"http://javafx.com/javafx\"&gt; xmlns:fx=\"http://javafx.com/fxml\"&gt; fx:controller=\"com.cmlanche.javafx.layouts.stackpane.StackPaneTest\"&gt; prefHeight=\"400.0\" prefWidth=\"600.0\" style=\"-fx-background-color: grey;\"&gt;&gt;&gt; &lt;Button fx:id=\"button1\" text=\"button1\" prefWidth=\"100\" prefHeight=\"200\" StackPane.alignment=\"TOP_LEFT\"&gt;&gt; &lt;/Button&gt;&gt;&gt; &lt;Button fx:id=\"button2\" text=\"button2\" prefWidth=\"200\" prefHeight=\"100\"&gt;&gt; &lt;/Button&gt;&gt; &lt;/StackPane&gt;&gt; &gt; 而且我的空间大小是充满我的父空间的。看如下图的灰色区域，都是我的空间 cmlanche: 那您有哪些应用场景吗？ stackpane君:比如说某一个区域需要共享，会被多个视图所共用，我就发挥作用啦。而且我可以轻易可以把元素居中，我总是铺满父布局的。 cmlanche: 有demo源码演示吗？ stackpane君:我的爸爸给我做了个演示例子，是开源的哦，欢迎star，github，我自己的例子在这里","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://www.cmlanche.com/tags/javafx/"},{"name":"javafx-layout","slug":"javafx-layout","permalink":"http://www.cmlanche.com/tags/javafx-layout/"},{"name":"javafx-stackpane","slug":"javafx-stackpane","permalink":"http://www.cmlanche.com/tags/javafx-stackpane/"}]},{"title":"梁文道·一千零一夜·儒学","slug":"ruxue","date":"2017-12-02T10:07:31.000Z","updated":"2017-12-02T10:29:27.000Z","comments":true,"path":"2017/12/02/ruxue/","link":"","permalink":"http://www.cmlanche.com/2017/12/02/ruxue/","excerpt":"儒家的个人始终和我们习惯的西方个人主义是不一样的观念，更加不是西方的自由主义的那套东西，儒家的个人始终是一个在社会之中的人，儒家的每一个人，每一个个体都是社会中的人，他必然是一个家庭的成员，他是一个社区邻里中的一分子，他是一个国家的一员，更是世界公民群体中的一员，更是大自然万物中的一员，每一个个人，都跟身边所有这些东西是密切联系起来的，他不是一个独立的绝对的，以己为本的一个个体。","text":"儒家的个人始终和我们习惯的西方个人主义是不一样的观念，更加不是西方的自由主义的那套东西，儒家的个人始终是一个在社会之中的人，儒家的每一个人，每一个个体都是社会中的人，他必然是一个家庭的成员，他是一个社区邻里中的一分子，他是一个国家的一员，更是世界公民群体中的一员，更是大自然万物中的一员，每一个个人，都跟身边所有这些东西是密切联系起来的，他不是一个独立的绝对的，以己为本的一个个体。 儒家特别讲究关系，要讲究名分，要讲究名位，所以我们才会听过另外一句很有名的话，叫做不在其位不谋其政，然后不在其位呢，甚至不能够作礼乐，这么听起来，儒家又好像很权威，就好像你这个人，你站在一个高位，你当领导，那你就能够说话算数，能作礼乐了，你不是领导你管那么多国家时事管那么多天下大事干什么，怪怪的种好你的地做好你的小买卖不就得了，不完全是这样，因为你还要反过来看，孔子还说什么了呢？孔子还说，“岁在其位，苟无其德，不可作礼乐”，就是说就算你有这个位置，但是你没有配得上这个位置的德行，你也是不能够作礼乐的，所以在不同的位置，人是要讲位置的，讲关系，但是每个位置，每个关系，你是不是能够在那个位置，你还要配得上那个位置，你要有那个德，那个德又是怎么来呢？就要看你对身边的人是什么样的一个状态，什么样的关系，然后同时你对身边的人是什么样的态度，你跟他如何相处，恰恰又跟你这个人自己自身的修养、学问、涵养是密切相关的，你比如说讲敬，我们现代人讲尊敬这个字，就很容易把它想象成是一个由下往上的，我看到领导说领导您好，尊敬，我看到台长，哎呀你好，尊敬，看到老板要很尊敬，这是由下对上的，但是儒家是这样子吗？不是的，你看孟子，孟子把这个敬说成是什么呢？是下对上固然要敬，但是上对下也要敬哦，上对下那个敬叫什么敬呢？那就叫做礼贤，就是上下是呼应的，所以你是不是在那个位置，你得看你配不配得上那个位置，你怎么样叫配得上在我的上位呢？那就要看你怎么样对在你下面的人，所以也就是说话我们在下面的人，也都能够决定你是不是该在那个位置，完全是靠这样相应的一个关系，这个才是儒家的真正本色。","categories":[],"tags":[{"name":"文化","slug":"文化","permalink":"http://www.cmlanche.com/tags/文化/"},{"name":"儒学","slug":"儒学","permalink":"http://www.cmlanche.com/tags/儒学/"}]},{"title":"JavaFx概要脑图","slug":"JavaFx概要脑图","date":"2017-08-25T03:50:15.000Z","updated":"2017-12-02T09:26:16.000Z","comments":true,"path":"2017/08/25/JavaFx概要脑图/","link":"","permalink":"http://www.cmlanche.com/2017/08/25/JavaFx概要脑图/","excerpt":"本脑图是我自己总结的在JavaFx开发中的要点。","text":"本脑图是我自己总结的在JavaFx开发中的要点。 如上","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://www.cmlanche.com/tags/javafx/"},{"name":"javafx脑图","slug":"javafx脑图","permalink":"http://www.cmlanche.com/tags/javafx脑图/"}]},{"title":"Jenkins自动集成小记","slug":"Jenkins自动集成小记(一)","date":"2017-08-10T14:33:02.000Z","updated":"2017-12-02T09:27:07.000Z","comments":true,"path":"2017/08/10/Jenkins自动集成小记(一)/","link":"","permalink":"http://www.cmlanche.com/2017/08/10/Jenkins自动集成小记(一)/","excerpt":"Jenkins是用来自动构建任务的，也许你还不知道什么叫自动构建任务，它的意思是可以针对某个任务进行自动化，比如你开发的某个软件，每次写完代码提交到github之后，你可以设置让Jenkins自动进行打包构建发布包或者进行Units测试，发布报告，不用你每次手工在IDE中去Build，尤其是当打包非常繁琐的时候，用自动化构建可以极大的提高工作效率。","text":"Jenkins是用来自动构建任务的，也许你还不知道什么叫自动构建任务，它的意思是可以针对某个任务进行自动化，比如你开发的某个软件，每次写完代码提交到github之后，你可以设置让Jenkins自动进行打包构建发布包或者进行Units测试，发布报告，不用你每次手工在IDE中去Build，尤其是当打包非常繁琐的时候，用自动化构建可以极大的提高工作效率。 前言公司是同事使用Jenkins做的自动化构建，非常方便，每次提交代码，自动检测打包是否成功，然后发送邮件通知，因为我们集成了findingbugs插件，在打包前还会对代码进行findingbus检索，告诉你findingbus的状态，还会生成release的发布包，非常之方便。 wement.io这个项目我想多人协作开发，自然想到了Jenkins，让大家能够配合的非常的舒服，昨天折腾了三小时，搞定了Jenkins，其中包括怎么创建一个任务，怎么设置github，和github的项目挂钩，怎么设置邮件通知。 安装Jenkins直接去Jenkins官网下载war包，我这里是直接部署在阿里云的centos7上的，然后用scp xxx.war root@yourip:/home直接从本地拷贝到云服务器上，拷贝之后直接用java -jar xxx.war就可以运行成功了，如果你期望退出命令行还不关闭Jenkins的话，就用命令nohug java -jar xxx.war(centos 用nohup)来运行包，java进程自动在后台运行了，关闭命令行窗口也不会退出程序，这样你的Jenkins就运行了，默认端口监听在8080，如果你也是用的云服务器，请确保你的8080端口是允许访问的。 当然，要运行Jenkins，你需要安装Java环境，如果你的代码仓库用git的话请安装git，分别命令如下： yum install java yum install git 还没有完，Jenkins运行成功了，你再在浏览器上打开yourip:8080跟随Jenkins安装向导，用默认提示安装完成即可，接下来就是创建任务了。 创建一个任务 选择第一性，构建一个自由风格的软件项目 然后保存即可，任务创建完成。但是如果你的项目是私有项目，你需要在你的服务器上生成ssh，然后贴到你的github上，这样做的目的是然github信任你的这个服务器，同时要注意你的Jenkins控制台，有可能要你输入ssh的证书密码。 邮件通知一般来说这个时候右键通知是没问题的，但是我今天发现我提交代码之后，任务并没有自动构建，然后看Jenkins打的log是这样的： 22:23:55 [WARNING] mvn dependency:tree -Ddetail=true and the above output.22:23:55 [WARNING] See http://maven.apache.org/plugins/maven-shade-plugin/22:23:56 [INFO] ------------------------------------------------------------------------22:23:56 [INFO] BUILD SUCCESS22:23:56 [INFO] ------------------------------------------------------------------------22:23:56 [INFO] Total time: 10.112s22:23:56 [INFO] Finished at: Thu Aug 10 22:23:56 CST 201722:23:56 [INFO] Final Memory: 20M/59M22:23:56 [INFO] ------------------------------------------------------------------------22:23:56 Archiving artifacts22:23:56 Email was triggered for: Always22:23:56 Sending email for trigger: Always22:23:56 Not sending mail to unregistered user chengming@testin.cn because your SCM claimed this was associated with a user ID ‘chengming' which your security realm does not recognize; you may need changes in your SCM plugin22:23:56 An attempt to send an e-mail to empty list of recipients, ignored.22:23:56 Finished: SUCCESS 意思是构建成功了，但是发送邮件发现提交代码的用户名是chengming而不是我在Jenkins中设置的cmlanche，然后Jenkins自动忽略了发送邮件的这个行为。 然后我在我的sourcetree中把提交代码的用户换回了cmlanche，任务自动构建，邮件发送成功！ Jenkins分享（一）小结Jenkins是一个非常方便的工具，免费开源，推荐大家都来学习，都折腾下，对你以后大有好处。我其实也是刚刚学这个，知道的还不多，还需要花很多时间去折腾，有更新的收获我会慢慢分享出来。 欢迎加入我的Java栈群：518914410，讨论有关Java的一切技术。 参考另一个小菜的文章：Jenkins+Github持续集成","categories":[],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.cmlanche.com/tags/jenkins/"}]},{"title":"JavaFx TableView疑难详解","slug":"JavaFx-TableView详解","date":"2017-06-08T02:11:14.000Z","updated":"2017-12-02T09:26:57.000Z","comments":true,"path":"2017/06/08/JavaFx-TableView详解/","link":"","permalink":"http://www.cmlanche.com/2017/06/08/JavaFx-TableView详解/","excerpt":"TableView是个十分有用的控件，适应性和灵活性非常强，可以对它进行任意的修改，比如界面样式、功能。本文将从一步步提问的方式讲解TableView","text":"TableView是个十分有用的控件，适应性和灵活性非常强，可以对它进行任意的修改，比如界面样式、功能。本文将从一步步提问的方式讲解TableView 创建已知列的TableView已知列的表格的创建，需要把TableView的TableColumn关联到模型的属性，TableView是个模板类，其实是TableView，这个T就是模型，例如下代码： // MyModel.javapublic class MyModel&#123; private String name; private String url; // getters, setters ...&#125;// init your tableViewTableColumn&lt;MyModel, String&gt; t1 = new TableColumn();// 关联MyModel中的name属性t1.setCellValueFactory(new PropertyValueFactory&lt;&gt;(\"name\")); t1.setCellFactory(p-&gt;&#123; // 创建此列的Cell的时候的回调，允许让你自己去创建&#125;); 特别要说明的是，setCellValueFactory和setCellFactory不是冲突的，我用的时候一直以为是冲突，就是只能用其中一个，另外一个就失效了，其实不是，setCellFactory它的意图是在创建这列的时候要做的事情，你可以改变TableCell的任何内容，包括UI和Value，而setCellValueFactory呢，它的重点是关联属性，从你传递给它的Model中通过对应属性的getter来获取值。在setCellFactory中的TableCell有个回调，叫updateItem，它可以获取到你设置到此Cell的值，这个值是跟setCellValueFactory所关联的属性有关。 创建动态列的TableView参考：https://community.oracle.com/thread/2474328 因为列是不定的，模型是没有属性对应的，创建列的时候你根本不知道列是什么，看如下实现代码： column.setCellValueFactory(param -&gt; &#123; ObservableList&lt;VarCell&gt; values = param.getValue(); if (columnIndex &gt;= values.size()) &#123; return new SimpleObjectProperty&lt;&gt;(null); &#125; else &#123; return new SimpleObjectProperty&lt;&gt;(param.getValue().get(columnIndex)); &#125; &#125;); 创建动态列的tableview，它的模型是一个ObservableList&lt;T&gt;，你的setCellValueFactory不能使用PropertyValueFactory，而是如上代码所示，通过列的索引来获取此列的值 [列拖动] 如何捕获列拖动事件？列拖动是tablview一个默认的自带的效果，但是并没有专门的事件给你去监听它，而是监听列的变化，方法：给tableview的columns添加Listener,判断变动列的状态是否是replaced的状态，例如： tableView.getColumns().addListener(new ListChangeListener&lt;TableColumn&lt;ObservableList&lt;VarCell&gt;, ?&gt;&gt;() &#123; @Override public void onChanged(Change&lt;? extends TableColumn&lt;ObservableList&lt;VarCell&gt;, ?&gt;&gt; change) &#123; change.next(); if (change.wasReplaced()) &#123; // 表示当前拖动过了 &#125; &#125; &#125;); [列拖动] 如何防止第一列被拖动？在上一问的基础上，实现第一列不允许被拖动的功能。 参考：https://stackoverflow.com/questions/30645606/javafx-restrict-column-rearrangement-on-drag-and-drop tableView.getColumns().addListener(new ListChangeListener&lt;TableColumn&lt;ObservableList&lt;String&gt;, ?&gt;&gt;() &#123; private boolean suspended; @Override public void onChanged(Change&lt;? extends TableColumn&lt;ObservableList&lt;String&gt;, ?&gt;&gt; change) &#123; change.next(); if (change.wasReplaced() &amp;&amp; !suspended) &#123; List&lt;TableColumn&lt;ObservableList&lt;String&gt;, ?&gt;&gt; oldList = new ArrayList&lt;&gt;(change.getRemoved()); List&lt;TableColumn&lt;ObservableList&lt;String&gt;, ?&gt;&gt; newList = new ArrayList&lt;&gt;(tableView.getColumns()); // first column changed =&gt; revert to original list if (oldList.get(0) != newList.get(0)) &#123; this.suspended = true; tableView.getColumns().setAll(oldList); this.suspended = false; &#125; &#125; &#125; &#125;); 上面的代码中有三个关键的地方，是tableview原本提供的api，一个是change.wasReplaced表示当前的变动是否被替换了，第二个是change.getRemoved，表示获取要移除掉的列，进一步的意思就是原来的列，也就是此前的tablecolumns，第三个是tableview.getColumns这个是获取现在列，有了这些信息，就可以判断，oldList.get(0)!=newList(0)，表示如果新老列的第一列不相同，表示是第一列是变动的，但是我们不允许变动，因此，调用tableview.getColumns().setAll(oldList)用来恢复原来的列。这样就禁止拖动第一列了。 [列拖动] 如何禁用列拖动效果？参考：https://stackoverflow.com/questions/22202782/how-to-prevent-tableview-from-doing-tablecolumn-re-order-in-javafx-8 给列设置一个属性：column.impl_setReorderable(false); impl_setReorderable前面带impl_前缀，表示它是一个将来可能会被删除的方法，但是为了解决目前无法解决的问题，暂时把impl的私有方法改为了public方法，参考我的博客中的如何自定义Taborder的文章，是一样的道理。 [行拖动] 如何拖动行，进行换行？参考：https://stackoverflow.com/questions/28603224/sort-tableview-with-drag-and-drop-rows 已经测试过的代码： tableView.setRowFactory(tv -&gt; &#123; TableRow&lt;ObservableList&lt;String&gt;&gt; row = new TableRow&lt;&gt;(); row.setOnDragDetected(event -&gt; &#123; log.info(\"row drag detected\"); if (!row.isEmpty()) &#123; Integer index = row.getIndex(); Dragboard db = row.startDragAndDrop(TransferMode.MOVE); db.setDragView(row.snapshot(null, null)); ClipboardContent cc = new ClipboardContent(); cc.put(SERIALIZED_MIME_TYPE, index); db.setContent(cc); event.consume(); &#125; &#125;); row.setOnDragOver(event -&gt; &#123; log.info(\"row drag over\"); Dragboard db = event.getDragboard(); if (db.hasContent(SERIALIZED_MIME_TYPE)) &#123; if (row.getIndex() != ((Integer) db.getContent(SERIALIZED_MIME_TYPE)).intValue()) &#123; event.acceptTransferModes(TransferMode.COPY_OR_MOVE); event.consume(); &#125; &#125; &#125;); row.setOnDragDropped(event -&gt; &#123; log.info(\"row drag dropped\"); Dragboard db = event.getDragboard(); if (db.hasContent(SERIALIZED_MIME_TYPE)) &#123; int draggedIndex = (Integer) db.getContent(SERIALIZED_MIME_TYPE); ObservableList&lt;String&gt; draggedPerson = tableView.getItems().remove(draggedIndex); int dropIndex; if (row.isEmpty()) &#123; dropIndex = tableView.getItems().size(); &#125; else &#123; dropIndex = row.getIndex(); &#125; tableView.getItems().add(dropIndex, draggedPerson); event.setDropCompleted(true); tableView.getSelectionModel().select(dropIndex); event.consume(); &#125; &#125;); return row; &#125;); 修改TableView样式使用css，参考如下我的测试代码 .table-view &#123; -fx-border-width: 1px; -fx-border-color: #CACACA; -fx-background-color: transparent;&#125;.table-view:focused &#123; -fx-background-color: transparent;&#125;.table-view .table-cell &#123; -fx-font-size: 12px;&#125;.table-view .filler &#123; -fx-background-color: #BDE8FF;&#125;.table-view .text &#123; -fx-text-fill: red;&#125;.table-view .column-header &#123; -fx-background-color: #BDE8FF; -fx-pref-height: 37px; -fx-border-width: 1px; -fx-border-color: #D9D9D9; -fx-border-insets: -2px -2px 0px -2px;&#125;.table-view .column-header-background .label &#123; -fx-text-fill: #363739; -fx-font-weight: normal; -fx-font-size: 12px;&#125;.table-row-cell &#123; /*行高*/ -fx-cell-size: 35px;&#125;.table-row-cell .cell &#123; -fx-alignment: center; -fx-text-fill: #333333;&#125;.table-view .table-cell:selected &#123; -fx-text-fill: white;&#125;.table-view .table-column .column-header &#123; -fx-background-color: #363739;&#125;.cell &#123; /*-fx-border-width: 0px 1px 0 0;*/ /*-fx-border-color: #CACACA;*/&#125;.table-view .scroll-bar &#123; -fx-background-color: transparent;&#125;.viewport &#123; -fx-background-color: white;&#125; 如何自定义列头，比如自己设置一个可编辑的列头呢？答案是给你的TableColumn设置setGraphic，可编辑的列头的话，你让你的graphic中有编辑框，双击显示编辑框，按enter键确认编辑，如下是一个我的实现： package com.itestin.ui.datamgt.table;import com.itestin.ui.recordNreplay.logic.CommonLogic;import javafx.beans.property.BooleanProperty;import javafx.beans.property.SimpleBooleanProperty;import javafx.beans.property.SimpleStringProperty;import javafx.beans.property.StringProperty;import javafx.geometry.Pos;import javafx.scene.control.Label;import javafx.scene.control.TableColumn;import javafx.scene.control.TextField;import javafx.scene.control.Tooltip;import javafx.scene.input.KeyCode;import javafx.scene.layout.StackPane;/** * Created by cmlanche on 2017/6/1. */public class EditColumn extends StackPane &#123; private EditColumnCallback callback; private Label label; private TextField textField; private StringProperty title; private BooleanProperty editing; private BooleanProperty editable; private BooleanProperty textFieldFocus; private TableColumn tableColumn; private String oldTitle; public EditColumn(TableColumn tableColumn) &#123; super(); this.tableColumn = tableColumn; this.init(); &#125; private void init() &#123; this.setMaxWidth(120); this.setAlignment(Pos.CENTER); this.setStyle(\"-fx-background-color: #D9D9D9;\"); label = new Label(); label.setStyle(\"-fx-font-size: 12px; -fx-text-fill: #333333;\"); textField = new TextField(); textField.getStyleClass().add(\"tablefx-header-editor\"); label.textProperty().bindBidirectional(titleProperty()); textField.textProperty().bindBidirectional(titleProperty()); label.setTooltip(new Tooltip()); label.getTooltip().textProperty().bindBidirectional(label.textProperty()); this.getChildren().addAll(label, textField); editingProperty().addListener((observable, oldValue, newValue) -&gt; &#123; if (isEditable()) &#123; if (newValue) &#123; label.setVisible(false); textField.setVisible(true); textField.setFocusTraversable(true); textField.requestFocus(); &#125; else &#123; label.setVisible(true); textField.setVisible(false); &#125; &#125; &#125;); textField.textProperty().addListener((observable, oldValue, newValue) -&gt; &#123; textField.setStyle(\"-fx-border-color: #25B3FA;\"); &#125;); this.setStyle(\"-fx-background-color: transparent;\"); textField.setOnKeyPressed(event -&gt; &#123; if (isEditing()) &#123; if (event.getCode() == KeyCode.ENTER) &#123; event.consume(); // 放置对tabview的其他列产生影响，不让消息透传 oldTitle = textField.getText(); setEditing(false); // 提交编辑 if (callback != null) &#123; callback.editCommit(tableColumn, textField.getText()); &#125; &#125; else if (event.getCode() == KeyCode.ESCAPE) &#123; setTitle(oldTitle); setEditing(false); // 取消编辑 if (callback != null) &#123; callback.cancelEdit(); &#125; &#125; else if (event.getCode() == KeyCode.TAB) &#123; setEditing(false); &#125; &#125; &#125;); textFieldFocusProperty().addListener((observable, oldValue, newValue) -&gt; &#123; if (newValue) &#123; textField.setFocusTraversable(true); textField.requestFocus(); &#125; &#125;); setEditing(false); &#125; public String getTitle() &#123; return titleProperty().get(); &#125; public StringProperty titleProperty() &#123; if (title == null) &#123; title = new SimpleStringProperty(); &#125; return title; &#125; public void setTitle(String title) &#123; this.oldTitle = title; this.titleProperty().set(title); &#125; public boolean isEditing() &#123; return editingProperty().get(); &#125; public BooleanProperty editingProperty() &#123; if (editing == null) &#123; editing = new SimpleBooleanProperty(true); &#125; return editing; &#125; public void setEditing(boolean editing) &#123; this.editingProperty().set(editing); &#125; public void setEditCallback(EditColumnCallback callback) &#123; this.callback = callback; &#125; public boolean isEditable() &#123; return editableProperty().get(); &#125; public BooleanProperty editableProperty() &#123; if (editable == null) &#123; editable = new SimpleBooleanProperty(true); &#125; return editable; &#125; public void setEditable(boolean editable) &#123; this.editableProperty().set(editable); &#125; public boolean isTextFieldFocus() &#123; return textFieldFocusProperty().get(); &#125; public BooleanProperty textFieldFocusProperty() &#123; if (textFieldFocus == null) &#123; textFieldFocus = new SimpleBooleanProperty(); &#125; return textFieldFocus; &#125; public void setTextFieldFocus(boolean textFieldFocus) &#123; this.textFieldFocusProperty().set(textFieldFocus); &#125;&#125; ​ 最后欢迎加入我的javafx探讨群：518914410本文版权原创 by cmlanche.com","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://www.cmlanche.com/tags/javafx/"},{"name":"javafx-tableview","slug":"javafx-tableview","permalink":"http://www.cmlanche.com/tags/javafx-tableview/"}]},{"title":"JavaFx新手入门布局介绍","slug":"JavaFx新手入门布局介绍","date":"2017-06-06T12:57:29.000Z","updated":"2017-12-03T08:01:23.000Z","comments":true,"path":"2017/06/06/JavaFx新手入门布局介绍/","link":"","permalink":"http://www.cmlanche.com/2017/06/06/JavaFx新手入门布局介绍/","excerpt":"JavaFx新手入门，首先应该从布局容器入手，常用的布局容器有StackPane, BorderPane, HBox, VBox等，在使用他们时，特别是手动编写fxml布局文件时，了解他们的特性可以加速你的编写过程，能够活学活用。本文一次性介绍他们的特点。","text":"JavaFx新手入门，首先应该从布局容器入手，常用的布局容器有StackPane, BorderPane, HBox, VBox等，在使用他们时，特别是手动编写fxml布局文件时，了解他们的特性可以加速你的编写过程，能够活学活用。本文一次性介绍他们的特点。 StackPane StackPane总是充满父容器，并且，它的所有子节点Node都共用StackPane所占有的区域。所以在某个区域需要变动不同的内容的时候，经常用到它。 BorderPane BorderPane同样总是充满父容器，它同时能够控制子节点在它所占空间的方位，总共有5个方位，分别是上、下、左、右、中，不需要所有的方位都有节点，但是中间总会占有一块区域，这点需要注意。BorderPane是最为常用的容器，举例，你要两列布局，你可以用在给左侧和中间的区域设置视图，或者给中间和右侧设置，如果你给左侧和右侧设置，会发现中间会空一个区域。 HBox HBox的子节点中有容器的话，高度会被拉伸到Hbox一样的高度，但是宽度是由子节点它自身决定的。 VBox VBox的决定了子节点中的宽度，子节点的高度由子节点自己决定。 GridPane GridPane是网格布局，你可以指定它的子节点处于网格的哪行哪列。","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://www.cmlanche.com/tags/javafx/"},{"name":"javafx-layout","slug":"javafx-layout","permalink":"http://www.cmlanche.com/tags/javafx-layout/"}]},{"title":"JavaFx新手入门之布局 - SplitPane分隔容器","slug":"JavaFx新手入门之布局SplitPane分隔容器","date":"2017-06-06T12:37:10.000Z","updated":"2017-12-02T09:25:59.000Z","comments":true,"path":"2017/06/06/JavaFx新手入门之布局SplitPane分隔容器/","link":"","permalink":"http://www.cmlanche.com/2017/06/06/JavaFx新手入门之布局SplitPane分隔容器/","excerpt":"JavaFx新手入门，首先应该从布局容器入手，常用的布局容器有StackPane, BorderPane, HBox, VBox等，本文介绍相对使用频率较少的SplitPane，分隔容器","text":"JavaFx新手入门，首先应该从布局容器入手，常用的布局容器有StackPane, BorderPane, HBox, VBox等，本文介绍相对使用频率较少的SplitPane，分隔容器 怎么创建分隔的视图区域？ SplitPane的一级子Node就是SplitPane所分开的一个视图区域，例如下fxml代码： &lt;?import javafx.scene.control.SplitPane?&gt;&lt;?import javafx.scene.image.Image?&gt;&lt;?import javafx.scene.image.ImageView?&gt;&lt;?import javafx.scene.layout.StackPane?&gt;&lt;?import javafx.scene.layout.VBox?&gt;&lt;StackPane fx:controller=\"sample.Controller\" xmlns:fx=\"http://javafx.com/fxml\" alignment=\"center\"&gt; &lt;SplitPane fx:id=\"splitpane\"&gt; &lt;VBox fx:id=\"left\" prefWidth=\"300\" prefHeight=\"200\" style=\"-fx-background-color: antiquewhite\"&gt; &lt;ImageView fx:id=\"image1\" preserveRatio=\"true\" pickOnBounds=\"true\"&gt; &lt;image&gt; &lt;Image url=\"@/sample/test.jpg\"/&gt; &lt;/image&gt; &lt;/ImageView&gt; &lt;/VBox&gt; &lt;VBox fx:id=\"right\" prefWidth=\"300\" prefHeight=\"300\" style=\"-fx-background-color: aquamarine\"&gt; &lt;ImageView fx:id=\"image2\" preserveRatio=\"true\" pickOnBounds=\"true\"&gt; &lt;image&gt; &lt;Image url=\"@/sample/test.jpg\"/&gt; &lt;/image&gt; &lt;/ImageView&gt; &lt;/VBox&gt; &lt;/SplitPane&gt;&lt;/StackPane&gt; SplitPane中有图片的话，怎么让ImageView随着视图区域的变化而变化？ 答案是：监听SplitPane的divider的变化，动态去改变ImageView的大小 @Override public void initialize(URL location, ResourceBundle resources)&#123; splitpane.getDividers().get(0).positionProperty().addListener((observable, oldValue, newValue) -&gt; &#123; System.out.println(newValue); int w = 600; double w1 = w * newValue.doubleValue(); double w2 = w - w1; image1.setFitWidth(w1); image2.setFitWidth(w2); &#125;); &#125;","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://www.cmlanche.com/tags/javafx/"},{"name":"splitpane","slug":"splitpane","permalink":"http://www.cmlanche.com/tags/splitpane/"}]},{"title":"初入vertx遇到的问题，可能你也遇到了","slug":"初入vertx遇到的问题，可能你也遇到了","date":"2017-05-29T04:35:39.000Z","updated":"2018-07-17T05:20:36.000Z","comments":true,"path":"2017/05/29/初入vertx遇到的问题，可能你也遇到了/","link":"","permalink":"http://www.cmlanche.com/2017/05/29/初入vertx遇到的问题，可能你也遇到了/","excerpt":"wement.io的服务器准备采用vertx来开发，vertx的开发速度非常快，有很多写好的组件，这篇文章作为学习vertx的第一篇文章，总结了一些新手可能会遇到的问题。","text":"wement.io的服务器准备采用vertx来开发，vertx的开发速度非常快，有很多写好的组件，这篇文章作为学习vertx的第一篇文章，总结了一些新手可能会遇到的问题。 vertx关于对StaticHandler的使用的理解vertx中的StaticHandle是一个非常有用的处理静态资源的处理器，里面已经帮你实现了对静态资源的各种访问设置，但是使用过程中，我把/*映射给了静态资源webroot，发现我无法添加新的route了，新route添加了都不接受事件响应。 原因就是所有请求都让StaticHanle拦截了，对StaticHanle的使用应该让它走一个新的不一样的route，比如/static/*，这样的好处是，区分开了静态资源的访问，同时保护你的资源目录，这样修改了之后，你的webroot中的网页链接应该都加上/static/前缀，因为他们都会通过StaticHanle拦截，没有/static/的话，你的server是不认识的。 怎样添加新route并指向静态资源的某个网页呢？比如/about我需要让它能够访问静态资源中的/webroot/about.html，因为我可能需要传递数据渲染网页中 代码示例： router.route(\"/about\").handler(rc-&gt;&#123; rc.reroute(\"/static/about.html\");&#125;) 对，就是reroute，同时注意你的路径，需要加/static/前缀 这是网友大神赵尘恩给的一个解释性描述 route原理就是从上往下找match的路径，reroute就是把拦截到的再重新转发一下，如果reroute到同一个path容易造成死循环，还有web是通过前缀区分的，所以如果用/*来route的话，就会把所有的请求全部拦截到，应该加上/static/*来拦截 使用vertx的oauth2客户端验证授权github 直接撸代码把 初始化： private void init() &#123; JsonObject credentials = new JsonObject() .put(\"clientID\", \"your github client id\") .put(\"clientSecret\", \"your github client secret\") .put(\"site\", \"https://github.com/login\") .put(\"tokenPath\", \"/oauth/access_token\") .put(\"authorizationPath\", \"/oauth/authorize\"); githubAuth = OAuth2Auth.create(vertx, OAuth2FlowType.AUTH_CODE, credentials); &#125; 路由： router.route(\"/login/github\").handler(routingContext -&gt; login_github(routingContext)); router.route(\"/oauth/github/code\").handler(routingContext -&gt; oauth_github_code(routingContext)); 这样简历2个路由，分别用来请求授权，获取authcode /** * 请求github登录 * * @param rc */ private void login_github(RoutingContext rc) &#123; String authorization_uri = githubAuth.authorizeURL(new JsonObject() .put(\"redirect_uri\", getPath() + \"/oauth/github/code\") .put(\"scope\", \"no_expiry\")); info(authorization_uri); rc.response().putHeader(\"Location\", authorization_uri) .setStatusCode(302) .end(); &#125; /** * 获取到github的oauth code * * @param rc */private void oauth_github_code(RoutingContext rc) &#123; String code = rc.request().getParam(\"code\"); if (code != null) &#123; githubAuth.getToken(new JsonObject().put(\"code\", code).put(\"redirect_uri\", getPath() + \"/oauth/github/token\"), res -&gt; &#123; if (res.failed()) &#123; // error, the code provided is not valid info(\"failed\"); &#125; else &#123; // save the token and continue... info(\"success\"); AccessToken token = res.result(); info(token.principal().toString()); String access_token = token.principal().getString(\"access_token\"); rc.response().end(access_token); &#125; &#125;); &#125;&#125; 80端口问题我使用的IDE是idea，测试发现让vertx去绑定80端口，提示严重: java.net.SocketException: Permission denied，如果你的端口被占用了，执行下面两个步骤 检查80端口是否被占用：lsof -i:80 如果被占用，则杀死进程：kill -9 [pid] 发现结果还是无权限，后来才发现原因：执行运行java程序没有sudo，尚不知怎么解决怎么从idea执行，不过你可以先打包出来，然后使用sudo java -jar XXX-production.jar来执行你的生成jar包 vertx给我的感觉vertx非常灵活，然后又帮你做了非常多的大家都要做的一致性的工作，一致性的意思就是，代码都是那样，是共同的，非常喜欢vertx，之前学过play2,springmvc之类的java web框架，最后都前者因为极少中文文档，需要翻墙，开发者更是少之又少，国内也没见有推广它的，后缀因为过于庞大，要学的东西太多而放弃了，一直在寻找一个像vertx一样的java web框架，现在终于找到了。 欢迎加入我们的社群讨论技术JavaFx最大最活跃的社群：518914410 Vertx中国用户组：515203212","categories":[],"tags":[{"name":"vertx","slug":"vertx","permalink":"http://www.cmlanche.com/tags/vertx/"}]},{"title":"wement.io介绍文档","slug":"wement.io介绍文档","date":"2017-05-27T10:16:45.000Z","updated":"2017-12-02T09:27:24.000Z","comments":true,"path":"2017/05/27/wement.io介绍文档/","link":"","permalink":"http://www.cmlanche.com/2017/05/27/wement.io介绍文档/","excerpt":"wement.io是我准备开源做的一个开源公共的评论服务，分为评论插件，数据存储服务，广告服务。developing中，敬请期待","text":"wement.io是我准备开源做的一个开源公共的评论服务，分为评论插件，数据存储服务，广告服务。developing中，敬请期待 What is wement.ioWement.io is a common comment system for all users whoever wants to quickly have a comment system. It has a shared powerfull server to provide data storage service. and it provide user ad service to ensure the benefits of users. Comment pluginThe goal of wement.io is provide a common comment plugin for users. you can directly use the api of wement.io to fetch or post data from wement.io. also for wordpress, z-blog, hexo, hugo and any other blog system, you can install the plugin which is already written by excellent coders, it really very simple and easy. Data storage serviceWement.io have a powerful server which is provide for data storage service, you can call api to post or get your websites comments. Ads serviceWhy you write things, but you can not get benefits, there are lots of vampires to squeeze your efforts with no paid for you. wement.io provide ads service for your website, all benefits are yours. Open source &amp; servicesWement.io is open source software and service. we’d like to invite you to get join us. wement.io","categories":[],"tags":[{"name":"wement.io","slug":"wement-io","permalink":"http://www.cmlanche.com/tags/wement-io/"}]},{"title":"记录JavaFx中非常重要的细节","slug":"JavaFx细节","date":"2017-05-08T12:48:58.000Z","updated":"2017-12-02T09:26:29.000Z","comments":true,"path":"2017/05/08/JavaFx细节/","link":"","permalink":"http://www.cmlanche.com/2017/05/08/JavaFx细节/","excerpt":"JavaFx中有一些疑难杂症，或许你以为你掌握了JavaFx，但是也未必知道我所说的这些问题和解决方案，如果有帮助到你的，可以加群最大最活跃的JavaFx社群：518914410 欢迎访问我的个人博客www.cmlanche.com","text":"JavaFx中有一些疑难杂症，或许你以为你掌握了JavaFx，但是也未必知道我所说的这些问题和解决方案，如果有帮助到你的，可以加群最大最活跃的JavaFx社群：518914410 欢迎访问我的个人博客www.cmlanche.com 已经解决的细节： 鼠标单击、双击以及多击事件（大于三次基本无意义）的执行。 从图中看出，单击一次执行一次，双击，执行两次，click中走了两次，一次clickcount为1，另一次为2，多击和双击同理 ComboBox&lt;T&gt;这个控件中的T模板类型如果换成一个JavaBean类型的话，控件所选择的值和列表显示什么数据呢？ 如果你入门了，你告诉我，会显示JavaBean对象中的toString()返回的值，是的，没错，但是加入这个JavaBean是你无法更改的，又或者说你更改它会不美观，会破坏你写代码的美感，没错，的确会这样。 然后更有经验的人会告诉我，你可以用setCellFactory来自己定义列表的值，确实列表的值变成了你想要的值，但是你同样会发现控件所选择的值还是toString()所表达的值。这怎么解决呢？ 其实ComboBox中有个叫StringConverter的东西，由它完成自定义转换，示例： public class JavaBean&#123; public String p1; public String p2;&#125;ComboBox&lt;JavaBean&gt; combox = new ComboBox&lt;&gt;();combox.setConverter(new StringConverter&lt;JavaBean&gt;()&#123; @Override public String toString(JavaBean bean)&#123; return String.format(\"%s(%s)\", bean.p1, bean.p2); &#125; @Override public JavaBean fromString(String str)&#123;return null;&#125;&#125;); 其实只要设置StringConverter就可以了，不用设置cellfactory，后者更多的是用来更改ui外观的 处于未知的细节问题： 是否可以自定义系统提供的标题栏，这样更加省事","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://www.cmlanche.com/tags/javafx/"},{"name":"javafx细节记录","slug":"javafx细节记录","permalink":"http://www.cmlanche.com/tags/javafx细节记录/"}]},{"title":"Hexo使用经验总结","slug":"hexo使用总结","date":"2017-05-06T08:28:04.000Z","updated":"2017-12-02T09:24:46.000Z","comments":true,"path":"2017/05/06/hexo使用总结/","link":"","permalink":"http://www.cmlanche.com/2017/05/06/hexo使用总结/","excerpt":"首页的文章列表显示文章摘要，而不是整段文章：Hexo主页显示摘要","text":"首页的文章列表显示文章摘要，而不是整段文章：Hexo主页显示摘要 首页的文章列表显示文章摘要，而不是整段文章：Hexo主页显示摘要 给github page设置域名后，有个过程是往你的github仓库中添加CNAME文件，写上你的域名，比如我的cmlanche.com，但是hexo每次deploy的时候会清空仓库，这样的话CNAME文件也被删除了，解决办法参考","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.cmlanche.com/tags/hexo/"}]},{"title":"JavaFx自定义Tab-Order","slug":"JavaFx自定义Tab Order","date":"2017-05-02T10:12:46.000Z","updated":"2017-12-02T09:26:44.000Z","comments":true,"path":"2017/05/02/JavaFx自定义Tab Order/","link":"","permalink":"http://www.cmlanche.com/2017/05/02/JavaFx自定义Tab Order/","excerpt":"Tab-order是什么？在界面上当你按tab键触发焦点转移的功能，这就是tab order。但是Javafx有个缺陷就是不方便自己设置tab-order的顺序。","text":"Tab-order是什么？在界面上当你按tab键触发焦点转移的功能，这就是tab order。但是Javafx有个缺陷就是不方便自己设置tab-order的顺序。 15年JDK爆出这个bug，有人提过： https://bugs.openjdk.java.net/browse/JDK-8090501 https://bugs.openjdk.java.net/browse/JDK-8091673 最后JDK中迫不得已临时把Parent类中的私有方法setImpl_traversalEngine设置为了public，让用户可以设置Node自己的tab-order顺序。 相关解决方案 stackoverflow 示例： fxml文件 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;?import javafx.scene.control.Button?&gt;&lt;?import javafx.scene.control.Label?&gt;&lt;?import javafx.scene.control.TextField?&gt;&lt;?import javafx.scene.layout.BorderPane?&gt;&lt;?import javafx.scene.layout.VBox?&gt;&lt;?import java.net.URL?&gt;&lt;BorderPane fx:id=\"root\" xmlns=\"http://javafx.com/javafx/8.0.112\" xmlns:fx=\"http://javafx.com/fxml/1\" fx:controller=\"com.cmlanche.easymvvmfx.ui.login.LoginView\"&gt; &lt;center&gt; &lt;Label style=\"-fx-font-size: 32\" text=\"hello world\"/&gt; &lt;/center&gt; &lt;bottom&gt; &lt;VBox fx:id=\"testbox\"&gt; &lt;Button fx:id=\"btn\" text=\"tray\"&gt; &lt;/Button&gt; &lt;TextField fx:id=\"t1\"/&gt; &lt;TextField fx:id=\"t2\"/&gt; &lt;TextField fx:id=\"t3\"/&gt; &lt;/VBox&gt; &lt;/bottom&gt;&lt;/BorderPane&gt; Controller文件 package com.cmlanche.easymvvmfx.ui.login;import com.fx.base.mvvm.BaseView;import com.sun.javafx.scene.traversal.Algorithm;import com.sun.javafx.scene.traversal.Direction;import com.sun.javafx.scene.traversal.ParentTraversalEngine;import com.sun.javafx.scene.traversal.TraversalContext;import javafx.fxml.FXML;import javafx.scene.Node;import javafx.scene.control.Button;import javafx.scene.control.TextField;import javafx.scene.input.MouseEvent;import javafx.scene.layout.VBox;import tray.notification.NotificationType;import tray.notification.TrayNotification;/** * Created by cmlanche on 2016/12/9. */public class LoginView extends BaseView&lt;LoginViewModel&gt; &#123; @FXML Button btn; @FXML TextField t1; @FXML TextField t2; @FXML TextField t3; @FXML VBox testbox; @Override protected void onViewCreated() &#123; t2.setFocusTraversable(true); t2.requestFocus(); testbox.setImpl_traversalEngine(new ParentTraversalEngine(testbox, new Algorithm() &#123; @Override public Node select(Node owner, Direction dir, TraversalContext context) &#123; if (\"t2\".equals(owner.getId())) &#123; return t3; &#125; else if (\"t3\".equals(owner.getId())) &#123; return t1; &#125; else if (\"t1\".equals(owner.getId())) &#123; return btn; &#125; else &#123; return t2; &#125; &#125; @Override public Node selectFirst(TraversalContext context) &#123; return t2; &#125; @Override public Node selectLast(TraversalContext context) &#123; return t1; &#125; &#125;)); &#125;&#125; 原来的tab-order顺序是btn-&gt;t1-&gt;t2-&gt;t3，现在的顺序是t2-&gt;t3-&gt;t1-&gt;btn。 需要注意的是 setImpl_traversalEngine是deprecated方法，以后可能废弃的api LoginView是我的框架easyMvvmFx构建的控制器，不能直接放在你代码中运行。 欢迎加我的qq群探讨JavaFx 最大最活跃的JavaFx社群 518914410","categories":[],"tags":[{"name":"javafx","slug":"javafx","permalink":"http://www.cmlanche.com/tags/javafx/"},{"name":"javafx-tab-order","slug":"javafx-tab-order","permalink":"http://www.cmlanche.com/tags/javafx-tab-order/"}]},{"title":"hexo网站的搭建实践与经验感触分享","slug":"hexo网站的搭建实践与经验感触分享","date":"2017-04-02T01:55:30.000Z","updated":"2017-12-02T09:25:05.000Z","comments":true,"path":"2017/04/02/hexo网站的搭建实践与经验感触分享/","link":"","permalink":"http://www.cmlanche.com/2017/04/02/hexo网站的搭建实践与经验感触分享/","excerpt":"做个人博客网站，从我粗鄙的见识认为，有三类，一类是不懂技术的小白，使用wordpress，当然我虽然是搞技术的，在很长一段时间我长期使用wordpress，因为它非常简单容易上手，傻瓜式的操作，而且内容也非常容易管理，第二类呢是使用hexo、hugo等工具自己在服务器上进行复杂的配置然后才能搭建，我呢现在属于这类，第三类呢，是在第二类的基础上，能够自己开发网站的样式，这个需要比较深厚的前端技术，你需要懂js、html、css等很多知识，还需要很多实践才能做。","text":"做个人博客网站，从我粗鄙的见识认为，有三类，一类是不懂技术的小白，使用wordpress，当然我虽然是搞技术的，在很长一段时间我长期使用wordpress，因为它非常简单容易上手，傻瓜式的操作，而且内容也非常容易管理，第二类呢是使用hexo、hugo等工具自己在服务器上进行复杂的配置然后才能搭建，我呢现在属于这类，第三类呢，是在第二类的基础上，能够自己开发网站的样式，这个需要比较深厚的前端技术，你需要懂js、html、css等很多知识，还需要很多实践才能做。 ​ 我觉得每个写个人博客的作者都是孤独的，特别是刚开始写的时候，明明没有人关注，却要一个人默默的写东西，你期待着与很多人对话，但是当时一个人都没有，一种孤独的，难以持续坚持的感觉油然而生。 ​ 做个人博客网站，从我粗鄙的见识认为，有三类，一类是不懂技术的小白，使用wordpress，当然我虽然是搞技术的，在很长一段时间我长期使用wordpress，因为它非常简单容易上手，傻瓜式的操作，而且内容也非常容易管理，第二类呢是使用hexo、hugo等工具自己在服务器上进行复杂的配置然后才能搭建，我呢现在属于这类，第三类呢，是在第二类的基础上，能够自己开发网站的样式，这个需要比较深厚的前端技术，你需要懂js、html、css等很多知识，还需要很多实践才能做。 ​ 当然上面的分类是不靠谱的，只是我脑瓜子随便一想得出的一个初步分类。我以后肯定是要制作专属自己的皮肤的，用来表达自己的个性（装逼） ​ 就不再唠嗑了，开始装逼了，哈哈哈 缘起请看这几个博客，都是我精心挑选的 ahonn 我的感触是，感叹这个作者写样式这么简洁大方，感叹这个网站响应速度这么快，第一个感叹是我以后要做的，第二个感叹是因为和我以前做的网站不一样，比我以前做的wordpress站点都快，后来我想到，主要有两个原因： 服务器响应速度快。我之前使用过最快的云主机尊云，这家网站速度还可以，其实国内的阿里云、腾讯云都不错，只是昨天，也就是2017/04/01，愚人节的这一天，腾讯活动给了一个月的免费主机，ping速度还不错，然后我的这个网站就选用这家了。 ahomn这个网站使用的是我们今天要介绍的hexo，它是一个静态网站生成器，也可以当一个服务器来运行，所以这个网站其实就是一些静态页面，我猜想是用nginx配置了服务器，请求这个网站只是返回一些静态网页而已，那自然是非常快的。 hexohexo目前来说是我接触最好用的博客建站网站了，不需要配置数据库，灵活的配置项，可以把你写的文章和你用的样式进行杂交，生成对应样式的文章等，当然你也可以自己开发样式，自己做其他的修改。 hexo之前用过几次，每次都是浅尝辄止，未得它的真正使用方式，我感觉很多个人博客都没有把这点说透，那是什么东西要说透呢，看下面的列表 你云服务器上放的东西应该是一个纯粹的静态网站，而不是用命令hexo server -p 80生成的hexo服务器 你的云服务器上应该是用其他服务器比如nginx，tomcat，appache，jetty等运行的一个环境，你只要把你的静态网站放在对应的网站路径就好 hexo怎么写文章？你以为是像wordpress那样有个管理网站给你吗？不是，hexo它完全是一种纯命令行形式的工具，你需要用专业的文字编辑工具去写，这里推荐大家使用Typora(我也是今天才真正投入使用，真正认为它是神器)，是我最好用的markdown神器 我的神器有如下几个，我都分享给你们 Java最佳开发神器，idea 写前端最佳开发神器，webstorm 写markdown的最佳神器，Typora，这个要重点介绍下，下了好久了这个，但是一直没用起来，我以为没有实施预览，今天要写文章再次拿来使用，发现他的编辑与预览是同时产生的，这个真是牛啊，体验超级棒👍，这样的话，markdown语法也是很快就学会了，以后就不怕写不了牛逼哄哄的markdown了（以前看到大牛写的markdown那真是一个羡慕啊，无法言语啊） UML/ER图/代码生成神器，Visual Paradigm，这个网上没有破解，我只好痛心买了注册码，$349，好心疼，有按月付费的，但是我觉得我以后长期用，长痛不如短痛就买了 API文档编写与生成代码神器 Swagger,这绝壁是神器，能让你快速开发你的服务，同时写好文档和测试，太牛逼了这个，现在也是特别火 思维导图软件 Freemind，这个是免费的，从我大学就开始用了，但是当时没有领略到它加上快捷键之后是如此的简单便捷，我深深的爱上了这款软件 hexo文章怎么发布呢，使用命令hexo deploy，但是你需要配置你博客目录下的一个文件_config.yml，并配置下你要发布你本地网站上的文章到指定的服务器（发布前用命令hexo generate生成静态网站，在目录public下），怎么配置？这个分不同的服务器。 我测试过git和我自己的云服务器rsync（找到你的deploy位置） git配置: deploy: ​ type: git ​ repo: https://github.com/cmlanche/cmlanche.github.io.git ​ branch: master ​ message: “hello guys” rsync deploy: ​ type: rsync ​ host: 123.207.x.x(这里隐藏我的服务器ip，免得被很多人拿来测试了) ​ user: root ​ root: /root ​ port: 22 ​ delete: true ​ verbose: true ​ ignore_error: false 这种方式的话后边会要求你输入服务器密码的 测试发现不能同时又两个deploy，这是我比较缺憾的，比较不满意的地方。 你写的文章怎么到你的云服务器或者github上了呢？再次重复下，你写文章，先发布（怎么发布？你只要把你写的markdown文件移动或者复制到你的博客根目录下的/source/_posts/目录下即可，注意标题格式）到你的本地环境的hexo上，并用hexo generate生成静态完整，再配置好_config.yml中的deploy选项，使用命令hexo deploy完成发布，这个过程看似繁琐，其实作为一个资深技术人来说，这是你应该做的，没必要用什么图形工具，那太low了，对不对？ 总结 发现我对工具往往浅尝辄止，类似的事情发生太多，就上面说的freemind，typora，hexo，没有深入去实践，当初都给他们定下不好用的标签，实际上你错了 既然这样一套成熟的开发方式已经摸熟了，以后就要坚持写博客，把我认为最有价值的内容带给大家，期待大家的关注","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.cmlanche.com/tags/hexo/"}]}]}